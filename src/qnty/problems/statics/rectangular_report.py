"""
Report generator for rectangular method problems.

This module provides a dedicated report generator for vector resolution problems
solved using the rectangular (Cartesian) method. LaTeX is the source of truth -
Markdown is derived from the same data model.

Key Design:
1. A shared data model represents the report content
2. LaTeX renderer produces LaTeX output
3. Markdown renderer produces Markdown output (derived from same data)
4. PDF is generated by compiling LaTeX
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING

from ...equations.base import latex_name

if TYPE_CHECKING:
    from .rectangular_solver import ComponentResult, RectangularMethodProblem, ResultantResult


def _get_float_value(qty) -> float:
    """Extract float value from a Quantity, using magnitude() if available."""
    if hasattr(qty, "magnitude"):
        val = qty.magnitude()
        if val is None:
            raise ValueError(f"Quantity {qty} has None magnitude")
        return val
    val = qty.value
    if val is None:
        raise ValueError(f"Quantity {qty} has None value")
    return float(val)


# =============================================================================
# Data Model
# =============================================================================


@dataclass
class VectorRow:
    """Data for a vector table row."""

    name: str  # e.g., "F_1", "F_R"
    mag: str  # formatted magnitude
    angle: str  # formatted angle
    ref: str  # reference axis, e.g., "+x", "-x"
    x_comp: str  # x-component
    y_comp: str  # y-component


@dataclass
class SolutionStepData:
    """Data for a solution step."""

    number: int
    target: str  # What we're solving for (LaTeX)
    substitution: str  # The math steps (LaTeX)


@dataclass
class RectangularReportModel:
    """
    Complete data model for a rectangular method report.

    This is the single source of truth - both LaTeX and Markdown
    renderers work from this model.
    """

    title: str
    vectors: list[VectorRow]
    solution_steps: list[SolutionStepData]
    resultant: VectorRow | None = None


# =============================================================================
# Report Builder
# =============================================================================


def build_report_model(problem: "RectangularMethodProblem", sig_figs: int = 3) -> RectangularReportModel:
    """
    Build the report data model from a solved problem.

    Args:
        problem: Solved RectangularMethodProblem
        sig_figs: Number of significant figures for formatting

    Returns:
        RectangularReportModel ready for rendering
    """
    if problem.result is None:
        raise ValueError("Problem must be solved before generating report")

    # Build vector rows
    vectors: list[VectorRow] = []
    solution_steps: list[SolutionStepData] = []
    step_num = 1

    for comp in problem.result.components:
        # Format values
        mag_val = _get_float_value(comp.magnitude)
        angle_val = _get_float_value(comp.angle)
        x_val = _get_float_value(comp.x_component)
        y_val = _get_float_value(comp.y_component)

        # Get units
        mag_unit = comp.magnitude.preferred.symbol if comp.magnitude.preferred else "N"
        angle_unit = comp.angle.preferred.symbol if comp.angle.preferred else "deg"
        x_unit = comp.x_component.preferred.symbol if comp.x_component.preferred else "N"
        y_unit = comp.y_component.preferred.symbol if comp.y_component.preferred else "N"

        vectors.append(
            VectorRow(
                name=comp.vector_name,
                mag=f"{mag_val:.{sig_figs}g} {mag_unit}",
                angle=f"{angle_val:.{sig_figs}g} {angle_unit}",
                ref=comp.angle_wrt,
                x_comp=f"{x_val:.{sig_figs}g} {x_unit}",
                y_comp=f"{y_val:.{sig_figs}g} {y_unit}",
            )
        )

        # Add solution step for this vector
        vec_latex = latex_name(comp.vector_name)
        solution_steps.append(
            SolutionStepData(
                number=step_num,
                target=f"({vec_latex})_x, ({vec_latex})_y",
                substitution=_format_component_step(comp, sig_figs),
            )
        )
        step_num += 1

    # Build resultant row if present
    resultant = None
    if problem.result.resultant is not None:
        res = problem.result.resultant
        x_val = _get_float_value(res.x_sum)
        y_val = _get_float_value(res.y_sum)
        mag_val = _get_float_value(res.magnitude)
        angle_val = _get_float_value(res.angle)

        x_unit = res.x_sum.preferred.symbol if res.x_sum.preferred else "N"
        angle_unit = res.angle.preferred.symbol if res.angle.preferred else "rad"

        resultant = VectorRow(
            name="F_R",
            mag=f"{mag_val:.{sig_figs}g} {x_unit}",
            angle=f"{angle_val:.{sig_figs}g} {angle_unit}",
            ref="+x",
            x_comp=f"{x_val:.{sig_figs}g} {x_unit}",
            y_comp=f"{y_val:.{sig_figs}g} {x_unit}",
        )

        # Add solution step for resultant
        solution_steps.append(
            SolutionStepData(
                number=step_num,
                target="|F_R|, \\theta_R",
                substitution=_format_resultant_step(res, sig_figs),
            )
        )

    return RectangularReportModel(
        title=problem.name,
        vectors=vectors,
        solution_steps=solution_steps,
        resultant=resultant,
    )


def _format_component_step(comp: "ComponentResult", sig_figs: int) -> str:
    """Format the solution step for component resolution."""
    vec_latex = latex_name(comp.vector_name)
    mag_val = _get_float_value(comp.magnitude)

    # Get angle in degrees for display
    if hasattr(comp.angle, "to_unit"):
        angle_deg = _get_float_value(comp.angle.to_unit("degree"))
    else:
        angle_deg = _get_float_value(comp.angle)

    x_val = _get_float_value(comp.x_component)
    y_val = _get_float_value(comp.y_component)

    unit = comp.magnitude.preferred.symbol if comp.magnitude.preferred else "N"

    return (
        f"({vec_latex})_x = {mag_val:.{sig_figs}g} \\cos({angle_deg:.{sig_figs}g}^\\circ) = {x_val:.{sig_figs}g} \\text{{ {unit}}} \\\\\n"
        f"({vec_latex})_y = {mag_val:.{sig_figs}g} \\sin({angle_deg:.{sig_figs}g}^\\circ) = {y_val:.{sig_figs}g} \\text{{ {unit}}}"
    )


def _format_resultant_step(res: "ResultantResult", sig_figs: int) -> str:
    """Format the solution step for resultant computation."""
    x_val = _get_float_value(res.x_sum)
    y_val = _get_float_value(res.y_sum)
    mag_val = _get_float_value(res.magnitude)
    angle_val = _get_float_value(res.angle)

    unit = res.x_sum.preferred.symbol if res.x_sum.preferred else "N"

    return (
        f"(F_R)_x = \\Sigma F_x = {x_val:.{sig_figs}g} \\text{{ {unit}}} \\\\\n"
        f"(F_R)_y = \\Sigma F_y = {y_val:.{sig_figs}g} \\text{{ {unit}}} \\\\\n"
        f"|F_R| = \\sqrt{{(F_R)_x^2 + (F_R)_y^2}} = {mag_val:.{sig_figs}g} \\text{{ {unit}}} \\\\\n"
        f"\\theta_R = \\arctan\\left(\\frac{{(F_R)_y}}{{(F_R)_x}}\\right) = {angle_val:.{sig_figs}g} \\text{{ rad}}"
    )


# =============================================================================
# Markdown Renderer
# =============================================================================


def render_markdown(model: RectangularReportModel) -> str:
    """
    Render the report model to Markdown format.

    Args:
        model: RectangularReportModel to render

    Returns:
        Markdown string
    """
    lines = [
        f"# {model.title}",
        "",
        "## Input Vectors",
        "",
        "| Vector | Magnitude | Angle | Reference |",
        "|--------|-----------|-------|-----------|",
    ]

    for vec in model.vectors:
        lines.append(f"| ${latex_name(vec.name)}$ | {vec.mag} | {vec.angle} | {vec.ref} |")

    lines.extend([
        "",
        "## Rectangular Components",
        "",
        "| Vector | x-component | y-component |",
        "|--------|-------------|-------------|",
    ])

    for vec in model.vectors:
        lines.append(f"| ${latex_name(vec.name)}$ | {vec.x_comp} | {vec.y_comp} |")

    if model.resultant:
        lines.extend([
            "",
            "## Resultant",
            "",
            "| Vector | x-component | y-component | Magnitude | Angle |",
            "|--------|-------------|-------------|-----------|-------|",
            f"| ${latex_name(model.resultant.name)}$ | {model.resultant.x_comp} | {model.resultant.y_comp} | {model.resultant.mag} | {model.resultant.angle} |",
        ])

    lines.extend([
        "",
        "## Solution Steps",
        "",
    ])

    for step in model.solution_steps:
        lines.append(f"**Step {step.number}**: Solve for ${step.target}$")
        lines.append("")
        lines.append(f"$$\n{step.substitution}\n$$")
        lines.append("")

    return "\n".join(lines)


# =============================================================================
# LaTeX Renderer
# =============================================================================


def render_latex(model: RectangularReportModel) -> str:
    """
    Render the report model to LaTeX format.

    Args:
        model: RectangularReportModel to render

    Returns:
        LaTeX string
    """
    lines = [
        r"\documentclass{article}",
        r"\usepackage{amsmath}",
        r"\usepackage{booktabs}",
        r"\begin{document}",
        "",
        f"\\section{{{model.title}}}",
        "",
        r"\subsection{Input Vectors}",
        "",
        r"\begin{tabular}{lccc}",
        r"\toprule",
        r"Vector & Magnitude & Angle & Reference \\",
        r"\midrule",
    ]

    for vec in model.vectors:
        lines.append(f"${latex_name(vec.name)}$ & {vec.mag} & {vec.angle} & {vec.ref} \\\\")

    lines.extend([
        r"\bottomrule",
        r"\end{tabular}",
        "",
        r"\subsection{Rectangular Components}",
        "",
        r"\begin{tabular}{lcc}",
        r"\toprule",
        r"Vector & $x$-component & $y$-component \\",
        r"\midrule",
    ])

    for vec in model.vectors:
        lines.append(f"${latex_name(vec.name)}$ & {vec.x_comp} & {vec.y_comp} \\\\")

    lines.extend([
        r"\bottomrule",
        r"\end{tabular}",
    ])

    if model.resultant:
        lines.extend([
            "",
            r"\subsection{Resultant}",
            "",
            r"\begin{tabular}{lcccc}",
            r"\toprule",
            r"Vector & $x$-component & $y$-component & Magnitude & Angle \\",
            r"\midrule",
            f"${latex_name(model.resultant.name)}$ & {model.resultant.x_comp} & {model.resultant.y_comp} & {model.resultant.mag} & {model.resultant.angle} \\\\",
            r"\bottomrule",
            r"\end{tabular}",
        ])

    lines.extend([
        "",
        r"\subsection{Solution Steps}",
        "",
    ])

    for step in model.solution_steps:
        lines.append(f"\\textbf{{Step {step.number}}}: Solve for ${step.target}$")
        lines.append("")
        lines.append(r"\begin{align*}")
        lines.append(step.substitution)
        lines.append(r"\end{align*}")
        lines.append("")

    lines.append(r"\end{document}")

    return "\n".join(lines)


# =============================================================================
# Report Generation
# =============================================================================


def generate_report(
    problem: "RectangularMethodProblem",
    output_dir: Path | str | None = None,
    formats: list[str] | None = None,
    sig_figs: int = 3,
) -> dict[str, str]:
    """
    Generate reports for a solved rectangular method problem.

    Args:
        problem: Solved RectangularMethodProblem
        output_dir: Directory to write files (if None, returns content only)
        formats: List of formats to generate ("md", "tex", "pdf")
        sig_figs: Number of significant figures

    Returns:
        Dict mapping format -> content (or file path if output_dir provided)
    """
    if formats is None:
        formats = ["md", "tex"]

    model = build_report_model(problem, sig_figs)
    results = {}

    if "md" in formats:
        md_content = render_markdown(model)
        results["md"] = md_content
        if output_dir:
            output_path = Path(output_dir) / f"{problem.name.replace(' ', '_')}.md"
            output_path.write_text(md_content)
            results["md"] = str(output_path)

    if "tex" in formats:
        tex_content = render_latex(model)
        results["tex"] = tex_content
        if output_dir:
            output_path = Path(output_dir) / f"{problem.name.replace(' ', '_')}.tex"
            output_path.write_text(tex_content)
            results["tex"] = str(output_path)

    return results
