"""
Report generator for rectangular method problems.

This module provides a dedicated report generator for vector resolution problems
solved using the rectangular (Cartesian) method. LaTeX is the source of truth -
Markdown is derived from the same data model.

Key Design:
1. A shared data model represents the report content
2. LaTeX renderer produces LaTeX output
3. Markdown renderer produces Markdown output (derived from same data)
4. PDF is generated by compiling LaTeX

The report follows the same format as parallelogram_report.py:
1. Calculate the components of each vector using trigonometric functions
2. Sum components to get the resultant
3. Calculate the magnitude of the resultant using Pythagorean theorem
4. Calculate the direction of the resultant using inverse tangent
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING

from ...equations.base import latex_name
from .report_utils import (
    clean_latex_alignment_markers,
    compile_latex_to_pdf,
    convert_to_latex_macros,
    format_substitution_md,
)
from .report_utils import (
    format_reference as _format_reference,
)

if TYPE_CHECKING:
    from .cartesian_solver import RectangularMethodProblem


def _get_float_value(qty) -> float:
    """Extract float value from a Quantity, using magnitude() if available."""
    if hasattr(qty, "magnitude"):
        val = qty.magnitude()
        if val is None:
            raise ValueError(f"Quantity {qty} has None magnitude")
        return val
    val = qty.value
    if val is None:
        raise ValueError(f"Quantity {qty} has None value")
    return float(val)


# =============================================================================
# Data Model
# =============================================================================


@dataclass
class InputVectorRow:
    """Data for an input vector in the Problem Setup table (given info only)."""

    name: str  # e.g., "F_1", "F_2"
    mag: str  # formatted magnitude
    angle: str  # formatted angle
    ref: str  # reference axis, e.g., "+x", "-y"


@dataclass
class ComponentRow:
    """Data for a vector's calculated components."""

    name: str  # e.g., "F_1", "F_2", "F_R"
    x_comp: str  # x-component
    y_comp: str  # y-component


@dataclass
class ResultRow:
    """Data for the resultant vector in the Results table."""

    name: str  # "F_R"
    x_comp: str  # x-component
    y_comp: str  # y-component
    mag: str  # magnitude
    angle: str  # angle in degrees from +x


@dataclass
class DiagramVectorData:
    """Data for a vector in the TikZ diagram."""

    name: str  # e.g., "F_1"
    magnitude: float  # Magnitude value (can be negative)
    angle_deg: float  # Absolute angle from +x in degrees
    angle_ref: float  # Angle as defined in problem (relative to reference)
    angle_wrt: str  # Reference axis (e.g., "+x", "+y")


@dataclass
class EquationData:
    """Data for an equation in the equations list."""

    latex: str  # LaTeX representation


@dataclass
class SolutionStepData:
    """Data for a solution step."""

    number: int
    target: str  # What we're solving for (LaTeX)
    substitution: str  # The math steps (LaTeX)


@dataclass
class RectangularReportModel:
    """
    Complete data model for a rectangular method report.

    This is the single source of truth - both LaTeX and Markdown
    renderers work from this model.
    """

    title: str
    input_vectors: list[InputVectorRow]  # Problem Setup: given info only
    diagram_vectors: list[DiagramVectorData]  # For TikZ diagram
    equations: list[EquationData]
    solution_steps: list[SolutionStepData]
    result: ResultRow | None = None  # Final resultant with components
    unit: str = "N"


# =============================================================================
# Report Builder
# =============================================================================


def build_report_model(problem: RectangularMethodProblem, sig_figs: int = 1) -> RectangularReportModel:
    """
    Build the report data model from a solved problem.

    Args:
        problem: Solved RectangularMethodProblem
        sig_figs: Number of significant figures for formatting

    Returns:
        RectangularReportModel ready for rendering
    """
    if problem.result is None:
        raise ValueError("Problem must be solved before generating report")

    # Determine unit from first component
    unit = "N"
    if problem.result.components:
        first_comp = problem.result.components[0]
        if first_comp.magnitude.preferred:
            unit = first_comp.magnitude.preferred.symbol

    # Build input vector rows (Problem Setup - given info only)
    input_vectors: list[InputVectorRow] = []
    diagram_vectors: list[DiagramVectorData] = []

    for comp in problem.result.components:
        # Format values for input table
        mag_val = _get_float_value(comp.magnitude)
        angle_val = _get_float_value(comp.angle)

        input_vectors.append(
            InputVectorRow(
                name=comp.vector_name,
                mag=f"{mag_val:.{sig_figs}f}",
                angle=f"{angle_val:.{sig_figs}f}",
                ref=_format_reference(comp.angle_wrt),
            )
        )

        # Build diagram data
        diagram_vectors.append(
            DiagramVectorData(
                name=comp.vector_name,
                magnitude=mag_val,
                angle_deg=comp.abs_angle_deg,
                angle_ref=angle_val,
                angle_wrt=comp.angle_wrt,
            )
        )

    # Build equations list from solving_history
    equations: list[EquationData] = []
    seen_equations = set()
    for step in problem.solving_history:
        eq_str = step.get("equation_for_list", "")
        if eq_str and eq_str not in seen_equations:
            equations.append(EquationData(latex=eq_str))
            seen_equations.add(eq_str)

    # Build solution steps from solving_history
    solution_steps: list[SolutionStepData] = []
    for i, step in enumerate(problem.solving_history, 1):
        target = step.get("target", "Unknown")
        substitution = step.get("substitution", "")
        solution_steps.append(
            SolutionStepData(
                number=i,
                target=target,
                substitution=substitution,
            )
        )

    # Build result row if present
    result = None
    if problem.result.resultant is not None:
        import math

        res = problem.result.resultant
        x_val = _get_float_value(res.x_sum)
        y_val = _get_float_value(res.y_sum)
        mag_val = _get_float_value(res.magnitude)
        angle_rad = _get_float_value(res.angle)
        angle_deg = math.degrees(angle_rad)

        result = ResultRow(
            name="F_R",
            x_comp=f"{x_val:.{sig_figs}f}",
            y_comp=f"{y_val:.{sig_figs}f}",
            mag=f"{mag_val:.{sig_figs}f}",
            angle=f"{angle_deg:.2f}",
        )

    return RectangularReportModel(
        title=problem.name,
        input_vectors=input_vectors,
        diagram_vectors=diagram_vectors,
        equations=equations,
        solution_steps=solution_steps,
        result=result,
        unit=unit,
    )


# =============================================================================
# LaTeX Renderer
# =============================================================================


class LaTeXRenderer:
    """Render RectangularReportModel to LaTeX."""

    def render(self, data: RectangularReportModel) -> str:
        """Render the complete LaTeX document in compact single-page layout."""
        preamble = self._render_preamble(data)
        problem_setup_diagram = self._render_problem_setup_diagram(data)
        variables_table = self._render_variables_table(data)
        equations = self._render_equations_section(data)
        solution = self._render_steps_section(data)
        results_table = self._render_results_table(data)
        results_diagram = self._render_results_diagram(data)
        disclaimer = self._render_disclaimer()

        sign_convention = r"{\scriptsize \textit{Vector sign convention used to define vector direction: Positive angles rotate counterclockwise, negative angles rotate clockwise. Positive magnitudes point outward from the origin, negative magnitudes point inward.}}"

        return rf"""{preamble}
\textbf{{\underline{{Problem Setup}}}}\\[0.3em]
{sign_convention}\\[0.5em]
\noindent
\begin{{minipage}}[c]{{0.32\textwidth}}
{variables_table}
\end{{minipage}}%
\hfill
\begin{{minipage}}[c]{{0.65\textwidth}}
\centering
{problem_setup_diagram}
\end{{minipage}}

\vspace{{0.5em}}
{equations}

\vspace{{0.5em}}
{solution}

\vspace{{0.5em}}
\textbf{{\underline{{Results}}}}\\[0.5em]
\noindent
\begin{{minipage}}[c]{{0.45\textwidth}}
{results_table}
\end{{minipage}}%
\hfill
\begin{{minipage}}[c]{{0.52\textwidth}}
\centering
{results_diagram}
\end{{minipage}}
{disclaimer}"""

    def _render_preamble(self, data: RectangularReportModel) -> str:
        """Render LaTeX preamble with TikZ support."""
        return rf"""\documentclass[10pt,a4paper]{{article}}
\usepackage{{amsmath}}
\usepackage{{amssymb}}
\usepackage{{booktabs}}
\usepackage{{tabularx}}
\usepackage{{geometry}}
\geometry{{margin=0.6in,top=0.5in,bottom=0.5in}}
\usepackage{{enumitem}}
\usepackage{{siunitx}}
\usepackage{{tikz}}
\usepackage{{xcolor}}
\usetikzlibrary{{calc,arrows.meta}}
\setlength{{\parindent}}{{0pt}}
\setlength{{\parskip}}{{0.3em}}

% Vector notation
\newcommand{{\vv}}[1]{{\vec{{#1}}}}
\newcommand{{\magn}}[1]{{|#1|}}

% TikZ styles for vector diagrams
\colorlet{{vec_f1}}{{blue!80!black}}
\colorlet{{vec_f2}}{{red!80!black}}
\colorlet{{vec_fr}}{{green!60!black}}
\tikzset{{
    vector/.style={{-{{Stealth[length=2.5mm,width=1.5mm]}},thick}},
}}

\begin{{document}}
\begin{{center}}
\textbf{{\large Engineering Calculation Report: {data.title}}}\\[0.3em]
\small Generated: {{{{GENERATED_DATE}}}}
\end{{center}}
\vspace{{-0.5em}}
\hrule
\vspace{{0.5em}}
"""

    def _render_problem_setup_diagram(self, data: RectangularReportModel) -> str:
        """Render TikZ diagram showing input vectors (F_1, F_2 only, not F_R)."""
        from .tikz_diagram import (
            RectangularVectorData,
            build_rectangular_setup_diagram,
            render_rectangular_setup_tikz,
        )

        if not data.diagram_vectors:
            return ""

        # Convert DiagramVectorData to RectangularVectorData
        rect_vectors = [
            RectangularVectorData(
                name=v.name,
                magnitude=v.magnitude,
                angle_deg=v.angle_deg,
                angle_ref=v.angle_ref,
                angle_wrt=v.angle_wrt,
            )
            for v in data.diagram_vectors
        ]

        diagram = build_rectangular_setup_diagram(rect_vectors, data.unit)
        return render_rectangular_setup_tikz(diagram)

    def _render_variables_table(self, data: RectangularReportModel) -> str:
        """Render compact variables table (given info only: magnitude, angle, reference)."""
        rows = self._format_input_vector_rows(data.input_vectors)

        return rf"""\begin{{tabular}}{{lSSl}}
\toprule
Vector & {{$\magn{{\vv{{F}}}}$ ({data.unit})}} & {{$\theta$ (deg)}} & Ref \\
\midrule
{chr(10).join(rows)}
\bottomrule
\end{{tabular}}"""

    def _format_vec_name(self, name: str) -> str:
        """Format vector name: F_1 -> $\\vv{F_1}$"""
        formatted_name = latex_name(name)
        return f"$\\vv{{{formatted_name}}}$"

    def _format_input_vector_rows(self, vectors: list[InputVectorRow]) -> list[str]:
        """Format input vector data into LaTeX table rows."""
        rows = []
        for v in vectors:
            name_latex = self._format_vec_name(v.name)
            rows.append(f"{name_latex} & {v.mag} & {v.angle} & {v.ref} \\\\")
        return rows

    def _render_results_table(self, data: RectangularReportModel) -> str:
        """Render compact results table."""
        if data.result is None:
            return ""

        r = data.result
        name_latex = self._format_vec_name(r.name)

        return rf"""\begin{{tabular}}{{lSSSS}}
\toprule
Vector & {{$F_x$ ({data.unit})}} & {{$F_y$ ({data.unit})}} & {{$\magn{{\vv{{F}}}}$ ({data.unit})}} & {{$\theta$ (deg)}} \\
\midrule
{name_latex} & {r.x_comp} & {r.y_comp} & {r.mag} & {r.angle} \\
\bottomrule
\end{{tabular}}"""

    def _render_results_diagram(self, data: RectangularReportModel) -> str:
        """Render TikZ diagram showing the resultant vector F_R."""
        from .tikz_diagram import (
            ResultantVectorData,
            build_rectangular_result_diagram,
            render_rectangular_result_tikz,
        )

        if data.result is None:
            return ""

        r = data.result
        resultant = ResultantVectorData(
            name=r.name,
            x_comp=float(r.x_comp),
            y_comp=float(r.y_comp),
            magnitude=float(r.mag),
            angle_deg=float(r.angle),
        )

        diagram = build_rectangular_result_diagram(resultant, data.unit)
        return render_rectangular_result_tikz(diagram)

    def _render_equations_section(self, data: RectangularReportModel) -> str:
        """Render equations used section with each equation on its own line."""
        items = []
        for i, eq in enumerate(data.equations, 1):
            latex = self._convert_to_latex_macros(eq.latex)
            items.append(f"\\hspace*{{1em}}({i}) $\\displaystyle {latex}$")

        equations_str = "\\\\[0.5em]\n".join(items)
        return rf"""
\textbf{{\underline{{Equations Used}}}}\\[0.5em]
{equations_str}
"""

    def _convert_to_latex_macros(self, eq: str) -> str:
        """Convert equation string to use LaTeX macros."""
        return convert_to_latex_macros(eq)

    def _render_steps_section(self, data: RectangularReportModel) -> str:
        """Render step-by-step solution section in compact format."""
        steps_latex = []
        for step in data.solution_steps:
            target_latex = self._convert_to_latex_macros(step.target)
            sub_latex = self._format_substitution_compact(step.substitution)

            step_latex = rf"""
\hspace*{{1em}}\textbf{{Step {step.number}:}} ${target_latex}$\\[0.2em]
\hspace*{{2em}}${sub_latex}$
"""
            steps_latex.append(step_latex)

        steps_str = "\\\\[0.3em]\n".join(s.strip() for s in steps_latex)
        return f"\\textbf{{\\underline{{Solution}}}}\\\\[0.5em]\n{steps_str}"

    def _format_substitution_compact(self, sub: str) -> str:
        """Format substitution in compact single-line format."""
        if not sub:
            return ""

        # Convert to LaTeX macros first
        sub = self._convert_to_latex_macros(sub)

        # Clean up alignment markers and return as aligned equations on one line
        lines = sub.strip().split("\n")
        result_parts = clean_latex_alignment_markers(lines)
        return " = ".join(result_parts)

    def _render_disclaimer(self) -> str:
        """Render compact disclaimer section."""
        return r"""
\vspace{0.5em}
\hrule
\vspace{0.3em}
\begin{center}
\footnotesize
\textbf{Signatures:} Calc. By: \rule{2cm}{0.4pt} \quad Rev. By: \rule{2cm}{0.4pt} \quad Appr. By: \rule{2cm}{0.4pt}
\vspace{0.3em}

\scriptsize\textit{Generated by Qnty Library (Beta). Independent verification required. Users assume full responsibility.}
\end{center}
\end{document}"""


# =============================================================================
# Markdown Renderer
# =============================================================================


class MarkdownRenderer:
    """Render RectangularReportModel to Markdown."""

    def render(self, data: RectangularReportModel) -> str:
        """Render the complete Markdown document."""
        parts = [
            self._render_header(data),
            self._render_variables_section(data),
            self._render_equations_section(data),
            self._render_steps_section(data),
            self._render_results_section(data),
            self._render_disclaimer(),
        ]
        return "\n".join(parts)

    def _render_header(self, data: RectangularReportModel) -> str:
        """Render Markdown header."""
        return f"""# Engineering Calculation Report: {data.title}

**Generated:** {{{{GENERATED_DATETIME}}}}
"""

    def _render_input_vector_table(self, vectors: list[InputVectorRow], unit: str) -> str:
        """Render a Markdown table for input vectors (given info only)."""
        lines = [
            '<div align="center">',
            "",
            f"| Vector | $|\\vec{{F}}|$ ({unit}) | $\\theta$ (deg) | Reference |",
            "| :--- | ---: | ---: | :--- |",
        ]
        for v in vectors:
            name_md = self._format_vec_name_md(v.name)
            lines.append(f"| {name_md} | {v.mag} | {v.angle} | {v.ref} |")
        lines.extend(["", "</div>"])
        return "\n".join(lines)

    def _format_vec_name_md(self, name: str) -> str:
        """Format vector name for Markdown."""
        formatted_name = latex_name(name)
        return f"$\\vec{{{formatted_name}}}$"

    def _render_variables_section(self, data: RectangularReportModel) -> str:
        """Render variables section."""
        table = self._render_input_vector_table(data.input_vectors, data.unit)
        sign_note = "*Vector sign convention used to define vector direction: Positive angles rotate counterclockwise, negative angles rotate clockwise. Positive magnitudes point outward from the origin, negative magnitudes point inward.*"
        return f"## 1. Input Vectors\n\n{sign_note}\n\n{table}\n"

    def _render_equations_section(self, data: RectangularReportModel) -> str:
        """Render equations used section."""
        lines = ["## 2. Equations Used", ""]
        for i, eq in enumerate(data.equations, 1):
            lines.append(f"{i}. ${eq.latex}$")
            lines.append("")
        return "\n".join(lines)

    def _render_steps_section(self, data: RectangularReportModel) -> str:
        """Render step-by-step solution section."""
        lines = ["## 3. Step-by-Step Solution", ""]
        for step in data.solution_steps:
            target = step.target
            title = f"**Step {step.number}: Solve for ${target}$**"

            lines.append(title)
            lines.append("")
            lines.append("$$")
            lines.append("\\begin{aligned}")
            # Format substitution for aligned environment
            sub_lines = self._format_substitution_md(step.substitution)
            lines.extend(sub_lines)
            lines.append("\\end{aligned}")
            lines.append("$$")
            lines.append("")
        return "\n".join(lines)

    def _format_substitution_md(self, sub: str) -> list[str]:
        """Format substitution for Markdown aligned environment."""
        return format_substitution_md(sub)

    def _render_results_section(self, data: RectangularReportModel) -> str:
        """Render results summary section."""
        if data.result is None:
            return ""

        r = data.result
        name_md = self._format_vec_name_md(r.name)

        lines = [
            "## 4. Summary of Results",
            "",
            '<div align="center">',
            "",
            f"| Vector | $F_x$ ({data.unit}) | $F_y$ ({data.unit}) | $|\\vec{{F}}|$ ({data.unit}) | $\\theta$ (deg) |",
            "| :--- | ---: | ---: | ---: | ---: |",
            f"| {name_md} | {r.x_comp} | {r.y_comp} | {r.mag} | {r.angle} |",
            "",
            "</div>",
            "",
        ]
        return "\n".join(lines)

    def _render_disclaimer(self) -> str:
        """Render disclaimer section."""
        return """
---

## Disclaimer

While every effort has been made to ensure the accuracy and reliability of the calculations provided, we do not guarantee that the information is complete, up-to-date, or suitable for any specific purpose. Users must independently verify the results and assume full responsibility for any decisions or actions taken based on its output.

**Report Details:**
- **Generated Date:** {{GENERATED_DATE}}
- **Generated Using:** Qnty Library
- **Version:** Beta (Independent verification required for production use)

**Signatures:**

| Role | Name | Signature | Date |
|------|------|-----------|------|
| Calculated By | _________________ | _________________ | _______ |
| Reviewed By | _________________ | _________________ | _______ |
| Approved By | _________________ | _________________ | _______ |

*Report generated using qnty library*"""


# =============================================================================
# Report Generation
# =============================================================================


def generate_report(
    problem: RectangularMethodProblem,
    output_path: str | Path,
    format: str = "markdown",
) -> None:
    """
    Generate a report for a rectangular method problem.

    Args:
        problem: Solved RectangularMethodProblem
        output_path: Output file path
        format: 'markdown', 'latex', or 'pdf'
    """
    output_path = Path(output_path)
    data = build_report_model(problem)

    if format == "latex":
        renderer = LaTeXRenderer()
        content = renderer.render(data)
        output_path.write_text(content, encoding="utf-8")
    elif format == "markdown":
        renderer = MarkdownRenderer()
        content = renderer.render(data)
        output_path.write_text(content, encoding="utf-8")
    elif format == "pdf":
        _generate_pdf(data, output_path)
    else:
        raise ValueError(f"Unknown format: {format}")


def _generate_pdf(data: RectangularReportModel, output_path: Path) -> None:
    """Generate PDF by compiling LaTeX."""
    from datetime import datetime

    renderer = LaTeXRenderer()
    latex = renderer.render(data)
    # Replace date placeholder with actual date for PDF
    latex = latex.replace("{{GENERATED_DATE}}", datetime.now().strftime("%Y-%m-%d"))

    compile_latex_to_pdf(latex, output_path)
