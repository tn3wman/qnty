"""
Report generator for parallelogram law problems.

This module provides a dedicated report generator for vector addition problems
solved using the parallelogram law. LaTeX is the source of truth - Markdown
is derived from the same data model.

Key Design:
1. A shared data model represents the report content
2. LaTeX renderer produces LaTeX output
3. Markdown renderer produces Markdown output (derived from same data)
4. PDF is generated by compiling LaTeX
"""

# TODO: Reports are missing a step to find the correct angle before applying Law of Cosines.

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING, Any

from ...equations.base import latex_name

if TYPE_CHECKING:
    from .parallelogram_solver import ParallelogramLawProblem


# =============================================================================
# Data Model
# =============================================================================

def _format_reference(ref: str) -> str:
    """
    Format reference axis for consistent display in LaTeX/Markdown.

    Uses math mode with explicit + or - to ensure consistent sizing and alignment.
    E.g., "+x" -> "$+x$", "-y" -> "$-y$"
    """
    if not ref:
        return "$+x$"
    # Ensure the sign is explicit
    if ref[0] not in "+-":
        ref = "+" + ref
    return f"${ref}$"


@dataclass
class VectorRow:
    """Data for a vector table row."""
    name: str  # e.g., "F_1", "F_R"
    mag: str   # formatted magnitude or "?"
    angle: str # formatted angle or "?"
    ref: str   # reference axis, e.g., "+x", "-x"


@dataclass
class EquationData:
    """Data for an equation in the equations list."""
    latex: str  # LaTeX representation


@dataclass
class SolutionStepData:
    """Data for a solution step."""
    number: int
    target: str          # What we're solving for (LaTeX)
    substitution: str    # The math steps (LaTeX)


@dataclass
class DiagramVertex:
    """A vertex in the parallelogram diagram."""
    name: str  # A, B, C, or D
    x: float
    y: float
    vector_name: str | None = None  # e.g., "F_1", "F_R"


@dataclass
class DiagramVector:
    """Data for a vector in the diagram."""
    name: str  # e.g., "F_1"
    magnitude: float  # Magnitude value
    angle_deg: float  # Angle in degrees (absolute, from +x)
    angle_ref: float  # Angle as defined in problem (relative to reference)
    angle_wrt: str  # Reference axis (e.g., "+x", "-x", "+y", "-y")
    unit: str = "N"


@dataclass
class DiagramAngle:
    """Data for an interior angle in the force triangle."""
    name: str  # e.g., "∠(F_1, F_2)"
    value_deg: float  # Angle value in degrees
    vec1_name: str  # First vector
    vec2_name: str  # Second vector


@dataclass
class DiagramData:
    """Data for the parallelogram diagram."""
    vertices: list[DiagramVertex]
    vectors: list[DiagramVector]  # Vector data for labels
    interior_angles: list[DiagramAngle]  # Interior angles for force triangle
    # Scaling info
    scale: float = 1.0
    # Whether we have valid coordinates
    is_valid: bool = True


@dataclass
class ReportData:
    """Complete report data model."""
    problem_name: str
    known_vectors: list[VectorRow]
    unknown_vectors: list[VectorRow]
    equations: list[EquationData]
    steps: list[SolutionStepData]
    result_vectors: list[VectorRow]
    diagram: DiagramData | None = None
    unit: str = "N"


# =============================================================================
# Report Data Builder
# =============================================================================

class ReportDataBuilder:
    """Build ReportData from a solved ParallelogramLawProblem."""

    def __init__(self, problem: ParallelogramLawProblem):
        self.problem = problem
        self.unit = self._extract_unit_from_vectors()

    def _extract_unit_from_vectors(self) -> str:
        """Extract the unit symbol from the problem's vectors.

        Uses the Quantity's preferred unit (set when the vector was created).
        Falls back to 'N' if no unit can be determined.
        """
        for vec in self.problem.vectors.values():
            mag = vec.magnitude
            # For VectorUnknown, magnitude might be ellipsis
            if mag is ...:
                continue
            # Get unit from Quantity.preferred (set during Q(value, unit) creation)
            if hasattr(mag, "preferred") and mag.preferred is not None:
                return mag.preferred.symbol
        return "N"

    def build(self) -> ReportData:
        """Build the complete report data."""
        return ReportData(
            problem_name=self.problem.name,
            known_vectors=self._build_known_vectors(),
            unknown_vectors=self._build_unknown_vectors(),
            equations=self._build_equations(),
            steps=self._build_steps(),
            result_vectors=self._build_result_vectors(),
            diagram=self._build_diagram(),
            unit=self.unit,
        )

    def _build_diagram(self) -> DiagramData | None:
        """Build diagram data from the solved problem's parallelogram geometry."""
        from ...equations.angle_finder import get_absolute_angle
        from ...geometry.parallelogram import Parallelogram

        # Get the triangle from the problem (which we can use to build a Parallelogram)
        if not hasattr(self.problem, '_triangle') or self.problem._triangle is None:
            return None

        triangle = self.problem._triangle

        # Build a Parallelogram from the triangle's vectors
        try:
            parallelogram = Parallelogram(
                vec_1=triangle.vec_1,
                vec_2=triangle.vec_2,
                vec_r=triangle.vec_r,
            )
        except Exception:
            return None

        # Extract vertex coordinates
        vertices = []
        for v in parallelogram.vertices:
            vertices.append(DiagramVertex(
                name=v.name,
                x=v.x,
                y=v.y,
                vector_name=v.vector_tip,
            ))

        # Extract vector data (magnitude and angle) from SOLVED problem vectors
        # The triangle's vectors may still have ellipsis for unknowns,
        # so we use the problem's solved vectors instead
        vectors = []
        for vec in self.problem.vectors.values():
            if vec is None:
                continue
            try:
                mag = vec.magnitude
                if mag is ... or mag is None:
                    continue
                mag_val = mag.magnitude() if hasattr(mag, 'magnitude') else float(mag)

                # Get absolute angle (from +x)
                abs_angle = get_absolute_angle(vec)
                angle_deg = abs_angle.to_unit.degree.magnitude()

                # Get original angle reference (as defined in problem)
                angle_ref = 0.0
                angle_wrt = "+x"
                if vec.angle is not ... and vec.angle is not None:
                    angle_ref = vec.angle.to_unit.degree.magnitude()
                if hasattr(vec, 'wrt') and vec.wrt:
                    angle_wrt = vec.wrt

                vectors.append(DiagramVector(
                    name=vec.name or "V",
                    magnitude=mag_val,
                    angle_deg=angle_deg,
                    angle_ref=angle_ref,
                    angle_wrt=angle_wrt,
                    unit=self.unit,
                ))
            except Exception:
                continue

        # Extract all three interior angles from the triangle
        # Triangle vertex mapping to parallelogram (from triangle.py):
        #   - Vertex A (angle_A): where vec_1 tail and vec_r tail meet = ORIGIN in parallelogram
        #   - Vertex B (angle_B): where vec_1 tip meets vec_2 tail = F1 TIP in parallelogram (point B)
        #   - Vertex C (angle_C): where vec_2 tip and vec_r tip meet = FR TIP in parallelogram (point D)
        #
        # We store angles in a dict keyed by their position in the parallelogram
        interior_angle_values: dict[str, float] = {}

        def extract_angle_value(angle_obj) -> float | None:
            """Extract angle value in degrees from triangle angle object."""
            try:
                if angle_obj is not None and angle_obj.angle is not None:
                    angle_val = angle_obj.angle
                    if hasattr(angle_val, 'to_unit'):
                        return angle_val.to_unit.degree.magnitude()
                    return float(angle_val)
            except Exception:
                pass
            return None

        # Get known angles - mapping from triangle vertices to parallelogram positions
        angle_A_val = extract_angle_value(triangle.angle_A)  # At origin (vertex A)
        angle_B_val = extract_angle_value(triangle.angle_B)  # At F1 tip (vertex B)
        angle_C_val = extract_angle_value(triangle.angle_C)  # At FR tip (vertex D in parallelogram)

        # Store known angles
        if angle_A_val is not None:
            interior_angle_values["origin"] = angle_A_val
        if angle_B_val is not None:
            interior_angle_values["f1_tip"] = angle_B_val
        if angle_C_val is not None:
            interior_angle_values["fr_tip"] = angle_C_val

        # Compute missing angle if exactly 2 are known (angles sum to 180°)
        known_count = len(interior_angle_values)
        if known_count == 2:
            known_sum = sum(interior_angle_values.values())
            missing_angle = 180.0 - known_sum
            if missing_angle > 0:
                if "origin" not in interior_angle_values:
                    interior_angle_values["origin"] = missing_angle
                elif "f1_tip" not in interior_angle_values:
                    interior_angle_values["f1_tip"] = missing_angle
                elif "fr_tip" not in interior_angle_values:
                    interior_angle_values["fr_tip"] = missing_angle

        # Build DiagramAngle list for compatibility
        # Note: The angle names reflect what vectors form the angle at that vertex
        interior_angles = []
        v1_name = triangle.vec_1.name if triangle.vec_1 and triangle.vec_1.name else "F_1"
        v2_name = triangle.vec_2.name if triangle.vec_2 and triangle.vec_2.name else "F_2"
        vr_name = triangle.vec_r.name if triangle.vec_r and triangle.vec_r.name else "F_R"

        if "origin" in interior_angle_values:
            # Angle at origin (vertex A): between F1 and FR (both start from origin)
            interior_angles.append(DiagramAngle(
                name=f"∠({v1_name}, {vr_name})",
                value_deg=interior_angle_values["origin"],
                vec1_name=v1_name,
                vec2_name=vr_name
            ))
        if "f1_tip" in interior_angle_values:
            # Angle at F1 tip (vertex B): the junction angle between F1 and translated F2
            interior_angles.append(DiagramAngle(
                name=f"∠({v1_name}, {v2_name})",
                value_deg=interior_angle_values["f1_tip"],
                vec1_name=v1_name,
                vec2_name=v2_name
            ))
        if "fr_tip" in interior_angle_values:
            # Angle at FR tip (vertex C/D): between translated F2 and FR
            interior_angles.append(DiagramAngle(
                name=f"∠({v2_name}, {vr_name})",
                value_deg=interior_angle_values["fr_tip"],
                vec1_name=v2_name,
                vec2_name=vr_name
            ))

        # Check if we have valid coordinates (not all zeros or NaN)
        has_valid_coords = any(
            (v.x != 0 or v.y != 0) and v.x == v.x and v.y == v.y  # NaN check: x != x is True for NaN
            for v in vertices
        )

        if not has_valid_coords:
            return DiagramData(vertices=vertices, vectors=vectors, interior_angles=interior_angles, is_valid=False)

        # Compute scale factor to fit in a reasonable size (e.g., 8cm width)
        min_x, min_y, max_x, max_y = parallelogram.bounding_box
        width = max_x - min_x
        height = max_y - min_y
        max_dim = max(width, height, 1.0)  # Avoid division by zero
        scale = 6.0 / max_dim  # Target 6cm max dimension

        return DiagramData(
            vertices=vertices,
            vectors=vectors,
            interior_angles=interior_angles,
            scale=scale,
            is_valid=True,
        )

    def _get_vector_row(self, name: str, vec: Any, show_values: bool) -> VectorRow:
        """Extract a VectorRow from a vector.

        Args:
            name: Vector name for display
            vec: Vector object
            show_values: If True, show all values (for solved results).
                If False, only show values that were originally known (for unknown
                variables table - e.g., a vector might have unknown magnitude but
                known angle, so we show '?' for magnitude but the actual angle value).
        """
        # Check original states to determine what was known before solving
        mag_originally_known = self.problem._original_variable_states.get(f"{name}_mag", True)
        angle_originally_known = self.problem._original_variable_states.get(f"{name}_angle", True)

        # Get magnitude
        mag_qty = vec.magnitude
        if show_values or mag_originally_known:
            if mag_qty is not ... and mag_qty is not None and mag_qty.value is not None:
                mag_str = f"{mag_qty.magnitude():.1f}"
            else:
                mag_str = "?"
        else:
            mag_str = "?"

        # Get angle in degrees
        angle_qty = vec.angle
        if show_values or angle_originally_known:
            if angle_qty is not ... and angle_qty is not None and angle_qty.value is not None:
                angle_deg = angle_qty.to_unit.degree
                angle_str = f"{angle_deg.magnitude():.1f}"
            else:
                angle_str = "?"
        else:
            angle_str = "?"

        # Get reference (wrt attribute) and format it for consistent display
        ref = getattr(vec, "wrt", "+x")
        ref_formatted = _format_reference(ref)

        return VectorRow(
            name=name,
            mag=mag_str,
            angle=angle_str,
            ref=ref_formatted,
        )

    def _build_known_vectors(self) -> list[VectorRow]:
        """Build known vector rows."""
        rows = []
        for name, vec in self.problem.vectors.items():
            if self.problem._original_vector_states.get(name, True):
                rows.append(self._get_vector_row(name, vec, show_values=True))
        return rows

    def _build_unknown_vectors(self) -> list[VectorRow]:
        """Build unknown vector rows (showing ? for values)."""
        rows = []
        for name, vec in self.problem.vectors.items():
            if not self.problem._original_vector_states.get(name, True):
                rows.append(self._get_vector_row(name, vec, show_values=False))
        return rows

    def _build_result_vectors(self) -> list[VectorRow]:
        """Build result vector rows (showing solved values)."""
        rows = []
        for name, vec in self.problem.vectors.items():
            if not self.problem._original_vector_states.get(name, True):
                rows.append(self._get_vector_row(name, vec, show_values=True))
        return rows

    def _build_equations(self) -> list[EquationData]:
        """Build equation data from solving history."""
        equations = []
        seen = set()
        for step in self.problem.solving_history:
            eq_str = step.get("equation_for_list", "")
            if eq_str and eq_str not in seen:
                equations.append(EquationData(latex=eq_str))
                seen.add(eq_str)
        return equations

    def _build_steps(self) -> list[SolutionStepData]:
        """Build solution step data."""
        steps = []
        for i, step in enumerate(self.problem.solving_history, 1):
            target = step.get("target", "Unknown")
            substitution = step.get("substitution", "")
            steps.append(SolutionStepData(
                number=i,
                target=target,
                substitution=substitution,
            ))
        return steps


# =============================================================================
# LaTeX Renderer
# =============================================================================

class LaTeXRenderer:
    """Render ReportData to LaTeX."""

    def render(self, data: ReportData) -> str:
        """Render the complete LaTeX document."""
        parts = [
            self._render_preamble(data),
            self._render_diagram_section(data),
            self._render_known_section(data),
            self._render_unknown_section(data),
            self._render_equations_section(data),
            self._render_steps_section(data),
            self._render_results_section(data),
            self._render_disclaimer(),
        ]
        return "".join(parts)

    def _render_preamble(self, data: ReportData) -> str:
        """Render LaTeX preamble."""
        return rf"""\documentclass[11pt,a4paper]{{article}}
\usepackage{{amsmath}}
\usepackage{{amssymb}}
\usepackage{{booktabs}}
\usepackage{{longtable}}
\usepackage{{geometry}}
\geometry{{margin=1in}}
\usepackage{{hyperref}}
\usepackage{{enumitem}}
\usepackage{{graphicx}}
\usepackage{{siunitx}}
\usepackage{{accents}}
\usepackage{{changepage}}
\usepackage{{needspace}}
\usepackage{{tikz}}
\usepackage{{xcolor}}
\usetikzlibrary{{calc,arrows.meta}}

% Vector notation: \vv{{F}} produces F with arrow over it
\newcommand{{\vv}}[1]{{\vec{{#1}}}}
% Magnitude notation: \magn{{F}} produces |F| with fixed-height bars
\newcommand{{\magn}}[1]{{|#1|}}

% TikZ styles for vector diagrams
\colorlet{{vec_f1}}{{blue!80!black}}
\colorlet{{vec_f2}}{{red!80!black}}
\colorlet{{vec_fr}}{{green!60!black}}
\colorlet{{vec_translated}}{{gray!60}}
\tikzset{{
    vector/.style={{-{{Stealth[length=3mm,width=2mm]}},very thick}},
    vector_translated/.style={{-{{Stealth[length=2mm,width=1.5mm]}},dashed,thin}},
}}

\title{{Engineering Calculation Report: {data.problem_name}}}
\date{{{{{{GENERATED_DATE}}}}}}

\begin{{document}}
\maketitle
"""

    def _render_diagram_section(self, data: ReportData) -> str:
        """Render the vector diagrams section using TikZ.

        Creates two diagrams:
        1. Problem Setup: Shows vectors with their original angle references
        2. Force Triangle: Shows the triangle with interior angles used for solving
        """
        if data.diagram is None or not data.diagram.is_valid:
            return ""

        vertices = data.diagram.vertices
        vectors = data.diagram.vectors
        scale = data.diagram.scale

        # Find vertices by name
        v_dict = {v.name: v for v in vertices}
        A = v_dict.get("A")
        B = v_dict.get("B")
        C = v_dict.get("C")
        D = v_dict.get("D")

        if A is None or B is None or C is None or D is None:
            return ""

        # Scale coordinates for display
        def sc(v: DiagramVertex) -> tuple[float, float]:
            return (v.x * scale, v.y * scale)

        ax, ay = sc(A)
        bx, by = sc(B)
        cx, cy = sc(C)
        dx, dy = sc(D)

        # Get vector names for labels
        f1_name = B.vector_name or "F_1"
        f2_name = C.vector_name or "F_2"
        fr_name = D.vector_name or "F_R"

        # Format names for LaTeX
        f1_label = latex_name(f1_name)
        f2_label = latex_name(f2_name)
        fr_label = latex_name(fr_name)

        # Find vector data by name for magnitude/angle labels
        vec_dict = {v.name: v for v in vectors}
        f1_vec = vec_dict.get(f1_name)
        f2_vec = vec_dict.get(f2_name)
        fr_vec = vec_dict.get(fr_name)

        # Compute axis length to match the longest vector
        # Calculate actual vector lengths (distance from origin to tip)
        import math
        f1_len = math.sqrt(bx**2 + by**2)
        f2_len = math.sqrt(cx**2 + cy**2)
        fr_len = math.sqrt(dx**2 + dy**2)
        max_vec_len = max(f1_len, f2_len, fr_len, 1.0)
        axis_len = max_vec_len  # Axes as long as longest vector

        # Build magnitude labels (e.g., "450 N")
        def mag_label(vec: DiagramVector | None) -> str:
            if vec is None:
                return ""
            return f"{vec.magnitude:.0f}\\,\\text{{{vec.unit}}}"

        f1_mag = mag_label(f1_vec)
        f2_mag = mag_label(f2_vec)
        fr_mag = mag_label(fr_vec)

        # Calculate reference axis directions for drawing
        def get_ref_axis_angle(wrt: str) -> float:
            """Get the absolute angle of the reference axis."""
            ref_angles = {"+x": 0, "-x": 180, "+y": 90, "-y": 270}
            return ref_angles.get(wrt, 0)

        # Build angle arcs for Problem Setup diagram
        angle_arcs = []
        arc_radius_base = axis_len * 0.5
        import math

        def get_label_anchor_for_angle(mid_angle: float) -> str:
            """Determine optimal anchor position (TikZ compass direction) based on angle.

            The anchor is the point on the label that attaches to the coordinate.
            We want the anchor to be towards the origin, so the label extends outward.
            """
            mid_angle = mid_angle % 360
            # Choose anchor towards origin (opposite to arc direction)
            if 315 <= mid_angle or mid_angle < 45:
                return "west"   # Arc on right, anchor on west (left side of label)
            elif 45 <= mid_angle < 135:
                return "south"  # Arc on top, anchor on south (bottom of label)
            elif 135 <= mid_angle < 225:
                return "east"   # Arc on left, anchor on east (right side of label)
            else:
                return "north"  # Arc on bottom, anchor on north (top of label)

        # F1: Draw angle arc from reference axis to vector
        if f1_vec is not None:
            ref_angle = get_ref_axis_angle(f1_vec.angle_wrt)
            if abs(f1_vec.angle_ref) > 0.5:
                arc_start = ref_angle
                arc_end = f1_vec.angle_deg
                arc_radius = arc_radius_base * 0.7
                mid_angle = (arc_start + arc_end) / 2
                # Position label at midpoint, offset outward from arc
                label_r = arc_radius + 0.35
                label_x = ax + label_r * math.cos(math.radians(mid_angle))
                label_y = ay + label_r * math.sin(math.radians(mid_angle))
                label_anchor = get_label_anchor_for_angle(mid_angle)
                angle_arcs.append(
                    rf"  \draw[vec_f1,thin] ({ax:.3f},{ay:.3f}) ++({arc_start}:{arc_radius:.3f}) "
                    rf"arc ({arc_start}:{arc_end}:{arc_radius:.3f});"
                )
                angle_arcs.append(
                    rf"  \node[vec_f1,anchor={label_anchor}] at ({label_x:.3f},{label_y:.3f}) {{${f1_vec.angle_ref:.0f}^\circ$}};"
                )

        # F2: Draw angle arc from reference axis to vector
        if f2_vec is not None:
            ref_angle = get_ref_axis_angle(f2_vec.angle_wrt)
            if abs(f2_vec.angle_ref) > 0.5:
                arc_start = ref_angle
                arc_end = f2_vec.angle_deg
                arc_radius = arc_radius_base * 1.0  # Larger radius to avoid overlap
                mid_angle = (arc_start + arc_end) / 2
                # Position label at midpoint, offset outward from arc
                label_r = arc_radius + 0.35
                label_x = ax + label_r * math.cos(math.radians(mid_angle))
                label_y = ay + label_r * math.sin(math.radians(mid_angle))
                label_anchor = get_label_anchor_for_angle(mid_angle)
                angle_arcs.append(
                    rf"  \draw[vec_f2,thin] ({ax:.3f},{ay:.3f}) ++({arc_start}:{arc_radius:.3f}) "
                    rf"arc ({arc_start}:{arc_end}:{arc_radius:.3f});"
                )
                angle_arcs.append(
                    rf"  \node[vec_f2,anchor={label_anchor}] at ({label_x:.3f},{label_y:.3f}) {{${f2_vec.angle_ref:.0f}^\circ$}};"
                )

        angle_arcs_str = "\n".join(angle_arcs) if angle_arcs else "  % No angle arcs"

        # Compute smart label positions based on vector directions
        # For vectors, place labels perpendicular to the vector direction
        def get_vector_label_position(angle_deg: float, at_tip: bool = True) -> str:
            """Get the position for a vector label to avoid overlap with angle arcs.

            Labels are placed perpendicular to the vector, on the side away from the origin.
            For vectors pointing into Q1 (0-90°), labels go below-right.
            For vectors pointing into Q2 (90-180°), labels go below-left.
            For vectors pointing into Q3 (180-270°), labels go above-left.
            For vectors pointing into Q4 (270-360°), labels go above-right.
            """
            angle = angle_deg % 360
            if 0 <= angle < 90:
                return "below right" if at_tip else "below right"
            elif 90 <= angle < 180:
                return "below left" if at_tip else "above right"
            elif 180 <= angle < 270:
                return "above left" if at_tip else "above left"
            else:
                return "above right" if at_tip else "below left"

        f1_pos = get_vector_label_position(f1_vec.angle_deg, at_tip=True) if f1_vec else "below right"
        f2_pos = get_vector_label_position(f2_vec.angle_deg, at_tip=True) if f2_vec else "above left"

        # DIAGRAM 1: Problem Setup
        diagram1 = rf"""
\subsection*{{Problem Setup}}

\begin{{center}}
\begin{{tikzpicture}}[scale=1]
  % Define coordinates
  \coordinate (A) at ({ax:.3f},{ay:.3f});
  \coordinate (B) at ({bx:.3f},{by:.3f});
  \coordinate (C) at ({cx:.3f},{cy:.3f});
  \coordinate (D) at ({dx:.3f},{dy:.3f});

  % Draw all four coordinate axes (as long as the longest vector)
  \draw[->,gray] ({ax:.3f},{ay:.3f}) -- ({ax + axis_len:.3f},{ay:.3f}) node[right] {{$+x$}};
  \draw[->,gray] ({ax:.3f},{ay:.3f}) -- ({ax - axis_len:.3f},{ay:.3f}) node[left] {{$-x$}};
  \draw[->,gray] ({ax:.3f},{ay:.3f}) -- ({ax:.3f},{ay + axis_len:.3f}) node[above] {{$+y$}};
  \draw[->,gray] ({ax:.3f},{ay:.3f}) -- ({ax:.3f},{ay - axis_len:.3f}) node[below] {{$-y$}};

  % Draw main vectors with arrows and magnitude labels (at tip)
  \draw[vector,vec_f1] (A) -- (B) node[{f1_pos},pos=1] {{$\vv{{{f1_label}}} = {f1_mag}$}};
  \draw[vector,vec_f2] (A) -- (C) node[{f2_pos},pos=1] {{$\vv{{{f2_label}}} = {f2_mag}$}};

  % Draw angle arcs (from reference axis to vector)
{angle_arcs_str}

  % Draw origin point
  \fill (A) circle (2pt) node[below left] {{$O$}};
\end{{tikzpicture}}
\end{{center}}
"""

        # DIAGRAM 2: Force Triangle (Parallelogram with solution)
        # Compute smart label positions for vectors in force triangle
        fr_pos = get_vector_label_position(fr_vec.angle_deg, at_tip=True) if fr_vec else "above right"

        # Build interior angle arcs for the force triangle
        # The force triangle has vertices at:
        #   - Origin (A): where F1 and FR both start
        #   - F1 tip (B): where F1 ends and translated F2 starts
        #   - FR tip (D): where translated F2 ends and FR ends
        #
        # Interior angles (from triangle.py vertex naming):
        #   - angle_A (origin): angle between F1 and FR (at origin)
        #   - angle_B (f1_tip): junction angle (between F1 incoming and translated F2 outgoing)
        #   - angle_C (fr_tip): angle between translated F2 and FR (at D)
        triangle_angle_arcs = []

        # Get angles from the dict (computed in _build_diagram, passed via data.diagram)
        angle_at_origin = data.diagram.interior_angles[0].value_deg if len(data.diagram.interior_angles) > 0 else 0
        angle_at_f1_tip = data.diagram.interior_angles[1].value_deg if len(data.diagram.interior_angles) > 1 else 0
        angle_at_fr_tip = data.diagram.interior_angles[2].value_deg if len(data.diagram.interior_angles) > 2 else 0

        import math

        def get_arc_angles(start_angle: float, end_angle: float) -> tuple[float, float]:
            """Get arc start/end angles ensuring we sweep the interior (shorter) arc.

            TikZ arcs go counterclockwise when end > start, clockwise when end < start.
            To ensure we draw the interior angle (shorter sweep), we adjust the angles.

            Returns (start, end) such that:
            - If the shorter sweep doesn't cross 0°, use normalized angles
            - If the shorter sweep crosses 0°, add 360° to end so end > start
            """
            # Normalize to [0, 360)
            start = start_angle % 360
            end = end_angle % 360

            # Calculate the counterclockwise sweep (the "positive direction" sweep)
            ccw_sweep = (end - start) % 360
            if ccw_sweep == 0:
                ccw_sweep = 360  # Full circle if same angle

            # The clockwise sweep is the complement
            cw_sweep = 360 - ccw_sweep

            # Choose the shorter sweep
            if ccw_sweep <= cw_sweep:
                # Counterclockwise is shorter. For TikZ, we need end > start.
                if end < start:
                    end += 360  # Make end > start so TikZ sweeps counterclockwise
                return start, end
            else:
                # Clockwise is shorter. Swap and adjust for TikZ counterclockwise.
                if start < end:
                    start += 360
                return end, start

        # Arc at origin (A): angle between F1 and FR (both outgoing from origin)
        if angle_at_origin > 0:
            f1_angle = f1_vec.angle_deg if f1_vec else 0
            fr_angle = fr_vec.angle_deg if fr_vec else 0
            arc_start, arc_end = get_arc_angles(f1_angle, fr_angle)
            arc_r = arc_radius_base * 0.5
            triangle_angle_arcs.append(
                rf"  \draw[orange,thick] ({ax:.3f},{ay:.3f}) ++({arc_start:.1f}:{arc_r:.3f}) "
                rf"arc ({arc_start:.1f}:{arc_end:.1f}:{arc_r:.3f}) "
                rf"node[midway,above] {{${angle_at_origin:.0f}^\circ$}};"
            )

        # Arc at B (F1 tip): junction angle between F1 (incoming) and translated F2 (outgoing to D)
        if angle_at_f1_tip > 0:
            f1_incoming_angle = ((f1_vec.angle_deg if f1_vec else 0) + 180) % 360
            bd_angle = math.degrees(math.atan2(dy - by, dx - bx)) % 360
            arc_start, arc_end = get_arc_angles(f1_incoming_angle, bd_angle)
            arc_r = arc_radius_base * 0.4
            triangle_angle_arcs.append(
                rf"  \draw[purple,thick] ({bx:.3f},{by:.3f}) ++({arc_start:.1f}:{arc_r:.3f}) "
                rf"arc ({arc_start:.1f}:{arc_end:.1f}:{arc_r:.3f}) "
                rf"node[midway,below left] {{${angle_at_f1_tip:.0f}^\circ$}};"
            )

        # Arc at D (FR tip): angle between translated F2 (incoming from B) and FR (incoming from origin)
        if angle_at_fr_tip > 0:
            bd_angle = math.degrees(math.atan2(dy - by, dx - bx)) % 360
            f2_incoming_angle = (bd_angle + 180) % 360
            fr_incoming_angle = ((fr_vec.angle_deg if fr_vec else 0) + 180) % 360
            arc_start, arc_end = get_arc_angles(f2_incoming_angle, fr_incoming_angle)
            arc_r = arc_radius_base * 0.4
            triangle_angle_arcs.append(
                rf"  \draw[cyan,thick] ({dx:.3f},{dy:.3f}) ++({arc_start:.1f}:{arc_r:.3f}) "
                rf"arc ({arc_start:.1f}:{arc_end:.1f}:{arc_r:.3f}) "
                rf"node[midway,right] {{${angle_at_fr_tip:.0f}^\circ$}};"
            )

        triangle_angle_arcs_str = "\n".join(triangle_angle_arcs) if triangle_angle_arcs else "  % No interior angles"

        diagram2 = rf"""
\subsection*{{Force Triangle (Parallelogram Law)}}

\begin{{center}}
\begin{{tikzpicture}}[scale=1]
  % Define coordinates
  \coordinate (A) at ({ax:.3f},{ay:.3f});
  \coordinate (B) at ({bx:.3f},{by:.3f});
  \coordinate (C) at ({cx:.3f},{cy:.3f});
  \coordinate (D) at ({dx:.3f},{dy:.3f});

  % Draw all four coordinate axes (as long as the longest vector)
  \draw[->,gray] ({ax:.3f},{ay:.3f}) -- ({ax + axis_len:.3f},{ay:.3f}) node[right] {{$+x$}};
  \draw[->,gray] ({ax:.3f},{ay:.3f}) -- ({ax - axis_len:.3f},{ay:.3f}) node[left] {{$-x$}};
  \draw[->,gray] ({ax:.3f},{ay:.3f}) -- ({ax:.3f},{ay + axis_len:.3f}) node[above] {{$+y$}};
  \draw[->,gray] ({ax:.3f},{ay:.3f}) -- ({ax:.3f},{ay - axis_len:.3f}) node[below] {{$-y$}};

  % Draw translated sides (parallelogram completion) - dashed
  \draw[vector_translated,vec_translated] (B) -- (D);
  \draw[vector_translated,vec_translated] (C) -- (D);

  % Draw main vectors with arrows and magnitude labels (using smart positioning)
  \draw[vector,vec_f1] (A) -- (B) node[{f1_pos},pos=0.5] {{$\vv{{{f1_label}}}$}};
  \draw[vector,vec_f2] (A) -- (C) node[{f2_pos},pos=0.5] {{$\vv{{{f2_label}}}$}};
  \draw[vector,vec_fr] (A) -- (D) node[{fr_pos},pos=0.5] {{$\vv{{{fr_label}}} = {fr_mag}$}};

  % Draw interior angle arcs at each vertex of the force triangle
{triangle_angle_arcs_str}

  % Draw origin point
  \fill (A) circle (2pt) node[below left] {{$O$}};
\end{{tikzpicture}}
\end{{center}}
"""

        return rf"""
\section{{Vector Diagrams}}
{diagram1}
{diagram2}
"""

    def _render_vector_table(self, vectors: list[VectorRow], unit: str) -> str:
        """Render a vector table."""
        rows = []
        for v in vectors:
            name_latex = self._format_vec_name(v.name)
            rows.append(f"{name_latex} & {v.mag} & {v.angle} & {v.ref} \\\\")

        return rf"""\begin{{longtable}}{{lSSl}}
\toprule
Vector & {{$\magn{{\vv{{F}}}}$ ({unit})}} & {{$\theta$ (deg)}} & Reference \\
\midrule
\endhead
{chr(10).join(rows)}
\bottomrule
\end{{longtable}}
"""

    def _format_vec_name(self, name: str) -> str:
        """Format vector name: F_1 -> $\\vv{F_1}$, F_AB -> $\\vv{F_{AB}}$"""
        # Use latex_name to handle multi-character subscripts properly
        formatted_name = latex_name(name)
        return f"$\\vv{{{formatted_name}}}$"

    def _render_known_section(self, data: ReportData) -> str:
        """Render known variables section."""
        table = self._render_vector_table(data.known_vectors, data.unit)
        return f"\n\\section{{Known Variables}}\n\n{table}"

    def _render_unknown_section(self, data: ReportData) -> str:
        """Render unknown variables section."""
        table = self._render_vector_table(data.unknown_vectors, data.unit)
        return f"\n\\section{{Unknown Variables}}\n\n{table}"

    def _render_equations_section(self, data: ReportData) -> str:
        """Render equations used section."""
        items = []
        for eq in data.equations:
            # Convert to LaTeX macros
            latex = self._convert_to_latex_macros(eq.latex)
            items.append(f"\\item $\\displaystyle {latex}$")

        return rf"""
\section{{Equations Used}}

\begin{{enumerate}}
{chr(10).join(items)}
\end{{enumerate}}
"""

    def _convert_to_latex_macros(self, eq: str) -> str:
        """Convert equation string to use LaTeX macros."""
        import re
        result = eq
        # Convert |\vec{X}| to \magn{\vv{X}}
        result = re.sub(r'\|\\vec\{([^}]+)\}\|', r'\\magn{\\vv{\1}}', result)
        # Convert standalone \vec{X} to \vv{X}
        result = re.sub(r'\\vec\{([^}]+)\}', r'\\vv{\1}', result)
        return result

    def _render_steps_section(self, data: ReportData) -> str:
        """Render step-by-step solution section.

        Each step is wrapped in a samepage environment to prevent page breaks
        within a step. We also use needspace to ensure there's enough room
        for at least the step header before starting.
        """
        steps_latex = []
        for step in data.steps:
            target_latex = self._convert_to_latex_macros(step.target)
            sub_latex = self._format_substitution(step.substitution)

            # Separate math part from suffix (using Eq N, with respect to, etc.)
            if " using Eq " in target_latex:
                math_part, suffix = target_latex.split(" using Eq ", 1)
                title_content = f"${math_part}$ using Eq {suffix}"
            elif " with respect to " in target_latex:
                math_part, suffix = target_latex.split(" with respect to ", 1)
                title_content = f"${math_part}$ with respect to {suffix}"
            else:
                title_content = f"${target_latex}$"

            # Wrap each step in samepage to prevent page breaks within a step.
            # Use needspace to check if we have at least 4 baselineskips of space;
            # if not, LaTeX will start a new page before this step.
            step_latex = rf"""
\needspace{{4\baselineskip}}
\begin{{samepage}}
\vspace{{0.2em}}
\noindent\hspace{{1em}}\textbf{{Step {step.number}: Solve for {title_content}}}
\vspace{{0.1em}}

\begin{{adjustwidth}}{{2em}}{{}}
\vspace{{-0.8em}}
\begin{{flalign*}}
{sub_latex}
\end{{flalign*}}
\vspace{{-0.8em}}
\end{{adjustwidth}}
\end{{samepage}}
"""
            steps_latex.append(step_latex)

        return f"\n\\section{{Step-by-Step Solution}}\n{''.join(steps_latex)}"

    def _format_substitution(self, sub: str) -> str:
        """Format substitution for flalign environment."""
        if not sub:
            return ""

        # Convert to LaTeX macros first
        sub = self._convert_substitution_to_latex_macros(sub)

        lines = sub.strip().split("\n")
        formatted = []
        for line in lines:
            line = line.strip()
            if line.endswith("\\\\"):
                line = line[:-2].strip()
            if line:
                formatted.append(f"\\quad {line} &&")
        return " \\\\\n".join(formatted)

    def _convert_substitution_to_latex_macros(self, sub: str) -> str:
        """Convert substitution text to use LaTeX macros."""
        import re
        result = sub

        # Convert |\vec{X}| patterns to \magn{\vv{X}}
        result = re.sub(r'\|\\vec\{([^}]+)\}\|', r'\\magn{\\vv{\1}}', result)

        # Convert |...| patterns to \magn{...}
        # This needs to handle complex content like |\angle(...) - \angle(...)|
        # Use a function to properly match balanced |...|
        def convert_abs_to_magn(text: str) -> str:
            out = []
            i = 0
            while i < len(text):
                if text[i] == '|' and (i == 0 or text[i-1] != '\\'):
                    # Found opening |, look for closing |
                    j = i + 1
                    depth = 0
                    while j < len(text):
                        if text[j] == '{':
                            depth += 1
                        elif text[j] == '}':
                            depth -= 1
                        elif text[j] == '|' and depth == 0 and text[j-1] != '\\':
                            # Found closing |
                            content = text[i+1:j]
                            out.append(f'\\magn{{{content}}}')
                            i = j + 1
                            break
                        j += 1
                    else:
                        # No closing | found, just append the |
                        out.append(text[i])
                        i += 1
                else:
                    out.append(text[i])
                    i += 1
            return ''.join(out)

        result = convert_abs_to_magn(result)

        # Convert \vec{X} to \vv{X}
        result = re.sub(r'\\vec\{([^}]+)\}', r'\\vv{\1}', result)
        return result

    def _render_results_section(self, data: ReportData) -> str:
        """Render results summary section."""
        table = self._render_vector_table(data.result_vectors, data.unit)
        return f"\n\\section{{Summary of Results}}\n\n{table}"

    def _render_disclaimer(self) -> str:
        """Render disclaimer section."""
        return r"""
\section*{Disclaimer}
\small
While every effort has been made to ensure the accuracy and reliability of the calculations provided, we do not guarantee that the information is complete, up-to-date, or suitable for any specific purpose. Users must independently verify the results and assume full responsibility for any decisions or actions taken based on its output. Use of this calculator is entirely at your own risk, and we expressly disclaim any liability for errors or omissions in the information provided.

\vspace{1em}
\noindent\textbf{Report Details:}
\begin{itemize}[nosep]
\item \textbf{Generated Date:} {{GENERATED_DATE}}
\item \textbf{Generated Using:} Qnty Library
\item \textbf{Version:} Beta (Independent verification required for production use)
\end{itemize}

\vspace{1em}
\noindent\textbf{Signatures:}
\begin{longtable}{llll}
\toprule
Role & Name & Signature & Date \\
\midrule
Calculated By & \rule{3cm}{0.4pt} & \rule{3cm}{0.4pt} & \rule{2cm}{0.4pt} \\
Reviewed By & \rule{3cm}{0.4pt} & \rule{3cm}{0.4pt} & \rule{2cm}{0.4pt} \\
Approved By & \rule{3cm}{0.4pt} & \rule{3cm}{0.4pt} & \rule{2cm}{0.4pt} \\
\bottomrule
\end{longtable}

\begin{center}
\textit{Report generated using qnty library}
\end{center}
\end{document}"""


# =============================================================================
# Markdown Renderer
# =============================================================================

class MarkdownRenderer:
    """Render ReportData to Markdown."""

    def render(self, data: ReportData) -> str:
        """Render the complete Markdown document."""
        parts = [
            self._render_header(data),
            self._render_known_section(data),
            self._render_unknown_section(data),
            self._render_equations_section(data),
            self._render_steps_section(data),
            self._render_results_section(data),
            self._render_disclaimer(),
        ]
        return "\n".join(parts)

    def _render_header(self, data: ReportData) -> str:
        """Render Markdown header."""
        return f"""# Engineering Calculation Report: {data.problem_name}

**Generated:** {{{{GENERATED_DATETIME}}}}
"""

    def _render_vector_table(self, vectors: list[VectorRow], unit: str) -> str:
        """Render a Markdown vector table."""
        # Use \| to escape pipes in markdown table header for magnitude column
        lines = [
            "<div align=\"center\">",
            "",
            f"| Vector | $\\|\\vec{{F}}\\|$ ({unit}) | $\\theta$ (deg) | Reference |",
            "| :--- | ---: | ---: | :--- |",
        ]
        for v in vectors:
            name_md = self._format_vec_name_md(v.name)
            lines.append(f"| {name_md} | {v.mag} | {v.angle} | {v.ref} |")
        lines.extend(["", "</div>"])
        return "\n".join(lines)

    def _format_vec_name_md(self, name: str) -> str:
        """Format vector name for Markdown: F_1 -> $\\vec{F_1}$, F_AB -> $\\vec{F_{AB}}$"""
        # Use latex_name to handle multi-character subscripts properly
        formatted_name = latex_name(name)
        return f"$\\vec{{{formatted_name}}}$"

    def _render_known_section(self, data: ReportData) -> str:
        """Render known variables section."""
        table = self._render_vector_table(data.known_vectors, data.unit)
        return f"## 1. Known Variables\n\n{table}\n"

    def _render_unknown_section(self, data: ReportData) -> str:
        """Render unknown variables section."""
        table = self._render_vector_table(data.unknown_vectors, data.unit)
        return f"## 2. Unknown Variables\n\n{table}\n"

    def _render_equations_section(self, data: ReportData) -> str:
        """Render equations used section."""
        lines = ["## 3. Equations Used", ""]
        for i, eq in enumerate(data.equations, 1):
            # Keep as-is but ensure proper escaping
            lines.append(f"{i}. ${eq.latex}$")
            lines.append("")
        return "\n".join(lines)

    def _render_steps_section(self, data: ReportData) -> str:
        """Render step-by-step solution section."""
        lines = ["## 4. Step-by-Step Solution", ""]
        for step in data.steps:
            target = step.target
            # Separate the math part from "using Eq N" or "with respect to" suffix
            if " using Eq " in target:
                math_part, suffix = target.split(" using Eq ", 1)
                title = f"**Step {step.number}: Solve for ${math_part}$ using Eq {suffix}**"
            elif " with respect to " in target:
                math_part, suffix = target.split(" with respect to ", 1)
                title = f"**Step {step.number}: Solve for ${math_part}$ with respect to {suffix}**"
            else:
                title = f"**Step {step.number}: Solve for ${target}$**"

            lines.append(title)
            lines.append("")
            lines.append("$$")
            lines.append("\\begin{aligned}")
            # Format substitution for aligned environment
            sub_lines = self._format_substitution_md(step.substitution)
            lines.extend(sub_lines)
            lines.append("\\end{aligned}")
            lines.append("$$")
            lines.append("")
        return "\n".join(lines)

    def _format_substitution_md(self, sub: str) -> list[str]:
        """Format substitution for Markdown aligned environment."""
        if not sub:
            return []
        result = []
        for line in sub.strip().split("\n"):
            line = line.strip()
            if line.endswith("\\\\"):
                line = line[:-2].strip()
            if line:
                result.append(f"{line} \\\\")
        return result

    def _render_results_section(self, data: ReportData) -> str:
        """Render results summary section."""
        table = self._render_vector_table(data.result_vectors, data.unit)
        return f"## 5. Summary of Results\n\n{table}\n"

    def _render_disclaimer(self) -> str:
        """Render disclaimer section."""
        return """
---

## Disclaimer

While every effort has been made to ensure the accuracy and reliability of the calculations provided, we do not guarantee that the information is complete, up-to-date, or suitable for any specific purpose. Users must independently verify the results and assume full responsibility for any decisions or actions taken based on its output. Use of this calculator is entirely at your own risk, and we expressly disclaim any liability for errors or omissions in the information provided.

**Report Details:**
- **Generated Date:** {{GENERATED_DATE}}
- **Generated Using:** Qnty Library
- **Version:** Beta (Independent verification required for production use)

**Signatures:**

| Role | Name | Signature | Date |
|------|------|-----------|------|
| Calculated By | _________________ | _________________ | _______ |
| Reviewed By | _________________ | _________________ | _______ |
| Approved By | _________________ | _________________ | _______ |

*Report generated using qnty library*"""


# =============================================================================
# Report Generator
# =============================================================================

class ParallelogramReportGenerator:
    """
    Generate reports for parallelogram law problems.

    Supports Markdown, LaTeX, and PDF output formats.
    """

    def __init__(self, problem: ParallelogramLawProblem):
        if not problem.is_solved:
            raise ValueError("Problem must be solved before generating report")
        self.problem = problem
        self.data_builder = ReportDataBuilder(problem)

    def generate(self, output_path: str | Path, format: str = "markdown") -> None:
        """
        Generate a report in the specified format.

        Args:
            output_path: Path for output file
            format: 'markdown', 'latex', or 'pdf'
        """
        output_path = Path(output_path)
        data = self.data_builder.build()

        if format == "latex":
            renderer = LaTeXRenderer()
            content = renderer.render(data)
            output_path.write_text(content, encoding="utf-8")
        elif format == "markdown":
            renderer = MarkdownRenderer()
            content = renderer.render(data)
            output_path.write_text(content, encoding="utf-8")
        elif format == "pdf":
            self._generate_pdf(data, output_path)
        else:
            raise ValueError(f"Unknown format: {format}")

    def _generate_pdf(self, data: ReportData, output_path: Path) -> None:
        """Generate PDF by compiling LaTeX."""
        import subprocess
        import tempfile
        from datetime import datetime

        renderer = LaTeXRenderer()
        latex = renderer.render(data)
        # Replace date placeholder with actual date for PDF
        latex = latex.replace("{{GENERATED_DATE}}", datetime.now().strftime("%Y-%m-%d"))

        with tempfile.NamedTemporaryFile(mode='w', suffix='.tex', delete=False, encoding='utf-8') as f:
            f.write(latex)
            tex_path = Path(f.name)

        try:
            # Try tectonic first (use .exe on Windows)
            import sys
            tectonic_name = "tectonic.exe" if sys.platform == "win32" else "tectonic"
            tectonic_path = Path(__file__).parent.parent.parent / "extensions" / "reporting" / tectonic_name
            if tectonic_path.exists():
                result = subprocess.run(
                    [str(tectonic_path), str(tex_path), "-o", str(output_path.parent)],
                    capture_output=True,
                    timeout=60,
                )
                if result.returncode == 0:
                    generated = output_path.parent / (tex_path.stem + ".pdf")
                    if generated.exists() and generated != output_path:
                        output_path.unlink(missing_ok=True)  # Remove existing file first
                        generated.rename(output_path)
                    return

            raise RuntimeError("PDF generation requires tectonic. Install it or use latex format.")
        finally:
            tex_path.unlink(missing_ok=True)


def generate_report(
    problem: ParallelogramLawProblem,
    output_path: str | Path,
    format: str = "markdown",
) -> None:
    """
    Generate a report for a parallelogram law problem.

    Args:
        problem: Solved ParallelogramLawProblem
        output_path: Output file path
        format: 'markdown', 'latex', or 'pdf'
    """
    generator = ParallelogramReportGenerator(problem)
    generator.generate(output_path, format=format)
