"""
Report generator for parallelogram law problems.

This module provides a dedicated report generator for vector addition problems
solved using the parallelogram law. LaTeX is the source of truth - Markdown
is derived from the same data model.

Key Design:
1. A shared data model represents the report content
2. LaTeX renderer produces LaTeX output
3. Markdown renderer produces Markdown output (derived from same data)
4. PDF is generated by compiling LaTeX
"""

# TODO: Reports are missing a step to find the correct angle before applying Law of Cosines.

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING, Any

from ...equations.base import latex_name

if TYPE_CHECKING:
    from .parallelogram_solver import ParallelogramLawProblem


# =============================================================================
# Data Model
# =============================================================================

def _format_reference(ref: str) -> str:
    """
    Format reference axis for consistent display in LaTeX/Markdown.

    Uses math mode with explicit + or - to ensure consistent sizing and alignment.
    E.g., "+x" -> "$+x$", "-y" -> "$-y$"
    """
    if not ref:
        return "$+x$"
    # Ensure the sign is explicit
    if ref[0] not in "+-":
        ref = "+" + ref
    return f"${ref}$"


@dataclass
class VectorRow:
    """Data for a vector table row."""
    name: str  # e.g., "F_1", "F_R"
    mag: str   # formatted magnitude or "?"
    angle: str # formatted angle or "?"
    ref: str   # reference axis, e.g., "+x", "-x"


@dataclass
class EquationData:
    """Data for an equation in the equations list."""
    latex: str  # LaTeX representation


@dataclass
class SolutionStepData:
    """Data for a solution step."""
    number: int
    target: str          # What we're solving for (LaTeX)
    substitution: str    # The math steps (LaTeX)


@dataclass
class ReportData:
    """Complete report data model."""
    problem_name: str
    known_vectors: list[VectorRow]
    unknown_vectors: list[VectorRow]
    equations: list[EquationData]
    steps: list[SolutionStepData]
    result_vectors: list[VectorRow]
    unit: str = "N"


# =============================================================================
# Report Data Builder
# =============================================================================

class ReportDataBuilder:
    """Build ReportData from a solved ParallelogramLawProblem."""

    def __init__(self, problem: ParallelogramLawProblem):
        self.problem = problem
        self.unit = self._extract_unit_from_vectors()

    def _extract_unit_from_vectors(self) -> str:
        """Extract the unit symbol from the problem's vectors.

        Uses the Quantity's preferred unit (set when the vector was created).
        Falls back to 'N' if no unit can be determined.
        """
        for vec in self.problem.vectors.values():
            mag = vec.magnitude
            # For VectorUnknown, magnitude might be ellipsis
            if mag is ...:
                continue
            # Get unit from Quantity.preferred (set during Q(value, unit) creation)
            if hasattr(mag, "preferred") and mag.preferred is not None:
                return mag.preferred.symbol
        return "N"

    def build(self) -> ReportData:
        """Build the complete report data."""
        return ReportData(
            problem_name=self.problem.name,
            known_vectors=self._build_known_vectors(),
            unknown_vectors=self._build_unknown_vectors(),
            equations=self._build_equations(),
            steps=self._build_steps(),
            result_vectors=self._build_result_vectors(),
            unit=self.unit,
        )

    def _get_vector_row(self, name: str, vec: Any, show_values: bool) -> VectorRow:
        """Extract a VectorRow from a vector.

        Args:
            name: Vector name for display
            vec: Vector object
            show_values: If True, show all values (for solved results).
                If False, only show values that were originally known (for unknown
                variables table - e.g., a vector might have unknown magnitude but
                known angle, so we show '?' for magnitude but the actual angle value).
        """
        # Check original states to determine what was known before solving
        mag_originally_known = self.problem._original_variable_states.get(f"{name}_mag", True)
        angle_originally_known = self.problem._original_variable_states.get(f"{name}_angle", True)

        # Get magnitude
        mag_qty = vec.magnitude
        if show_values or mag_originally_known:
            if mag_qty is not ... and mag_qty is not None and mag_qty.value is not None:
                mag_str = f"{mag_qty.magnitude():.1f}"
            else:
                mag_str = "?"
        else:
            mag_str = "?"

        # Get angle in degrees
        angle_qty = vec.angle
        if show_values or angle_originally_known:
            if angle_qty is not ... and angle_qty is not None and angle_qty.value is not None:
                angle_deg = angle_qty.to_unit.degree
                angle_str = f"{angle_deg.magnitude():.1f}"
            else:
                angle_str = "?"
        else:
            angle_str = "?"

        # Get reference (wrt attribute) and format it for consistent display
        ref = getattr(vec, "wrt", "+x")
        ref_formatted = _format_reference(ref)

        return VectorRow(
            name=name,
            mag=mag_str,
            angle=angle_str,
            ref=ref_formatted,
        )

    def _build_known_vectors(self) -> list[VectorRow]:
        """Build known vector rows."""
        rows = []
        for name, vec in self.problem.vectors.items():
            if self.problem._original_vector_states.get(name, True):
                rows.append(self._get_vector_row(name, vec, show_values=True))
        return rows

    def _build_unknown_vectors(self) -> list[VectorRow]:
        """Build unknown vector rows (showing ? for values)."""
        rows = []
        for name, vec in self.problem.vectors.items():
            if not self.problem._original_vector_states.get(name, True):
                rows.append(self._get_vector_row(name, vec, show_values=False))
        return rows

    def _build_result_vectors(self) -> list[VectorRow]:
        """Build result vector rows (showing solved values)."""
        rows = []
        for name, vec in self.problem.vectors.items():
            if not self.problem._original_vector_states.get(name, True):
                rows.append(self._get_vector_row(name, vec, show_values=True))
        return rows

    def _build_equations(self) -> list[EquationData]:
        """Build equation data from solving history."""
        equations = []
        seen = set()
        for step in self.problem.solving_history:
            eq_str = step.get("equation_for_list", "")
            if eq_str and eq_str not in seen:
                equations.append(EquationData(latex=eq_str))
                seen.add(eq_str)
        return equations

    def _build_steps(self) -> list[SolutionStepData]:
        """Build solution step data."""
        steps = []
        for i, step in enumerate(self.problem.solving_history, 1):
            target = step.get("target", "Unknown")
            substitution = step.get("substitution", "")
            steps.append(SolutionStepData(
                number=i,
                target=target,
                substitution=substitution,
            ))
        return steps


# =============================================================================
# LaTeX Renderer
# =============================================================================

class LaTeXRenderer:
    """Render ReportData to LaTeX."""

    def render(self, data: ReportData) -> str:
        """Render the complete LaTeX document."""
        parts = [
            self._render_preamble(data),
            self._render_known_section(data),
            self._render_unknown_section(data),
            self._render_equations_section(data),
            self._render_steps_section(data),
            self._render_results_section(data),
            self._render_disclaimer(),
        ]
        return "".join(parts)

    def _render_preamble(self, data: ReportData) -> str:
        """Render LaTeX preamble."""
        return rf"""\documentclass[11pt,a4paper]{{article}}
\usepackage{{amsmath}}
\usepackage{{amssymb}}
\usepackage{{booktabs}}
\usepackage{{longtable}}
\usepackage{{geometry}}
\geometry{{margin=1in}}
\usepackage{{hyperref}}
\usepackage{{enumitem}}
\usepackage{{graphicx}}
\usepackage{{siunitx}}
\usepackage{{accents}}
\usepackage{{changepage}}

% Vector notation: \vv{{F}} produces F with arrow over it
\newcommand{{\vv}}[1]{{\vec{{#1}}}}
% Magnitude notation: \magn{{F}} produces |F| with fixed-height bars
\newcommand{{\magn}}[1]{{|#1|}}

\title{{Engineering Calculation Report: {data.problem_name}}}
\date{{{{{{GENERATED_DATE}}}}}}

\begin{{document}}
\maketitle
"""

    def _render_vector_table(self, vectors: list[VectorRow], unit: str) -> str:
        """Render a vector table."""
        rows = []
        for v in vectors:
            name_latex = self._format_vec_name(v.name)
            rows.append(f"{name_latex} & {v.mag} & {v.angle} & {v.ref} \\\\")

        return rf"""\begin{{longtable}}{{lSSl}}
\toprule
Vector & {{$\magn{{\vv{{F}}}}$ ({unit})}} & {{$\theta$ (deg)}} & Reference \\
\midrule
\endhead
{chr(10).join(rows)}
\bottomrule
\end{{longtable}}
"""

    def _format_vec_name(self, name: str) -> str:
        """Format vector name: F_1 -> $\\vv{F_1}$, F_AB -> $\\vv{F_{AB}}$"""
        # Use latex_name to handle multi-character subscripts properly
        formatted_name = latex_name(name)
        return f"$\\vv{{{formatted_name}}}$"

    def _render_known_section(self, data: ReportData) -> str:
        """Render known variables section."""
        table = self._render_vector_table(data.known_vectors, data.unit)
        return f"\n\\section{{Known Variables}}\n\n{table}"

    def _render_unknown_section(self, data: ReportData) -> str:
        """Render unknown variables section."""
        table = self._render_vector_table(data.unknown_vectors, data.unit)
        return f"\n\\section{{Unknown Variables}}\n\n{table}"

    def _render_equations_section(self, data: ReportData) -> str:
        """Render equations used section."""
        items = []
        for eq in data.equations:
            # Convert to LaTeX macros
            latex = self._convert_to_latex_macros(eq.latex)
            items.append(f"\\item $\\displaystyle {latex}$")

        return rf"""
\section{{Equations Used}}

\begin{{enumerate}}
{chr(10).join(items)}
\end{{enumerate}}
"""

    def _convert_to_latex_macros(self, eq: str) -> str:
        """Convert equation string to use LaTeX macros."""
        import re
        result = eq
        # Convert |\vec{X}| to \magn{\vv{X}}
        result = re.sub(r'\|\\vec\{([^}]+)\}\|', r'\\magn{\\vv{\1}}', result)
        # Convert standalone \vec{X} to \vv{X}
        result = re.sub(r'\\vec\{([^}]+)\}', r'\\vv{\1}', result)
        return result

    def _render_steps_section(self, data: ReportData) -> str:
        """Render step-by-step solution section."""
        steps_latex = []
        for step in data.steps:
            target_latex = self._convert_to_latex_macros(step.target)
            sub_latex = self._format_substitution(step.substitution)

            # Separate math part from suffix (using Eq N, with respect to, etc.)
            if " using Eq " in target_latex:
                math_part, suffix = target_latex.split(" using Eq ", 1)
                title_content = f"${math_part}$ using Eq {suffix}"
            elif " with respect to " in target_latex:
                math_part, suffix = target_latex.split(" with respect to ", 1)
                title_content = f"${math_part}$ with respect to {suffix}"
            else:
                title_content = f"${target_latex}$"

            step_latex = rf"""
\vspace{{0.2em}}
\noindent\hspace{{1em}}\textbf{{Step {step.number}: Solve for {title_content}}}
\vspace{{0.1em}}

\begin{{adjustwidth}}{{2em}}{{}}
\vspace{{-0.8em}}
\begin{{flalign*}}
{sub_latex}
\end{{flalign*}}
\vspace{{-0.8em}}
\end{{adjustwidth}}
"""
            steps_latex.append(step_latex)

        return f"\n\\section{{Step-by-Step Solution}}\n{''.join(steps_latex)}"

    def _format_substitution(self, sub: str) -> str:
        """Format substitution for flalign environment."""
        if not sub:
            return ""

        # Convert to LaTeX macros first
        sub = self._convert_substitution_to_latex_macros(sub)

        lines = sub.strip().split("\n")
        formatted = []
        for line in lines:
            line = line.strip()
            if line.endswith("\\\\"):
                line = line[:-2].strip()
            if line:
                formatted.append(f"\\quad {line} &&")
        return " \\\\\n".join(formatted)

    def _convert_substitution_to_latex_macros(self, sub: str) -> str:
        """Convert substitution text to use LaTeX macros."""
        import re
        result = sub

        # Convert |\vec{X}| patterns to \magn{\vv{X}}
        result = re.sub(r'\|\\vec\{([^}]+)\}\|', r'\\magn{\\vv{\1}}', result)

        # Convert |...| patterns to \magn{...}
        # This needs to handle complex content like |\angle(...) - \angle(...)|
        # Use a function to properly match balanced |...|
        def convert_abs_to_magn(text: str) -> str:
            out = []
            i = 0
            while i < len(text):
                if text[i] == '|' and (i == 0 or text[i-1] != '\\'):
                    # Found opening |, look for closing |
                    j = i + 1
                    depth = 0
                    while j < len(text):
                        if text[j] == '{':
                            depth += 1
                        elif text[j] == '}':
                            depth -= 1
                        elif text[j] == '|' and depth == 0 and text[j-1] != '\\':
                            # Found closing |
                            content = text[i+1:j]
                            out.append(f'\\magn{{{content}}}')
                            i = j + 1
                            break
                        j += 1
                    else:
                        # No closing | found, just append the |
                        out.append(text[i])
                        i += 1
                else:
                    out.append(text[i])
                    i += 1
            return ''.join(out)

        result = convert_abs_to_magn(result)

        # Convert \vec{X} to \vv{X}
        result = re.sub(r'\\vec\{([^}]+)\}', r'\\vv{\1}', result)
        return result

    def _render_results_section(self, data: ReportData) -> str:
        """Render results summary section."""
        table = self._render_vector_table(data.result_vectors, data.unit)
        return f"\n\\section{{Summary of Results}}\n\n{table}"

    def _render_disclaimer(self) -> str:
        """Render disclaimer section."""
        return r"""
\section*{Disclaimer}
\small
While every effort has been made to ensure the accuracy and reliability of the calculations provided, we do not guarantee that the information is complete, up-to-date, or suitable for any specific purpose. Users must independently verify the results and assume full responsibility for any decisions or actions taken based on its output. Use of this calculator is entirely at your own risk, and we expressly disclaim any liability for errors or omissions in the information provided.

\vspace{1em}
\noindent\textbf{Report Details:}
\begin{itemize}[nosep]
\item \textbf{Generated Date:} {{GENERATED_DATE}}
\item \textbf{Generated Using:} Qnty Library
\item \textbf{Version:} Beta (Independent verification required for production use)
\end{itemize}

\vspace{1em}
\noindent\textbf{Signatures:}
\begin{longtable}{llll}
\toprule
Role & Name & Signature & Date \\
\midrule
Calculated By & \rule{3cm}{0.4pt} & \rule{3cm}{0.4pt} & \rule{2cm}{0.4pt} \\
Reviewed By & \rule{3cm}{0.4pt} & \rule{3cm}{0.4pt} & \rule{2cm}{0.4pt} \\
Approved By & \rule{3cm}{0.4pt} & \rule{3cm}{0.4pt} & \rule{2cm}{0.4pt} \\
\bottomrule
\end{longtable}

\begin{center}
\textit{Report generated using qnty library}
\end{center}
\end{document}"""


# =============================================================================
# Markdown Renderer
# =============================================================================

class MarkdownRenderer:
    """Render ReportData to Markdown."""

    def render(self, data: ReportData) -> str:
        """Render the complete Markdown document."""
        parts = [
            self._render_header(data),
            self._render_known_section(data),
            self._render_unknown_section(data),
            self._render_equations_section(data),
            self._render_steps_section(data),
            self._render_results_section(data),
            self._render_disclaimer(),
        ]
        return "\n".join(parts)

    def _render_header(self, data: ReportData) -> str:
        """Render Markdown header."""
        return f"""# Engineering Calculation Report: {data.problem_name}

**Generated:** {{{{GENERATED_DATETIME}}}}
"""

    def _render_vector_table(self, vectors: list[VectorRow], unit: str) -> str:
        """Render a Markdown vector table."""
        # Use \| to escape pipes in markdown table header for magnitude column
        lines = [
            "<div align=\"center\">",
            "",
            f"| Vector | $\\|\\vec{{F}}\\|$ ({unit}) | $\\theta$ (deg) | Reference |",
            "| :--- | ---: | ---: | :--- |",
        ]
        for v in vectors:
            name_md = self._format_vec_name_md(v.name)
            lines.append(f"| {name_md} | {v.mag} | {v.angle} | {v.ref} |")
        lines.extend(["", "</div>"])
        return "\n".join(lines)

    def _format_vec_name_md(self, name: str) -> str:
        """Format vector name for Markdown: F_1 -> $\\vec{F_1}$, F_AB -> $\\vec{F_{AB}}$"""
        # Use latex_name to handle multi-character subscripts properly
        formatted_name = latex_name(name)
        return f"$\\vec{{{formatted_name}}}$"

    def _render_known_section(self, data: ReportData) -> str:
        """Render known variables section."""
        table = self._render_vector_table(data.known_vectors, data.unit)
        return f"## 1. Known Variables\n\n{table}\n"

    def _render_unknown_section(self, data: ReportData) -> str:
        """Render unknown variables section."""
        table = self._render_vector_table(data.unknown_vectors, data.unit)
        return f"## 2. Unknown Variables\n\n{table}\n"

    def _render_equations_section(self, data: ReportData) -> str:
        """Render equations used section."""
        lines = ["## 3. Equations Used", ""]
        for i, eq in enumerate(data.equations, 1):
            # Keep as-is but ensure proper escaping
            lines.append(f"{i}. ${eq.latex}$")
            lines.append("")
        return "\n".join(lines)

    def _render_steps_section(self, data: ReportData) -> str:
        """Render step-by-step solution section."""
        lines = ["## 4. Step-by-Step Solution", ""]
        for step in data.steps:
            target = step.target
            # Separate the math part from "using Eq N" or "with respect to" suffix
            if " using Eq " in target:
                math_part, suffix = target.split(" using Eq ", 1)
                title = f"**Step {step.number}: Solve for ${math_part}$ using Eq {suffix}**"
            elif " with respect to " in target:
                math_part, suffix = target.split(" with respect to ", 1)
                title = f"**Step {step.number}: Solve for ${math_part}$ with respect to {suffix}**"
            else:
                title = f"**Step {step.number}: Solve for ${target}$**"

            lines.append(title)
            lines.append("")
            lines.append("$$")
            lines.append("\\begin{aligned}")
            # Format substitution for aligned environment
            sub_lines = self._format_substitution_md(step.substitution)
            lines.extend(sub_lines)
            lines.append("\\end{aligned}")
            lines.append("$$")
            lines.append("")
        return "\n".join(lines)

    def _format_substitution_md(self, sub: str) -> list[str]:
        """Format substitution for Markdown aligned environment."""
        if not sub:
            return []
        result = []
        for line in sub.strip().split("\n"):
            line = line.strip()
            if line.endswith("\\\\"):
                line = line[:-2].strip()
            if line:
                result.append(f"{line} \\\\")
        return result

    def _render_results_section(self, data: ReportData) -> str:
        """Render results summary section."""
        table = self._render_vector_table(data.result_vectors, data.unit)
        return f"## 5. Summary of Results\n\n{table}\n"

    def _render_disclaimer(self) -> str:
        """Render disclaimer section."""
        return """
---

## Disclaimer

While every effort has been made to ensure the accuracy and reliability of the calculations provided, we do not guarantee that the information is complete, up-to-date, or suitable for any specific purpose. Users must independently verify the results and assume full responsibility for any decisions or actions taken based on its output. Use of this calculator is entirely at your own risk, and we expressly disclaim any liability for errors or omissions in the information provided.

**Report Details:**
- **Generated Date:** {{GENERATED_DATE}}
- **Generated Using:** Qnty Library
- **Version:** Beta (Independent verification required for production use)

**Signatures:**

| Role | Name | Signature | Date |
|------|------|-----------|------|
| Calculated By | _________________ | _________________ | _______ |
| Reviewed By | _________________ | _________________ | _______ |
| Approved By | _________________ | _________________ | _______ |

*Report generated using qnty library*"""


# =============================================================================
# Report Generator
# =============================================================================

class ParallelogramReportGenerator:
    """
    Generate reports for parallelogram law problems.

    Supports Markdown, LaTeX, and PDF output formats.
    """

    def __init__(self, problem: ParallelogramLawProblem):
        if not problem.is_solved:
            raise ValueError("Problem must be solved before generating report")
        self.problem = problem
        self.data_builder = ReportDataBuilder(problem)

    def generate(self, output_path: str | Path, format: str = "markdown") -> None:
        """
        Generate a report in the specified format.

        Args:
            output_path: Path for output file
            format: 'markdown', 'latex', or 'pdf'
        """
        output_path = Path(output_path)
        data = self.data_builder.build()

        if format == "latex":
            renderer = LaTeXRenderer()
            content = renderer.render(data)
            output_path.write_text(content, encoding="utf-8")
        elif format == "markdown":
            renderer = MarkdownRenderer()
            content = renderer.render(data)
            output_path.write_text(content, encoding="utf-8")
        elif format == "pdf":
            self._generate_pdf(data, output_path)
        else:
            raise ValueError(f"Unknown format: {format}")

    def _generate_pdf(self, data: ReportData, output_path: Path) -> None:
        """Generate PDF by compiling LaTeX."""
        import subprocess
        import tempfile
        from datetime import datetime

        renderer = LaTeXRenderer()
        latex = renderer.render(data)
        # Replace date placeholder with actual date for PDF
        latex = latex.replace("{{GENERATED_DATE}}", datetime.now().strftime("%Y-%m-%d"))

        with tempfile.NamedTemporaryFile(mode='w', suffix='.tex', delete=False, encoding='utf-8') as f:
            f.write(latex)
            tex_path = Path(f.name)

        try:
            # Try tectonic first (use .exe on Windows)
            import sys
            tectonic_name = "tectonic.exe" if sys.platform == "win32" else "tectonic"
            tectonic_path = Path(__file__).parent.parent.parent / "extensions" / "reporting" / tectonic_name
            if tectonic_path.exists():
                result = subprocess.run(
                    [str(tectonic_path), str(tex_path), "-o", str(output_path.parent)],
                    capture_output=True,
                    timeout=60,
                )
                if result.returncode == 0:
                    generated = output_path.parent / (tex_path.stem + ".pdf")
                    if generated.exists() and generated != output_path:
                        output_path.unlink(missing_ok=True)  # Remove existing file first
                        generated.rename(output_path)
                    return

            raise RuntimeError("PDF generation requires tectonic. Install it or use latex format.")
        finally:
            tex_path.unlink(missing_ok=True)


def generate_report(
    problem: ParallelogramLawProblem,
    output_path: str | Path,
    format: str = "markdown",
) -> None:
    """
    Generate a report for a parallelogram law problem.

    Args:
        problem: Solved ParallelogramLawProblem
        output_path: Output file path
        format: 'markdown', 'latex', or 'pdf'
    """
    generator = ParallelogramReportGenerator(problem)
    generator.generate(output_path, format=format)
