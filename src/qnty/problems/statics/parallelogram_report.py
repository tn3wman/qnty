"""
Report generator for parallelogram law problems.

This module provides a dedicated report generator for vector addition problems
solved using the parallelogram law. LaTeX is the source of truth - Markdown
is derived from the same data model.

Key Design:
1. A shared data model represents the report content
2. LaTeX renderer produces LaTeX output
3. Markdown renderer produces Markdown output (derived from same data)
4. PDF is generated by compiling LaTeX
"""

# TODO: Reports are missing a step to find the correct angle before applying Law of Cosines.

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING, Any

from ...equations.base import latex_name
from .tikz_diagram import (
    build_force_triangle_diagram,
    build_problem_setup_diagram,
    render_force_triangle_tikz,
    render_problem_setup_tikz,
)

if TYPE_CHECKING:
    from .parallelogram_solver import ParallelogramLawProblem


# =============================================================================
# Data Model
# =============================================================================

def _format_reference(ref: str) -> str:
    """
    Format reference axis for consistent display in LaTeX/Markdown.

    Uses math mode with explicit + or - to ensure consistent sizing and alignment.
    E.g., "+x" -> "$+x$", "-y" -> "$-y$"
    """
    if not ref:
        return "$+x$"
    # Ensure the sign is explicit
    if ref[0] not in "+-":
        ref = "+" + ref
    return f"${ref}$"


@dataclass
class VectorRow:
    """Data for a vector table row."""
    name: str  # e.g., "F_1", "F_R"
    mag: str   # formatted magnitude or "?"
    angle: str # formatted angle or "?"
    ref: str   # reference axis, e.g., "+x", "-x"


@dataclass
class EquationData:
    """Data for an equation in the equations list."""
    latex: str  # LaTeX representation


@dataclass
class SolutionStepData:
    """Data for a solution step."""
    number: int
    target: str          # What we're solving for (LaTeX)
    substitution: str    # The math steps (LaTeX)


@dataclass
class DiagramVertex:
    """A vertex in the parallelogram diagram."""
    name: str  # A, B, C, or D
    x: float
    y: float
    vector_name: str | None = None  # e.g., "F_1", "F_R"


@dataclass
class DiagramVector:
    """Data for a vector in the diagram."""
    name: str  # e.g., "F_1"
    magnitude: float  # Magnitude value
    angle_deg: float  # Angle in degrees (absolute, from +x)
    angle_ref: float  # Angle as defined in problem (relative to reference)
    angle_wrt: str  # Reference axis (e.g., "+x", "-x", "+y", "-y")
    unit: str = "N"
    is_known: bool = True  # Whether this vector was known in the original problem


@dataclass
class DiagramAngle:
    """Data for an interior angle in the force triangle."""
    name: str  # e.g., "∠(F_1, F_2)"
    value_deg: float  # Angle value in degrees
    vec1_name: str  # First vector
    vec2_name: str  # Second vector


@dataclass
class DiagramData:
    """Data for the parallelogram diagram."""
    vertices: list[DiagramVertex]
    vectors: list[DiagramVector]  # Vector data for labels
    interior_angles: list[DiagramAngle]  # Interior angles for force triangle
    # Scaling info
    scale: float = 1.0
    # Whether we have valid coordinates
    is_valid: bool = True


@dataclass
class ReportData:
    """Complete report data model."""
    problem_name: str
    known_vectors: list[VectorRow]
    unknown_vectors: list[VectorRow]
    equations: list[EquationData]
    steps: list[SolutionStepData]
    result_vectors: list[VectorRow]
    diagram: DiagramData | None = None
    unit: str = "N"


# =============================================================================
# Report Data Builder
# =============================================================================

class ReportDataBuilder:
    """Build ReportData from a solved ParallelogramLawProblem."""

    def __init__(self, problem: ParallelogramLawProblem):
        self.problem = problem
        self.unit = self._extract_unit_from_vectors()

    def _extract_unit_from_vectors(self) -> str:
        """Extract the unit symbol from the problem's vectors.

        Uses the Quantity's preferred unit (set when the vector was created).
        Falls back to 'N' if no unit can be determined.
        """
        for vec in self.problem.vectors.values():
            mag = vec.magnitude
            # For VectorUnknown, magnitude might be ellipsis
            if mag is ...:
                continue
            # Get unit from Quantity.preferred (set during Q(value, unit) creation)
            if hasattr(mag, "preferred") and mag.preferred is not None:
                return mag.preferred.symbol
        return "N"

    def build(self) -> ReportData:
        """Build the complete report data."""
        return ReportData(
            problem_name=self.problem.name,
            known_vectors=self._build_known_vectors(),
            unknown_vectors=self._build_unknown_vectors(),
            equations=self._build_equations(),
            steps=self._build_steps(),
            result_vectors=self._build_result_vectors(),
            diagram=self._build_diagram(),
            unit=self.unit,
        )

    def _build_diagram(self) -> DiagramData | None:
        """Build diagram data from the solved problem's parallelogram geometry."""
        from ...equations.angle_finder import get_absolute_angle
        from ...geometry.parallelogram import Parallelogram

        # Get the triangle from the problem (which we can use to build a Parallelogram)
        if not hasattr(self.problem, '_triangle') or self.problem._triangle is None:
            return None

        triangle = self.problem._triangle

        # Build a Parallelogram using the SOLVED vectors from the problem
        # The triangle's vectors may still have ellipsis for unknowns, so we use
        # the problem's solved vectors which have computed values for all vectors.
        try:
            # Get vector names from the triangle
            v1_name = triangle.vec_1.name if triangle.vec_1 else "F_1"
            v2_name = triangle.vec_2.name if triangle.vec_2 else "F_2"
            vr_name = triangle.vec_r.name if triangle.vec_r else "F_R"

            # Get solved vectors from problem.vectors
            solved_vec_1 = self.problem.vectors.get(v1_name)
            solved_vec_2 = self.problem.vectors.get(v2_name)
            solved_vec_r = self.problem.vectors.get(vr_name)

            if not all([solved_vec_1, solved_vec_2, solved_vec_r]):
                return None

            parallelogram = Parallelogram(
                vec_1=solved_vec_1,
                vec_2=solved_vec_2,
                vec_r=solved_vec_r,
            )
        except Exception:
            return None

        # Extract vertex coordinates
        vertices = []
        for v in parallelogram.vertices:
            vertices.append(DiagramVertex(
                name=v.name,
                x=v.x,
                y=v.y,
                vector_name=v.vector_tip,
            ))

        # Extract vector data (magnitude and angle) from SOLVED problem vectors
        # The triangle's vectors may still have ellipsis for unknowns,
        # so we use the problem's solved vectors instead
        vectors = []
        for vec_name, vec in self.problem.vectors.items():
            if vec is None:
                continue
            try:
                mag = vec.magnitude
                if mag is ... or mag is None:
                    continue
                mag_val = mag.magnitude() if hasattr(mag, 'magnitude') else float(mag)

                # Get absolute angle (from +x)
                abs_angle = get_absolute_angle(vec)
                angle_deg = abs_angle.to_unit.degree.magnitude()

                # Get original angle reference (as defined in problem)
                angle_ref = 0.0
                angle_wrt = "+x"
                if vec.angle is not ... and vec.angle is not None:
                    angle_ref = vec.angle.to_unit.degree.magnitude()
                if hasattr(vec, 'wrt') and vec.wrt:
                    angle_wrt = vec.wrt

                # Check if this vector was originally known (before solving)
                is_known = self.problem._original_vector_states.get(vec_name, True)

                vectors.append(DiagramVector(
                    name=vec.name or "V",
                    magnitude=mag_val,
                    angle_deg=angle_deg,
                    angle_ref=angle_ref,
                    angle_wrt=angle_wrt,
                    unit=self.unit,
                    is_known=is_known,
                ))
            except Exception:
                continue

        # Extract all three interior angles from the triangle
        # Triangle vertex mapping to parallelogram (from triangle.py):
        #   - Vertex A (angle_A): where vec_1 tail and vec_r tail meet = ORIGIN in parallelogram
        #   - Vertex B (angle_B): where vec_1 tip meets vec_2 tail = F1 TIP in parallelogram (point B)
        #   - Vertex C (angle_C): where vec_2 tip and vec_r tip meet = FR TIP in parallelogram (point D)
        #
        # We store angles in a dict keyed by their position in the parallelogram
        interior_angle_values: dict[str, float] = {}

        def extract_angle_value(angle_obj) -> float | None:
            """Extract angle value in degrees from triangle angle object."""
            try:
                if angle_obj is not None and angle_obj.angle is not None:
                    angle_val = angle_obj.angle
                    if hasattr(angle_val, 'to_unit'):
                        return angle_val.to_unit.degree.magnitude()
                    return float(angle_val)
            except Exception:
                pass
            return None

        # Get known angles - mapping from triangle vertices to parallelogram positions
        angle_A_val = extract_angle_value(triangle.angle_A)  # At origin (vertex A)
        angle_B_val = extract_angle_value(triangle.angle_B)  # At F1 tip (vertex B)
        angle_C_val = extract_angle_value(triangle.angle_C)  # At FR tip (vertex D in parallelogram)

        # Store known angles
        if angle_A_val is not None:
            interior_angle_values["origin"] = angle_A_val
        if angle_B_val is not None:
            interior_angle_values["f1_tip"] = angle_B_val
        if angle_C_val is not None:
            interior_angle_values["fr_tip"] = angle_C_val

        # Compute missing angle if exactly 2 are known (angles sum to 180°)
        known_count = len(interior_angle_values)
        if known_count == 2:
            known_sum = sum(interior_angle_values.values())
            missing_angle = 180.0 - known_sum
            if missing_angle > 0:
                if "origin" not in interior_angle_values:
                    interior_angle_values["origin"] = missing_angle
                elif "f1_tip" not in interior_angle_values:
                    interior_angle_values["f1_tip"] = missing_angle
                elif "fr_tip" not in interior_angle_values:
                    interior_angle_values["fr_tip"] = missing_angle

        # Build DiagramAngle list for compatibility
        # Note: The angle names reflect what vectors form the angle at that vertex
        interior_angles = []
        v1_name = triangle.vec_1.name if triangle.vec_1 and triangle.vec_1.name else "F_1"
        v2_name = triangle.vec_2.name if triangle.vec_2 and triangle.vec_2.name else "F_2"
        vr_name = triangle.vec_r.name if triangle.vec_r and triangle.vec_r.name else "F_R"

        if "origin" in interior_angle_values:
            # Angle at origin (vertex A): between F1 and FR (both start from origin)
            interior_angles.append(DiagramAngle(
                name=f"∠({v1_name}, {vr_name})",
                value_deg=interior_angle_values["origin"],
                vec1_name=v1_name,
                vec2_name=vr_name
            ))
        if "f1_tip" in interior_angle_values:
            # Angle at F1 tip (vertex B): the junction angle between F1 and translated F2
            interior_angles.append(DiagramAngle(
                name=f"∠({v1_name}, {v2_name})",
                value_deg=interior_angle_values["f1_tip"],
                vec1_name=v1_name,
                vec2_name=v2_name
            ))
        if "fr_tip" in interior_angle_values:
            # Angle at FR tip (vertex C/D): between translated F2 and FR
            interior_angles.append(DiagramAngle(
                name=f"∠({v2_name}, {vr_name})",
                value_deg=interior_angle_values["fr_tip"],
                vec1_name=v2_name,
                vec2_name=vr_name
            ))

        # Check if we have valid coordinates (not all zeros or NaN)
        has_valid_coords = any(
            (v.x != 0 or v.y != 0) and v.x == v.x and v.y == v.y  # NaN check: x != x is True for NaN
            for v in vertices
        )

        if not has_valid_coords:
            return DiagramData(vertices=vertices, vectors=vectors, interior_angles=interior_angles, is_valid=False)

        # Compute scale factor to fit in a reasonable size (e.g., 8cm width)
        min_x, min_y, max_x, max_y = parallelogram.bounding_box
        width = max_x - min_x
        height = max_y - min_y
        max_dim = max(width, height, 1.0)  # Avoid division by zero
        scale = 6.0 / max_dim  # Target 6cm max dimension

        return DiagramData(
            vertices=vertices,
            vectors=vectors,
            interior_angles=interior_angles,
            scale=scale,
            is_valid=True,
        )

    def _get_vector_row(self, name: str, vec: Any, show_values: bool) -> VectorRow:
        """Extract a VectorRow from a vector.

        Args:
            name: Vector name for display
            vec: Vector object
            show_values: If True, show all values (for solved results).
                If False, only show values that were originally known (for unknown
                variables table - e.g., a vector might have unknown magnitude but
                known angle, so we show '?' for magnitude but the actual angle value).
        """
        # Check original states to determine what was known before solving
        mag_originally_known = self.problem._original_variable_states.get(f"{name}_mag", True)
        angle_originally_known = self.problem._original_variable_states.get(f"{name}_angle", True)

        # Get magnitude
        mag_qty = vec.magnitude
        if show_values or mag_originally_known:
            if mag_qty is not ... and mag_qty is not None and mag_qty.value is not None:
                mag_str = f"{mag_qty.magnitude():.1f}"
            else:
                mag_str = "?"
        else:
            mag_str = "?"

        # Get angle in degrees
        angle_qty = vec.angle
        if show_values or angle_originally_known:
            if angle_qty is not ... and angle_qty is not None and angle_qty.value is not None:
                angle_deg = angle_qty.to_unit.degree
                angle_str = f"{angle_deg.magnitude():.1f}"
            else:
                angle_str = "?"
        else:
            angle_str = "?"

        # Get reference (wrt attribute) and format it for consistent display
        ref = getattr(vec, "wrt", "+x")
        ref_formatted = _format_reference(ref)

        return VectorRow(
            name=name,
            mag=mag_str,
            angle=angle_str,
            ref=ref_formatted,
        )

    def _build_known_vectors(self) -> list[VectorRow]:
        """Build known vector rows."""
        rows = []
        for name, vec in self.problem.vectors.items():
            if self.problem._original_vector_states.get(name, True):
                rows.append(self._get_vector_row(name, vec, show_values=True))
        return rows

    def _build_unknown_vectors(self) -> list[VectorRow]:
        """Build unknown vector rows (showing ? for values)."""
        rows = []
        for name, vec in self.problem.vectors.items():
            if not self.problem._original_vector_states.get(name, True):
                rows.append(self._get_vector_row(name, vec, show_values=False))
        return rows

    def _build_result_vectors(self) -> list[VectorRow]:
        """Build result vector rows (showing solved values)."""
        rows = []
        for name, vec in self.problem.vectors.items():
            if not self.problem._original_vector_states.get(name, True):
                rows.append(self._get_vector_row(name, vec, show_values=True))
        return rows

    def _build_equations(self) -> list[EquationData]:
        """Build equation data from solving history."""
        equations = []
        seen = set()
        for step in self.problem.solving_history:
            eq_str = step.get("equation_for_list", "")
            if eq_str and eq_str not in seen:
                equations.append(EquationData(latex=eq_str))
                seen.add(eq_str)
        return equations

    def _build_steps(self) -> list[SolutionStepData]:
        """Build solution step data."""
        steps = []
        for i, step in enumerate(self.problem.solving_history, 1):
            target = step.get("target", "Unknown")
            substitution = step.get("substitution", "")
            steps.append(SolutionStepData(
                number=i,
                target=target,
                substitution=substitution,
            ))
        return steps


# =============================================================================
# LaTeX Renderer
# =============================================================================

class LaTeXRenderer:
    """Render ReportData to LaTeX."""

    def render(self, data: ReportData) -> str:
        """Render the complete LaTeX document in compact single-page layout."""
        # Get individual components
        preamble = self._render_preamble(data)

        # Row 1: Problem Setup (with parallelogram) | Variables table
        problem_setup = self._render_problem_setup_diagram(data)
        variables_table = self._render_variables_table(data)

        # Row 2: Equations and Solution
        equations = self._render_equations_section(data)
        solution = self._render_steps_section(data)

        # Row 3: Force Triangle | Results
        force_triangle = self._render_force_triangle_diagram(data)
        results_table = self._render_results_table(data)

        disclaimer = self._render_disclaimer()

        # Combine with side-by-side layout (table 1/3, diagram 2/3)
        # [c] centers content both horizontally and vertically within each minipage
        return rf"""{preamble}
\textbf{{\underline{{Problem Setup}}}}\\[0.5em]
\noindent
\begin{{minipage}}[c]{{0.32\textwidth}}
\begin{{center}}
{variables_table}
\end{{center}}
\end{{minipage}}%
\hfill
\begin{{minipage}}[c]{{0.66\textwidth}}
\begin{{center}}
{problem_setup}
\end{{center}}
\end{{minipage}}

\vspace{{0.5em}}
{equations}

\vspace{{0.5em}}
{solution}

\vspace{{0.5em}}
\textbf{{\underline{{Results}}}}\\[0.5em]
\noindent
\begin{{minipage}}[c]{{0.32\textwidth}}
\begin{{center}}
{results_table}
\end{{center}}
\end{{minipage}}%
\hfill
\begin{{minipage}}[c]{{0.66\textwidth}}
\begin{{center}}
{force_triangle}
\end{{center}}
\end{{minipage}}
{disclaimer}"""

    def _render_preamble(self, data: ReportData) -> str:
        """Render LaTeX preamble."""
        return rf"""\documentclass[10pt,a4paper]{{article}}
\usepackage{{amsmath}}
\usepackage{{amssymb}}
\usepackage{{booktabs}}
\usepackage{{tabularx}}
\usepackage{{geometry}}
\geometry{{margin=0.6in,top=0.5in,bottom=0.5in}}
\usepackage{{enumitem}}
\usepackage{{siunitx}}
\usepackage{{tikz}}
\usepackage{{xcolor}}
\usepackage{{multicol}}
\usetikzlibrary{{calc,arrows.meta}}
\setlength{{\parindent}}{{0pt}}
\setlength{{\parskip}}{{0.3em}}

% Vector notation
\newcommand{{\vv}}[1]{{\vec{{#1}}}}
\newcommand{{\magn}}[1]{{|#1|}}

% TikZ styles for vector diagrams
\colorlet{{vec_f1}}{{blue!80!black}}
\colorlet{{vec_f2}}{{red!80!black}}
\colorlet{{vec_fr}}{{green!60!black}}
\colorlet{{vec_translated}}{{gray!60}}
\tikzset{{
    vector/.style={{-{{Stealth[length=2.5mm,width=1.5mm]}},thick}},
    vector_translated/.style={{-{{Stealth[length=1.5mm,width=1mm]}},dashed,thin}},
}}

\begin{{document}}
\begin{{center}}
\textbf{{\large Engineering Calculation Report: {data.problem_name}}}\\[0.3em]
\small Generated: {{{{GENERATED_DATE}}}}
\end{{center}}
\vspace{{-0.5em}}
\hrule
\vspace{{0.5em}}
"""

    def _render_problem_setup_diagram(self, data: ReportData) -> str:
        """Render the Problem Setup diagram with parallelogram.

        Uses the tikz_diagram module for diagram building and rendering.
        """
        if data.diagram is None or not data.diagram.is_valid:
            return ""

        # Build diagram DTO and render to TikZ
        diagram = build_problem_setup_diagram(data.diagram)
        return render_problem_setup_tikz(diagram)

    def _render_variables_table(self, data: ReportData) -> str:
        """Render compact variables table (known and unknown)."""
        rows = self._format_vector_rows(data.known_vectors)

        if data.unknown_vectors:
            rows.append("\\midrule")
            rows.extend(self._format_vector_rows(data.unknown_vectors))

        # Table only - centering handled by parent minipage
        return rf"""\begin{{tabular}}{{lSSl}}
\toprule
Vector & {{$\magn{{\vv{{F}}}}$ ({data.unit})}} & {{$\theta$ (deg)}} & Ref \\
\midrule
{chr(10).join(rows)}
\bottomrule
\end{{tabular}}"""

    def _render_force_triangle_diagram(self, data: ReportData) -> str:
        """Render the Force Triangle diagram with interior angles.

        Uses the tikz_diagram module for diagram building and rendering.
        """
        if data.diagram is None or not data.diagram.is_valid:
            return ""

        # Build diagram DTO and render to TikZ
        diagram = build_force_triangle_diagram(data.diagram)
        return render_force_triangle_tikz(diagram)

    def _render_results_table(self, data: ReportData) -> str:
        """Render compact results table, centered."""
        rows = self._format_vector_rows(data.result_vectors)

        return rf"""\begin{{tabular}}{{lSSl}}
\toprule
Vector & {{$\magn{{\vv{{F}}}}$ ({data.unit})}} & {{$\theta$ (deg)}} & Ref \\
\midrule
{chr(10).join(rows)}
\bottomrule
\end{{tabular}}"""

    # NOTE: The _render_diagram_section method was REMOVED (dead code, never called).
    # Diagram rendering is done by _render_problem_setup_diagram and _render_force_triangle_diagram.
    # See tikz_diagram.py for modular TikZ diagram utilities and DTOs.

    def _render_vector_table(self, vectors: list[VectorRow], unit: str) -> str:
        """Render a vector table."""
        rows = self._format_vector_rows(vectors)

        return rf"""\begin{{longtable}}{{lSSl}}
\toprule
Vector & {{$\magn{{\vv{{F}}}}$ ({unit})}} & {{$\theta$ (deg)}} & Reference \\
\midrule
\endhead
{chr(10).join(rows)}
\bottomrule
\end{{longtable}}
"""

    def _format_vec_name(self, name: str) -> str:
        """Format vector name: F_1 -> $\\vv{F_1}$, F_AB -> $\\vv{F_{AB}}$"""
        # Use latex_name to handle multi-character subscripts properly
        formatted_name = latex_name(name)
        return f"$\\vv{{{formatted_name}}}$"

    def _format_vector_rows(self, vectors: list[VectorRow]) -> list[str]:
        """Format vector data into LaTeX table rows.

        Args:
            vectors: List of vector row data

        Returns:
            List of LaTeX table row strings
        """
        rows = []
        for v in vectors:
            name_latex = self._format_vec_name(v.name)
            rows.append(f"{name_latex} & {v.mag} & {v.angle} & {v.ref} \\\\")
        return rows

    def _render_known_section(self, data: ReportData) -> str:
        """Render known and unknown variables in a compact combined format."""
        rows = self._format_vector_rows(data.known_vectors)

        # Add separator and unknown vectors
        if data.unknown_vectors:
            rows.append("\\midrule")
            rows.extend(self._format_vector_rows(data.unknown_vectors))

        table = rf"""\begin{{tabular}}{{lSSl}}
\toprule
Vector & {{$\magn{{\vv{{F}}}}$ ({data.unit})}} & {{$\theta$ (deg)}} & Ref \\
\midrule
{chr(10).join(rows)}
\bottomrule
\end{{tabular}}"""

        return f"\n\\textbf{{Variables}} (Known / Unknown)\n\\begin{{center}}\n{table}\n\\end{{center}}"

    def _render_unknown_section(self, data: ReportData) -> str:  # noqa: ARG002
        """Render unknown variables section - now combined with known."""
        # Combined with known section, return empty
        return ""

    def _render_equations_section(self, data: ReportData) -> str:
        """Render equations used section with each equation on its own line."""
        items = []
        for i, eq in enumerate(data.equations, 1):
            latex = self._convert_to_latex_macros(eq.latex)
            items.append(f"\\hspace*{{1em}}({i}) $\\displaystyle {latex}$")

        # Add vertical spacing between equations (\\[0.5em] after each line)
        equations_str = "\\\\[0.5em]\n".join(items)
        return rf"""
\textbf{{\underline{{Equations Used}}}}\\[0.5em]
{equations_str}
"""

    def _convert_to_latex_macros(self, eq: str) -> str:
        """Convert equation string to use LaTeX macros."""
        import re
        result = eq
        # Convert |\vec{X}| to \magn{\vv{X}}
        result = re.sub(r'\|\\vec\{([^}]+)\}\|', r'\\magn{\\vv{\1}}', result)
        # Convert standalone \vec{X} to \vv{X}
        result = re.sub(r'\\vec\{([^}]+)\}', r'\\vv{\1}', result)
        return result

    def _render_steps_section(self, data: ReportData) -> str:
        """Render step-by-step solution section in compact format."""
        steps_latex = []
        for step in data.steps:
            target_latex = self._convert_to_latex_macros(step.target)
            sub_latex = self._format_substitution_compact(step.substitution)

            # Separate math part from suffix (using Eq N, with respect to, etc.)
            if " using Eq " in target_latex:
                math_part, suffix = target_latex.split(" using Eq ", 1)
                title_content = f"${math_part}$ using Eq {suffix}"
            elif " with respect to " in target_latex:
                math_part, suffix = target_latex.split(" with respect to ", 1)
                title_content = f"${math_part}$ with respect to {suffix}"
            else:
                title_content = f"${target_latex}$"

            step_latex = rf"""
\hspace*{{1em}}\textbf{{Step {step.number}:}} {title_content}\\[0.2em]
\hspace*{{2em}}${sub_latex}$
"""
            steps_latex.append(step_latex)

        # Use \\[0.3em] as separator between steps for moderate spacing
        steps_str = '\\\\[0.3em]\n'.join(s.strip() for s in steps_latex)
        return f"\\textbf{{\\underline{{Solution}}}}\\\\[0.5em]\n{steps_str}"

    def _format_substitution_compact(self, sub: str) -> str:
        """Format substitution in compact single-line format."""
        if not sub:
            return ""

        # Convert to LaTeX macros first
        sub = self._convert_substitution_to_latex_macros(sub)

        # Extract just the final result (last line with =)
        lines = sub.strip().split("\n")
        result_parts = []
        for line in lines:
            line = line.strip()
            if line.endswith("\\\\"):
                line = line[:-2].strip()
            # Remove alignment markers (&=, &)
            line = line.replace("&=", "=").replace("& =", "=").replace("&", "")
            # Remove leading = (which comes from the alignment)
            line = line.strip()
            if line.startswith("="):
                line = line[1:].strip()
            if line:
                result_parts.append(line.strip())

        # Return as aligned equations on one line
        return " = ".join(result_parts)

    def _format_substitution(self, sub: str) -> str:
        """Format substitution for flalign environment."""
        if not sub:
            return ""

        # Convert to LaTeX macros first
        sub = self._convert_substitution_to_latex_macros(sub)

        lines = sub.strip().split("\n")
        formatted = []
        for line in lines:
            line = line.strip()
            if line.endswith("\\\\"):
                line = line[:-2].strip()
            if line:
                formatted.append(f"\\quad {line} &&")
        return " \\\\\n".join(formatted)

    def _convert_substitution_to_latex_macros(self, sub: str) -> str:
        """Convert substitution text to use LaTeX macros."""
        import re
        result = sub

        # Convert |\vec{X}| patterns to \magn{\vv{X}}
        result = re.sub(r'\|\\vec\{([^}]+)\}\|', r'\\magn{\\vv{\1}}', result)

        # Convert |...| patterns to \magn{...}
        # This needs to handle complex content like |\angle(...) - \angle(...)|
        # Use a function to properly match balanced |...|
        def convert_abs_to_magn(text: str) -> str:
            out = []
            i = 0
            while i < len(text):
                if text[i] == '|' and (i == 0 or text[i-1] != '\\'):
                    # Found opening |, look for closing |
                    j = i + 1
                    depth = 0
                    while j < len(text):
                        if text[j] == '{':
                            depth += 1
                        elif text[j] == '}':
                            depth -= 1
                        elif text[j] == '|' and depth == 0 and text[j-1] != '\\':
                            # Found closing |
                            content = text[i+1:j]
                            out.append(f'\\magn{{{content}}}')
                            i = j + 1
                            break
                        j += 1
                    else:
                        # No closing | found, just append the |
                        out.append(text[i])
                        i += 1
                else:
                    out.append(text[i])
                    i += 1
            return ''.join(out)

        result = convert_abs_to_magn(result)

        # Convert \vec{X} to \vv{X}
        result = re.sub(r'\\vec\{([^}]+)\}', r'\\vv{\1}', result)
        return result

    def _render_results_section(self, data: ReportData) -> str:
        """Render results summary section."""
        rows = self._format_vector_rows(data.result_vectors)

        table = rf"""\begin{{tabular}}{{lSSl}}
\toprule
Vector & {{$\magn{{\vv{{F}}}}$ ({data.unit})}} & {{$\theta$ (deg)}} & Ref \\
\midrule
{chr(10).join(rows)}
\bottomrule
\end{{tabular}}"""

        return f"\n\\textbf{{Results}}\n\\begin{{center}}\n{table}\n\\end{{center}}"

    def _render_disclaimer(self) -> str:
        """Render compact disclaimer section."""
        return r"""
\vspace{0.5em}
\hrule
\vspace{0.3em}
\begin{center}
\footnotesize
\textbf{Signatures:} Calc. By: \rule{2cm}{0.4pt} \quad Rev. By: \rule{2cm}{0.4pt} \quad Appr. By: \rule{2cm}{0.4pt}
\vspace{0.3em}

\scriptsize\textit{Generated by Qnty Library (Beta). Independent verification required. Users assume full responsibility.}
\end{center}
\end{document}"""


# =============================================================================
# Markdown Renderer
# =============================================================================

class MarkdownRenderer:
    """Render ReportData to Markdown."""

    def render(self, data: ReportData) -> str:
        """Render the complete Markdown document."""
        parts = [
            self._render_header(data),
            self._render_known_section(data),
            self._render_unknown_section(data),
            self._render_equations_section(data),
            self._render_steps_section(data),
            self._render_results_section(data),
            self._render_disclaimer(),
        ]
        return "\n".join(parts)

    def _render_header(self, data: ReportData) -> str:
        """Render Markdown header."""
        return f"""# Engineering Calculation Report: {data.problem_name}

**Generated:** {{{{GENERATED_DATETIME}}}}
"""

    def _render_vector_table(self, vectors: list[VectorRow], unit: str) -> str:
        """Render a Markdown vector table."""
        # Use \| to escape pipes in markdown table header for magnitude column
        lines = [
            "<div align=\"center\">",
            "",
            f"| Vector | $\\|\\vec{{F}}\\|$ ({unit}) | $\\theta$ (deg) | Reference |",
            "| :--- | ---: | ---: | :--- |",
        ]
        for v in vectors:
            name_md = self._format_vec_name_md(v.name)
            lines.append(f"| {name_md} | {v.mag} | {v.angle} | {v.ref} |")
        lines.extend(["", "</div>"])
        return "\n".join(lines)

    def _format_vec_name_md(self, name: str) -> str:
        """Format vector name for Markdown: F_1 -> $\\vec{F_1}$, F_AB -> $\\vec{F_{AB}}$"""
        # Use latex_name to handle multi-character subscripts properly
        formatted_name = latex_name(name)
        return f"$\\vec{{{formatted_name}}}$"

    def _render_known_section(self, data: ReportData) -> str:
        """Render known variables section."""
        table = self._render_vector_table(data.known_vectors, data.unit)
        return f"## 1. Known Variables\n\n{table}\n"

    def _render_unknown_section(self, data: ReportData) -> str:
        """Render unknown variables section."""
        table = self._render_vector_table(data.unknown_vectors, data.unit)
        return f"## 2. Unknown Variables\n\n{table}\n"

    def _render_equations_section(self, data: ReportData) -> str:
        """Render equations used section."""
        lines = ["## 3. Equations Used", ""]
        for i, eq in enumerate(data.equations, 1):
            # Keep as-is but ensure proper escaping
            lines.append(f"{i}. ${eq.latex}$")
            lines.append("")
        return "\n".join(lines)

    def _render_steps_section(self, data: ReportData) -> str:
        """Render step-by-step solution section."""
        lines = ["## 4. Step-by-Step Solution", ""]
        for step in data.steps:
            target = step.target
            # Separate the math part from "using Eq N" or "with respect to" suffix
            if " using Eq " in target:
                math_part, suffix = target.split(" using Eq ", 1)
                title = f"**Step {step.number}: Solve for ${math_part}$ using Eq {suffix}**"
            elif " with respect to " in target:
                math_part, suffix = target.split(" with respect to ", 1)
                title = f"**Step {step.number}: Solve for ${math_part}$ with respect to {suffix}**"
            else:
                title = f"**Step {step.number}: Solve for ${target}$**"

            lines.append(title)
            lines.append("")
            lines.append("$$")
            lines.append("\\begin{aligned}")
            # Format substitution for aligned environment
            sub_lines = self._format_substitution_md(step.substitution)
            lines.extend(sub_lines)
            lines.append("\\end{aligned}")
            lines.append("$$")
            lines.append("")
        return "\n".join(lines)

    def _format_substitution_md(self, sub: str) -> list[str]:
        """Format substitution for Markdown aligned environment."""
        if not sub:
            return []
        result = []
        for line in sub.strip().split("\n"):
            line = line.strip()
            if line.endswith("\\\\"):
                line = line[:-2].strip()
            if line:
                result.append(f"{line} \\\\")
        return result

    def _render_results_section(self, data: ReportData) -> str:
        """Render results summary section."""
        table = self._render_vector_table(data.result_vectors, data.unit)
        return f"## 5. Summary of Results\n\n{table}\n"

    def _render_disclaimer(self) -> str:
        """Render disclaimer section."""
        return """
---

## Disclaimer

While every effort has been made to ensure the accuracy and reliability of the calculations provided, we do not guarantee that the information is complete, up-to-date, or suitable for any specific purpose. Users must independently verify the results and assume full responsibility for any decisions or actions taken based on its output. Use of this calculator is entirely at your own risk, and we expressly disclaim any liability for errors or omissions in the information provided.

**Report Details:**
- **Generated Date:** {{GENERATED_DATE}}
- **Generated Using:** Qnty Library
- **Version:** Beta (Independent verification required for production use)

**Signatures:**

| Role | Name | Signature | Date |
|------|------|-----------|------|
| Calculated By | _________________ | _________________ | _______ |
| Reviewed By | _________________ | _________________ | _______ |
| Approved By | _________________ | _________________ | _______ |

*Report generated using qnty library*"""


# =============================================================================
# Report Generator
# =============================================================================

class ParallelogramReportGenerator:
    """
    Generate reports for parallelogram law problems.

    Supports Markdown, LaTeX, and PDF output formats.
    """

    def __init__(self, problem: ParallelogramLawProblem):
        if not problem.is_solved:
            raise ValueError("Problem must be solved before generating report")
        self.problem = problem
        self.data_builder = ReportDataBuilder(problem)

    def generate(self, output_path: str | Path, format: str = "markdown") -> None:
        """
        Generate a report in the specified format.

        Args:
            output_path: Path for output file
            format: 'markdown', 'latex', or 'pdf'
        """
        output_path = Path(output_path)
        data = self.data_builder.build()

        if format == "latex":
            renderer = LaTeXRenderer()
            content = renderer.render(data)
            output_path.write_text(content, encoding="utf-8")
        elif format == "markdown":
            renderer = MarkdownRenderer()
            content = renderer.render(data)
            output_path.write_text(content, encoding="utf-8")
        elif format == "pdf":
            self._generate_pdf(data, output_path)
        else:
            raise ValueError(f"Unknown format: {format}")

    def _generate_pdf(self, data: ReportData, output_path: Path) -> None:
        """Generate PDF by compiling LaTeX."""
        import subprocess
        import tempfile
        from datetime import datetime

        renderer = LaTeXRenderer()
        latex = renderer.render(data)
        # Replace date placeholder with actual date for PDF
        latex = latex.replace("{{GENERATED_DATE}}", datetime.now().strftime("%Y-%m-%d"))

        with tempfile.NamedTemporaryFile(mode='w', suffix='.tex', delete=False, encoding='utf-8') as f:
            f.write(latex)
            tex_path = Path(f.name)

        try:
            # Try tectonic first (use .exe on Windows)
            import sys
            tectonic_name = "tectonic.exe" if sys.platform == "win32" else "tectonic"
            tectonic_path = Path(__file__).parent.parent.parent / "extensions" / "reporting" / tectonic_name
            if tectonic_path.exists():
                result = subprocess.run(
                    [str(tectonic_path), str(tex_path), "-o", str(output_path.parent)],
                    capture_output=True,
                    timeout=60,
                )
                if result.returncode == 0:
                    generated = output_path.parent / (tex_path.stem + ".pdf")
                    if generated.exists() and generated != output_path:
                        output_path.unlink(missing_ok=True)  # Remove existing file first
                        generated.rename(output_path)
                    return

            raise RuntimeError("PDF generation requires tectonic. Install it or use latex format.")
        finally:
            tex_path.unlink(missing_ok=True)


def generate_report(
    problem: ParallelogramLawProblem,
    output_path: str | Path,
    format: str = "markdown",
) -> None:
    """
    Generate a report for a parallelogram law problem.

    Args:
        problem: Solved ParallelogramLawProblem
        output_path: Output file path
        format: 'markdown', 'latex', or 'pdf'
    """
    generator = ParallelogramReportGenerator(problem)
    generator.generate(output_path, format=format)
