#!/usr/bin/env python3
"""
Units generator for qnty library.

This script generates the units.py file from unit_data.json, creating
comprehensive unit definitions organized by dimensional groups.
"""

import json
from pathlib import Path
from typing import Any

try:
    from .data_processor import (
        augment_with_prefixed_units,
        convert_to_class_name,
        escape_string,
        get_dimension_constant_name,
        get_unit_names_and_aliases,
        is_valid_python_identifier,
        load_unit_data,
        setup_import_path,
    )
except ImportError:
    from .data_processor import (
        augment_with_prefixed_units,
        convert_to_class_name,
        escape_string,
        get_dimension_constant_name,
        get_unit_names_and_aliases,
        is_valid_python_identifier,
        load_unit_data,
        setup_import_path,
    )


class UnitsGenerator:
    """Generator for units.py file."""
    
    def __init__(self, data_path: Path, output_path: Path, out_dir: Path):
        """Initialize with paths."""
        self.data_path = data_path
        self.output_path = output_path
        self.out_dir = out_dir
        self.out_dir.mkdir(parents=True, exist_ok=True)
        
        # Setup import path and load data
        setup_import_path()
        raw_unit_data = load_unit_data(self.data_path)
        
        # Augment with prefixed units using shared processor
        self.unit_data, generated_count = augment_with_prefixed_units(raw_unit_data)
        print(f"Generated {generated_count} prefixed units")
        
        # Track generated info
        self.dimension_constants: set[str] = set()
        self.field_to_class_mapping: dict[str, str] = {}
    
    
    def get_class_name(self, field_name: str) -> str:
        """Convert field name to class name."""
        # Use shared utility and add 'Units' suffix
        class_name = convert_to_class_name(field_name) + 'Units'
        self.field_to_class_mapping[field_name] = class_name
        return class_name
    
    def get_dimension_constant_name(self, field_name: str) -> str:
        """Get the dimension constant name for a field."""
        constant_name = get_dimension_constant_name(field_name)
        self.dimension_constants.add(constant_name)
        return constant_name
    
    
    def generate_header(self) -> list[str]:
        """Generate file header with imports."""
        lines = [
            '"""',
            'Comprehensive Units Module',
            '==========================',
            '',
            'Auto-generated unit definitions for all engineering units.',
            f'Contains {sum(len(field_data["units"]) for field_data in self.unit_data.values())} units',
            f'across {len(self.unit_data)} fields.',
            '',
            'This file is auto-generated by codegen/generators/units_gen.py',
            'DO NOT EDIT MANUALLY - changes will be overwritten.',
            '"""',
            '',
        ]
        
        lines.extend([
            'from ..units.registry import UnitConstant, UnitDefinition',
            'from . import dimensions as dim',
            '',
            '',
        ])
        
        return lines
    
    def generate_unit_class(self, field_name: str, field_data: dict[str, Any]) -> list[str]:
        """Generate a unit class for a field."""
        class_name = self.get_class_name(field_name)
        dimension_constant = self.get_dimension_constant_name(field_name)
        
        lines = [
            f'class {class_name}:',
            f'    """Unit constants for {field_data["field"]}."""',
            '    __slots__ = ()',
            '',
        ]
        
        # Process all units for this field
        units = field_data.get('units', [])
        if not units:
            lines.extend(['    pass', '', ''])
            return lines
        
        # Generate unit constants using shared name processing
        for unit_data in units:
            primary_name, aliases = get_unit_names_and_aliases(unit_data)
            if not is_valid_python_identifier(primary_name):
                continue
            
            full_name = unit_data.get('name', '')
            symbol = unit_data.get('notation', '')
            si_factor = unit_data.get('si_conversion', 1.0)
            
            lines.extend([
                f'    # {full_name}',
                f'    {primary_name} = UnitConstant(UnitDefinition(',
                f'        name="{escape_string(primary_name)}",',
                f'        symbol="{escape_string(symbol)}",',
                f'        dimension=dim.{dimension_constant},',
                f'        si_factor={si_factor},',
                '        si_offset=0.0',
                '    ))',
                '',
            ])
            
            # Add aliases as class attributes using shared processing
            for alias in aliases:
                if is_valid_python_identifier(alias):
                    lines.append(f'    {alias} = {primary_name}')
        
        lines.append('')
        return lines
    
    def generate_registry_function(self) -> list[str]:
        """Generate function to register all units with registry."""
        lines = [
            'def register_all_units(registry) -> None:',
            '    """Register all unit definitions with the registry."""',
            '    unit_classes = [',
        ]
        
        # Add all generated unit classes
        for class_name in sorted(self.field_to_class_mapping.values()):
            lines.append(f'        {class_name},')
        
        lines.extend([
            '    ]',
            '',
            '    for unit_class in unit_classes:',
            '        for attr_name in dir(unit_class):',
            '            if not attr_name.startswith("_"):',
            '                unit_constant = getattr(unit_class, attr_name, None)',
            '                if unit_constant is not None and hasattr(unit_constant, "definition"):',
            '                    unit_def = unit_constant.definition',
            '                    if unit_def.name not in registry.units:',
            '                        registry.register_unit(unit_def)',
            '',
            '    # Finalize registry',
            '    registry.finalize_registration()',
            '',
            '',
        ])
        
        return lines
    
    def generate_dimensionless_class(self) -> list[str]:
        """Generate DimensionlessUnits class for backward compatibility."""
        return [
            '# Backward compatibility class',
            'class DimensionlessUnits:',
            '    """Dimensionless units for backward compatibility."""',
            '    __slots__ = ()',
            '',
            '    dimensionless = UnitConstant(UnitDefinition(',
            '        name="dimensionless",',
            '        symbol="",',
            '        dimension=dim.DIMENSIONLESS,',
            '        si_factor=1.0,',
            '        si_offset=0.0',
            '    ))',
            '',
            '',
        ]
    
    def generate_exports(self) -> list[str]:
        """Generate __all__ export list."""
        lines = [
            '# Export list',
            '__all__ = [',
            '    "register_all_units",',
            '    "DimensionlessUnits",',
        ]
        
        for class_name in sorted(self.field_to_class_mapping.values()):
            lines.append(f'    "{class_name}",')
        
        lines.extend([
            ']',
            '',
        ])
        
        return lines
    
    def generate_statistics(self) -> list[str]:
        """Generate statistics section."""
        total_units = sum(len(field_data.get('units', [])) for field_data in self.unit_data.values())
        
        return [
            '# Statistics',
            f'TOTAL_UNITS = {total_units}',
            f'TOTAL_FIELDS = {len(self.unit_data)}',
            f'TOTAL_DIMENSIONS = {len(self.dimension_constants)}',
        ]
    
    def generate(self) -> None:
        """Generate the complete units.py file."""
        # First pass: collect all dimension constants
        for field_name in self.unit_data.keys():
            self.get_dimension_constant_name(field_name)
            self.get_class_name(field_name)
        
        # Build file content
        lines = []
        lines.extend(self.generate_header())
        
        # Generate unit classes for each field
        for field_name, field_data in sorted(self.unit_data.items()):
            lines.extend(self.generate_unit_class(field_name, field_data))
        
        lines.extend(self.generate_registry_function())
        lines.extend(self.generate_exports())
        lines.extend(self.generate_statistics())
        
        # Write the file
        content = '\n'.join(lines) + '\n'
        self.output_path.write_text(content, encoding='utf-8')
        print(f"Generated {self.output_path}")
        
        # Save metadata
        metadata = {
            'total_units': sum(len(field_data.get('units', [])) for field_data in self.unit_data.values()),
            'total_fields': len(self.unit_data),
            'total_dimensions': len(self.dimension_constants),
            'dimension_constants': sorted(self.dimension_constants),
            'unit_classes': sorted(self.field_to_class_mapping.values()),
        }
        
        metadata_path = self.out_dir / 'units_metadata.json'
        with open(metadata_path, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2)
        print(f"Saved metadata to {metadata_path}")


def main() -> None:
    """Main entry point."""
    # Set up paths
    generator_dir = Path(__file__).parent
    data_path = generator_dir / 'data' / 'unit_data.json'
    output_path = generator_dir.parent.parent / 'generated' / 'units.py'
    out_dir = generator_dir / 'out'
    
    # Create output directory if needed
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Check if data file exists
    if not data_path.exists():
        print(f"Error: Data file not found at {data_path}")
        return
    
    # Run generator
    generator = UnitsGenerator(data_path, output_path, out_dir)
    generator.generate()
    
    print("\nUnits generation complete!")
    print(f"  - Total units: {sum(len(field_data.get('units', [])) for field_data in generator.unit_data.values())}")
    print(f"  - Total fields: {len(generator.unit_data)}")
    print(f"  - Unit classes: {len(generator.field_to_class_mapping)}")


if __name__ == "__main__":
    main()
