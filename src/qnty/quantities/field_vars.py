"""
Quantity Classes Module - Static Edition
========================================

Static quantity class definitions for maximum import performance.
Uses static class generation instead of dynamic type() calls.
Auto-generated by codegen/generators/field_vars.py
DO NOT EDIT MANUALLY - changes will be overwritten.
"""

from typing import Self

from ..dimensions import field_dims as dim
from . import field_setter
from .base_qnty import TypeSafeSetter
from .field_qnty import FieldQnty

# ===== QUANTITY CLASSES =====
# Static quantity class definitions with __slots__ optimization

class AbsorbedDose(FieldQnty):
    """
    Type-safe absorbed radiation dose quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - AbsorbedDose("variable_name") -> Create unknown absorbed radiation dose
    - AbsorbedDose(value, "unit", "variable_name") -> Create known absorbed radiation dose
    
    Examples:
    ---------
    >>> unknown = AbsorbedDose("pressure")  # Unknown absorbed radiation dose
    >>> known = AbsorbedDose(100, "erg_per_gram", "inlet_pressure")  # Known absorbed radiation dose
    
    Available units: "erg_per_gram", "gram_rad", "gray"
    """

    __slots__ = ()
    _setter_class = field_setter.AbsorbedDoseSetter
    _dimension = dim.ABSORBED_DOSE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize absorbed radiation dose quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - AbsorbedDose("name") -> Unknown absorbed radiation dose
        - AbsorbedDose("name", "unit") -> Unknown absorbed radiation dose with unit preference (NEW)
        - AbsorbedDose("name", "unit", value) -> Known absorbed radiation dose (NEW)
        - AbsorbedDose(value, "unit", "name") -> Known absorbed radiation dose (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.AbsorbedDoseSetter':
        """
        Create a setter for this absorbed radiation dose quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            AbsorbedDoseSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.AbsorbedDoseSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.AbsorbedDoseSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this absorbed radiation dose.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this absorbed radiation dose.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Acceleration(FieldQnty):
    """
    Type-safe acceleration quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Acceleration("variable_name") -> Create unknown acceleration
    - Acceleration(value, "unit", "variable_name") -> Create known acceleration
    
    Examples:
    ---------
    >>> unknown = Acceleration("pressure")  # Unknown acceleration
    >>> known = Acceleration(100, "meter_per_second_squared", "inlet_pressure")  # Known acceleration
    
    Available units: "meter_per_second_squared", "foot_per_second_squared"
    """

    __slots__ = ()
    _setter_class = field_setter.AccelerationSetter
    _dimension = dim.ACCELERATION

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize acceleration quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Acceleration("name") -> Unknown acceleration
        - Acceleration("name", "unit") -> Unknown acceleration with unit preference (NEW)
        - Acceleration("name", "unit", value) -> Known acceleration (NEW)
        - Acceleration(value, "unit", "name") -> Known acceleration (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.AccelerationSetter':
        """
        Create a setter for this acceleration quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            AccelerationSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.AccelerationSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.AccelerationSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this acceleration.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this acceleration.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ActivationEnergy(FieldQnty):
    """
    Type-safe activation energy quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ActivationEnergy("variable_name") -> Create unknown activation energy
    - ActivationEnergy(value, "unit", "variable_name") -> Create known activation energy
    
    Examples:
    ---------
    >>> unknown = ActivationEnergy("pressure")  # Unknown activation energy
    >>> known = ActivationEnergy(100, "btu_per_pound_mole", "inlet_pressure")  # Known activation energy
    
    Available units: "btu_per_pound_mole", "calorie_mean_per_gram_mole", "joule_per_gram_mole"
    """

    __slots__ = ()
    _setter_class = field_setter.ActivationEnergySetter
    _dimension = dim.ACTIVATION_ENERGY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize activation energy quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ActivationEnergy("name") -> Unknown activation energy
        - ActivationEnergy("name", "unit") -> Unknown activation energy with unit preference (NEW)
        - ActivationEnergy("name", "unit", value) -> Known activation energy (NEW)
        - ActivationEnergy(value, "unit", "name") -> Known activation energy (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ActivationEnergySetter':
        """
        Create a setter for this activation energy quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ActivationEnergySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ActivationEnergySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ActivationEnergySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this activation energy.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this activation energy.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class AmountOfSubstance(FieldQnty):
    """
    Type-safe amount of substance quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - AmountOfSubstance("variable_name") -> Create unknown amount of substance
    - AmountOfSubstance(value, "unit", "variable_name") -> Create known amount of substance
    
    Examples:
    ---------
    >>> unknown = AmountOfSubstance("pressure")  # Unknown amount of substance
    >>> known = AmountOfSubstance(100, "kilogram_mol", "inlet_pressure")  # Known amount of substance
    
    Available units: "kilogram_mol", "mole", "pound_mole"
    """

    __slots__ = ()
    _setter_class = field_setter.AmountOfSubstanceSetter
    _dimension = dim.AMOUNT_OF_SUBSTANCE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize amount of substance quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - AmountOfSubstance("name") -> Unknown amount of substance
        - AmountOfSubstance("name", "unit") -> Unknown amount of substance with unit preference (NEW)
        - AmountOfSubstance("name", "unit", value) -> Known amount of substance (NEW)
        - AmountOfSubstance(value, "unit", "name") -> Known amount of substance (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.AmountOfSubstanceSetter':
        """
        Create a setter for this amount of substance quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            AmountOfSubstanceSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.AmountOfSubstanceSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.AmountOfSubstanceSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this amount of substance.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this amount of substance.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class AnglePlane(FieldQnty):
    """
    Type-safe angle, plane quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - AnglePlane("variable_name") -> Create unknown angle, plane
    - AnglePlane(value, "unit", "variable_name") -> Create known angle, plane
    
    Examples:
    ---------
    >>> unknown = AnglePlane("pressure")  # Unknown angle, plane
    >>> known = AnglePlane(100, "degree", "inlet_pressure")  # Known angle, plane
    
    Available units: "degree", "gon", "grade"
    """

    __slots__ = ()
    _setter_class = field_setter.AnglePlaneSetter
    _dimension = dim.ANGLE_PLANE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize angle, plane quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - AnglePlane("name") -> Unknown angle, plane
        - AnglePlane("name", "unit") -> Unknown angle, plane with unit preference (NEW)
        - AnglePlane("name", "unit", value) -> Known angle, plane (NEW)
        - AnglePlane(value, "unit", "name") -> Known angle, plane (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.AnglePlaneSetter':
        """
        Create a setter for this angle, plane quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            AnglePlaneSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.AnglePlaneSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.AnglePlaneSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this angle, plane.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this angle, plane.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class AngleSolid(FieldQnty):
    """
    Type-safe angle, solid quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - AngleSolid("variable_name") -> Create unknown angle, solid
    - AngleSolid(value, "unit", "variable_name") -> Create known angle, solid
    
    Examples:
    ---------
    >>> unknown = AngleSolid("pressure")  # Unknown angle, solid
    >>> known = AngleSolid(100, "spat", "inlet_pressure")  # Known angle, solid
    
    Available units: "spat", "square_degree", "square_gon"
    """

    __slots__ = ()
    _setter_class = field_setter.AngleSolidSetter
    _dimension = dim.ANGLE_SOLID

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize angle, solid quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - AngleSolid("name") -> Unknown angle, solid
        - AngleSolid("name", "unit") -> Unknown angle, solid with unit preference (NEW)
        - AngleSolid("name", "unit", value) -> Known angle, solid (NEW)
        - AngleSolid(value, "unit", "name") -> Known angle, solid (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.AngleSolidSetter':
        """
        Create a setter for this angle, solid quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            AngleSolidSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.AngleSolidSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.AngleSolidSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this angle, solid.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this angle, solid.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class AngularAcceleration(FieldQnty):
    """
    Type-safe angular acceleration quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - AngularAcceleration("variable_name") -> Create unknown angular acceleration
    - AngularAcceleration(value, "unit", "variable_name") -> Create known angular acceleration
    
    Examples:
    ---------
    >>> unknown = AngularAcceleration("pressure")  # Unknown angular acceleration
    >>> known = AngularAcceleration(100, "radian_per_second_squared", "inlet_pressure")  # Known angular acceleration
    
    Available units: "radian_per_second_squared", "revolution_per_second_squared", "rpm_or_revolution_per_minute"
    """

    __slots__ = ()
    _setter_class = field_setter.AngularAccelerationSetter
    _dimension = dim.ANGULAR_ACCELERATION

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize angular acceleration quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - AngularAcceleration("name") -> Unknown angular acceleration
        - AngularAcceleration("name", "unit") -> Unknown angular acceleration with unit preference (NEW)
        - AngularAcceleration("name", "unit", value) -> Known angular acceleration (NEW)
        - AngularAcceleration(value, "unit", "name") -> Known angular acceleration (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.AngularAccelerationSetter':
        """
        Create a setter for this angular acceleration quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            AngularAccelerationSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.AngularAccelerationSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.AngularAccelerationSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this angular acceleration.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this angular acceleration.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class AngularMomentum(FieldQnty):
    """
    Type-safe angular momentum quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - AngularMomentum("variable_name") -> Create unknown angular momentum
    - AngularMomentum(value, "unit", "variable_name") -> Create known angular momentum
    
    Examples:
    ---------
    >>> unknown = AngularMomentum("pressure")  # Unknown angular momentum
    >>> known = AngularMomentum(100, "gram_centimeter_squared_per_second", "inlet_pressure")  # Known angular momentum
    
    Available units: "gram_centimeter_squared_per_second", "kilogram_meter_squared_per_second", "pound_force_square_foot_per_second"
    """

    __slots__ = ()
    _setter_class = field_setter.AngularMomentumSetter
    _dimension = dim.ANGULAR_MOMENTUM

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize angular momentum quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - AngularMomentum("name") -> Unknown angular momentum
        - AngularMomentum("name", "unit") -> Unknown angular momentum with unit preference (NEW)
        - AngularMomentum("name", "unit", value) -> Known angular momentum (NEW)
        - AngularMomentum(value, "unit", "name") -> Known angular momentum (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.AngularMomentumSetter':
        """
        Create a setter for this angular momentum quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            AngularMomentumSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.AngularMomentumSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.AngularMomentumSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this angular momentum.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this angular momentum.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Area(FieldQnty):
    """
    Type-safe area quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Area("variable_name") -> Create unknown area
    - Area(value, "unit", "variable_name") -> Create known area
    
    Examples:
    ---------
    >>> unknown = Area("pressure")  # Unknown area
    >>> known = Area(100, "acre_general", "inlet_pressure")  # Known area
    
    Available units: "acre_general", "are", "arpent_quebec"
    """

    __slots__ = ()
    _setter_class = field_setter.AreaSetter
    _dimension = dim.AREA

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize area quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Area("name") -> Unknown area
        - Area("name", "unit") -> Unknown area with unit preference (NEW)
        - Area("name", "unit", value) -> Known area (NEW)
        - Area(value, "unit", "name") -> Known area (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.AreaSetter':
        """
        Create a setter for this area quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            AreaSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.AreaSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.AreaSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this area.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this area.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class AreaPerUnitVolume(FieldQnty):
    """
    Type-safe area per unit volume quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - AreaPerUnitVolume("variable_name") -> Create unknown area per unit volume
    - AreaPerUnitVolume(value, "unit", "variable_name") -> Create known area per unit volume
    
    Examples:
    ---------
    >>> unknown = AreaPerUnitVolume("pressure")  # Unknown area per unit volume
    >>> known = AreaPerUnitVolume(100, "square_centimeter_per_cubic_centimeter", "inlet_pressure")  # Known area per unit volume
    
    Available units: "square_centimeter_per_cubic_centimeter", "square_foot_per_cubic_foot", "square_inch_per_cubic_inch"
    """

    __slots__ = ()
    _setter_class = field_setter.AreaPerUnitVolumeSetter
    _dimension = dim.AREA_PER_UNIT_VOLUME

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize area per unit volume quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - AreaPerUnitVolume("name") -> Unknown area per unit volume
        - AreaPerUnitVolume("name", "unit") -> Unknown area per unit volume with unit preference (NEW)
        - AreaPerUnitVolume("name", "unit", value) -> Known area per unit volume (NEW)
        - AreaPerUnitVolume(value, "unit", "name") -> Known area per unit volume (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.AreaPerUnitVolumeSetter':
        """
        Create a setter for this area per unit volume quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            AreaPerUnitVolumeSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.AreaPerUnitVolumeSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.AreaPerUnitVolumeSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this area per unit volume.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this area per unit volume.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class AtomicWeight(FieldQnty):
    """
    Type-safe atomic weight quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - AtomicWeight("variable_name") -> Create unknown atomic weight
    - AtomicWeight(value, "unit", "variable_name") -> Create known atomic weight
    
    Examples:
    ---------
    >>> unknown = AtomicWeight("pressure")  # Unknown atomic weight
    >>> known = AtomicWeight(100, "atomic_mass_unit_12c", "inlet_pressure")  # Known atomic weight
    
    Available units: "atomic_mass_unit_12c", "grams_per_mole", "kilograms_per_kilomole"
    """

    __slots__ = ()
    _setter_class = field_setter.AtomicWeightSetter
    _dimension = dim.ATOMIC_WEIGHT

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize atomic weight quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - AtomicWeight("name") -> Unknown atomic weight
        - AtomicWeight("name", "unit") -> Unknown atomic weight with unit preference (NEW)
        - AtomicWeight("name", "unit", value) -> Known atomic weight (NEW)
        - AtomicWeight(value, "unit", "name") -> Known atomic weight (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.AtomicWeightSetter':
        """
        Create a setter for this atomic weight quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            AtomicWeightSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.AtomicWeightSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.AtomicWeightSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this atomic weight.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this atomic weight.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Concentration(FieldQnty):
    """
    Type-safe concentration quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Concentration("variable_name") -> Create unknown concentration
    - Concentration(value, "unit", "variable_name") -> Create known concentration
    
    Examples:
    ---------
    >>> unknown = Concentration("pressure")  # Unknown concentration
    >>> known = Concentration(100, "grains_of_i_per_cubic_foot", "inlet_pressure")  # Known concentration
    
    Available units: "grains_of_i_per_cubic_foot", "grains_of_i_per_gallon_us"
    """

    __slots__ = ()
    _setter_class = field_setter.ConcentrationSetter
    _dimension = dim.CONCENTRATION

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize concentration quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Concentration("name") -> Unknown concentration
        - Concentration("name", "unit") -> Unknown concentration with unit preference (NEW)
        - Concentration("name", "unit", value) -> Known concentration (NEW)
        - Concentration(value, "unit", "name") -> Known concentration (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ConcentrationSetter':
        """
        Create a setter for this concentration quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ConcentrationSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ConcentrationSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ConcentrationSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this concentration.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this concentration.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Dimensionless(FieldQnty):
    """
    Type-safe dimensionless quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Dimensionless("variable_name") -> Create unknown dimensionless
    - Dimensionless(value, "variable_name") -> Create known dimensionless
    
    Examples:
    ---------
    >>> unknown = Dimensionless("efficiency")  # Unknown dimensionless
    >>> known = Dimensionless(0.85, "thermal_efficiency")  # Known dimensionless
    """

    __slots__ = ()
    _setter_class = field_setter.DimensionlessSetter
    _dimension = dim.DIMENSIONLESS

    def __init__(self, name_or_value: str | int | float, name_or_unit: str | int | float | None = None):
        """
        Initialize dimensionless quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Dimensionless("name") -> Unknown dimensionless
        - Dimensionless("name", value) -> Known dimensionless (NEW)
        - Dimensionless(value, "name") -> Known dimensionless (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            name_or_unit: Variable name (str) or value (int/float), depending on first arg
        """
        if isinstance(name_or_value, str):
            # NEW syntax: name first
            if name_or_unit is None:
                # Unknown variable
                super().__init__(name_or_value, is_known=False)
            else:
                # Known variable
                super().__init__(name_or_unit, name_or_value, is_known=True)
        else:
            # OLD syntax: value first (backward compatibility)
            if name_or_unit is None:
                raise ValueError("Variable name required")
            super().__init__(name_or_value, name_or_unit, is_known=True)
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.DimensionlessSetter':
        """
        Create a setter for this dimensionless quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            DimensionlessSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.DimensionlessSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.DimensionlessSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this dimensionless.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this dimensionless.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class DynamicFluidity(FieldQnty):
    """
    Type-safe dynamic fluidity quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - DynamicFluidity("variable_name") -> Create unknown dynamic fluidity
    - DynamicFluidity(value, "unit", "variable_name") -> Create known dynamic fluidity
    
    Examples:
    ---------
    >>> unknown = DynamicFluidity("pressure")  # Unknown dynamic fluidity
    >>> known = DynamicFluidity(100, "meter_seconds_per_kilogram", "inlet_pressure")  # Known dynamic fluidity
    
    Available units: "meter_seconds_per_kilogram", "rhe", "square_foot_per_pound_second"
    """

    __slots__ = ()
    _setter_class = field_setter.DynamicFluiditySetter
    _dimension = dim.DYNAMIC_FLUIDITY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize dynamic fluidity quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - DynamicFluidity("name") -> Unknown dynamic fluidity
        - DynamicFluidity("name", "unit") -> Unknown dynamic fluidity with unit preference (NEW)
        - DynamicFluidity("name", "unit", value) -> Known dynamic fluidity (NEW)
        - DynamicFluidity(value, "unit", "name") -> Known dynamic fluidity (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.DynamicFluiditySetter':
        """
        Create a setter for this dynamic fluidity quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            DynamicFluiditySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.DynamicFluiditySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.DynamicFluiditySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this dynamic fluidity.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this dynamic fluidity.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ElectricCapacitance(FieldQnty):
    """
    Type-safe electric capacitance quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ElectricCapacitance("variable_name") -> Create unknown electric capacitance
    - ElectricCapacitance(value, "unit", "variable_name") -> Create known electric capacitance
    
    Examples:
    ---------
    >>> unknown = ElectricCapacitance("pressure")  # Unknown electric capacitance
    >>> known = ElectricCapacitance(100, "cm", "inlet_pressure")  # Known electric capacitance
    
    Available units: "cm", "abfarad", "farad"
    """

    __slots__ = ()
    _setter_class = field_setter.ElectricCapacitanceSetter
    _dimension = dim.ELECTRIC_CAPACITANCE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize electric capacitance quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ElectricCapacitance("name") -> Unknown electric capacitance
        - ElectricCapacitance("name", "unit") -> Unknown electric capacitance with unit preference (NEW)
        - ElectricCapacitance("name", "unit", value) -> Known electric capacitance (NEW)
        - ElectricCapacitance(value, "unit", "name") -> Known electric capacitance (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ElectricCapacitanceSetter':
        """
        Create a setter for this electric capacitance quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ElectricCapacitanceSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ElectricCapacitanceSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ElectricCapacitanceSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this electric capacitance.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this electric capacitance.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ElectricCharge(FieldQnty):
    """
    Type-safe electric charge quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ElectricCharge("variable_name") -> Create unknown electric charge
    - ElectricCharge(value, "unit", "variable_name") -> Create known electric charge
    
    Examples:
    ---------
    >>> unknown = ElectricCharge("pressure")  # Unknown electric charge
    >>> known = ElectricCharge(100, "abcoulomb", "inlet_pressure")  # Known electric charge
    
    Available units: "abcoulomb", "ampere_hour", "coulomb"
    """

    __slots__ = ()
    _setter_class = field_setter.ElectricChargeSetter
    _dimension = dim.ELECTRIC_CHARGE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize electric charge quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ElectricCharge("name") -> Unknown electric charge
        - ElectricCharge("name", "unit") -> Unknown electric charge with unit preference (NEW)
        - ElectricCharge("name", "unit", value) -> Known electric charge (NEW)
        - ElectricCharge(value, "unit", "name") -> Known electric charge (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ElectricChargeSetter':
        """
        Create a setter for this electric charge quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ElectricChargeSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ElectricChargeSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ElectricChargeSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this electric charge.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this electric charge.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ElectricCurrentIntensity(FieldQnty):
    """
    Type-safe electric current intensity quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ElectricCurrentIntensity("variable_name") -> Create unknown electric current intensity
    - ElectricCurrentIntensity(value, "unit", "variable_name") -> Create known electric current intensity
    
    Examples:
    ---------
    >>> unknown = ElectricCurrentIntensity("pressure")  # Unknown electric current intensity
    >>> known = ElectricCurrentIntensity(100, "abampere", "inlet_pressure")  # Known electric current intensity
    
    Available units: "abampere", "ampere_intl_mean", "ampere_intl_us"
    """

    __slots__ = ()
    _setter_class = field_setter.ElectricCurrentIntensitySetter
    _dimension = dim.ELECTRIC_CURRENT_INTENSITY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize electric current intensity quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ElectricCurrentIntensity("name") -> Unknown electric current intensity
        - ElectricCurrentIntensity("name", "unit") -> Unknown electric current intensity with unit preference (NEW)
        - ElectricCurrentIntensity("name", "unit", value) -> Known electric current intensity (NEW)
        - ElectricCurrentIntensity(value, "unit", "name") -> Known electric current intensity (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ElectricCurrentIntensitySetter':
        """
        Create a setter for this electric current intensity quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ElectricCurrentIntensitySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ElectricCurrentIntensitySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ElectricCurrentIntensitySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this electric current intensity.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this electric current intensity.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ElectricDipoleMoment(FieldQnty):
    """
    Type-safe electric dipole moment quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ElectricDipoleMoment("variable_name") -> Create unknown electric dipole moment
    - ElectricDipoleMoment(value, "unit", "variable_name") -> Create known electric dipole moment
    
    Examples:
    ---------
    >>> unknown = ElectricDipoleMoment("pressure")  # Unknown electric dipole moment
    >>> known = ElectricDipoleMoment(100, "ampere_meter_second", "inlet_pressure")  # Known electric dipole moment
    
    Available units: "ampere_meter_second", "coulomb_meter", "debye"
    """

    __slots__ = ()
    _setter_class = field_setter.ElectricDipoleMomentSetter
    _dimension = dim.ELECTRIC_DIPOLE_MOMENT

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize electric dipole moment quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ElectricDipoleMoment("name") -> Unknown electric dipole moment
        - ElectricDipoleMoment("name", "unit") -> Unknown electric dipole moment with unit preference (NEW)
        - ElectricDipoleMoment("name", "unit", value) -> Known electric dipole moment (NEW)
        - ElectricDipoleMoment(value, "unit", "name") -> Known electric dipole moment (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ElectricDipoleMomentSetter':
        """
        Create a setter for this electric dipole moment quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ElectricDipoleMomentSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ElectricDipoleMomentSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ElectricDipoleMomentSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this electric dipole moment.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this electric dipole moment.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ElectricFieldStrength(FieldQnty):
    """
    Type-safe electric field strength quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ElectricFieldStrength("variable_name") -> Create unknown electric field strength
    - ElectricFieldStrength(value, "unit", "variable_name") -> Create known electric field strength
    
    Examples:
    ---------
    >>> unknown = ElectricFieldStrength("pressure")  # Unknown electric field strength
    >>> known = ElectricFieldStrength(100, "volt_per_centimeter", "inlet_pressure")  # Known electric field strength
    
    Available units: "volt_per_centimeter", "volt_per_meter"
    """

    __slots__ = ()
    _setter_class = field_setter.ElectricFieldStrengthSetter
    _dimension = dim.ELECTRIC_FIELD_STRENGTH

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize electric field strength quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ElectricFieldStrength("name") -> Unknown electric field strength
        - ElectricFieldStrength("name", "unit") -> Unknown electric field strength with unit preference (NEW)
        - ElectricFieldStrength("name", "unit", value) -> Known electric field strength (NEW)
        - ElectricFieldStrength(value, "unit", "name") -> Known electric field strength (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ElectricFieldStrengthSetter':
        """
        Create a setter for this electric field strength quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ElectricFieldStrengthSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ElectricFieldStrengthSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ElectricFieldStrengthSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this electric field strength.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this electric field strength.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ElectricInductance(FieldQnty):
    """
    Type-safe electric inductance quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ElectricInductance("variable_name") -> Create unknown electric inductance
    - ElectricInductance(value, "unit", "variable_name") -> Create known electric inductance
    
    Examples:
    ---------
    >>> unknown = ElectricInductance("pressure")  # Unknown electric inductance
    >>> known = ElectricInductance(100, "abhenry", "inlet_pressure")  # Known electric inductance
    
    Available units: "abhenry", "cm", "henry"
    """

    __slots__ = ()
    _setter_class = field_setter.ElectricInductanceSetter
    _dimension = dim.ELECTRIC_INDUCTANCE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize electric inductance quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ElectricInductance("name") -> Unknown electric inductance
        - ElectricInductance("name", "unit") -> Unknown electric inductance with unit preference (NEW)
        - ElectricInductance("name", "unit", value) -> Known electric inductance (NEW)
        - ElectricInductance(value, "unit", "name") -> Known electric inductance (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ElectricInductanceSetter':
        """
        Create a setter for this electric inductance quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ElectricInductanceSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ElectricInductanceSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ElectricInductanceSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this electric inductance.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this electric inductance.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ElectricPotential(FieldQnty):
    """
    Type-safe electric potential quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ElectricPotential("variable_name") -> Create unknown electric potential
    - ElectricPotential(value, "unit", "variable_name") -> Create known electric potential
    
    Examples:
    ---------
    >>> unknown = ElectricPotential("pressure")  # Unknown electric potential
    >>> known = ElectricPotential(100, "abvolt", "inlet_pressure")  # Known electric potential
    
    Available units: "abvolt", "statvolt", "u_a_potential"
    """

    __slots__ = ()
    _setter_class = field_setter.ElectricPotentialSetter
    _dimension = dim.ELECTRIC_POTENTIAL

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize electric potential quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ElectricPotential("name") -> Unknown electric potential
        - ElectricPotential("name", "unit") -> Unknown electric potential with unit preference (NEW)
        - ElectricPotential("name", "unit", value) -> Known electric potential (NEW)
        - ElectricPotential(value, "unit", "name") -> Known electric potential (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ElectricPotentialSetter':
        """
        Create a setter for this electric potential quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ElectricPotentialSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ElectricPotentialSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ElectricPotentialSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this electric potential.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this electric potential.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ElectricResistance(FieldQnty):
    """
    Type-safe electric resistance quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ElectricResistance("variable_name") -> Create unknown electric resistance
    - ElectricResistance(value, "unit", "variable_name") -> Create known electric resistance
    
    Examples:
    ---------
    >>> unknown = ElectricResistance("pressure")  # Unknown electric resistance
    >>> known = ElectricResistance(100, "abohm", "inlet_pressure")  # Known electric resistance
    
    Available units: "abohm", "jacobi", "lenz"
    """

    __slots__ = ()
    _setter_class = field_setter.ElectricResistanceSetter
    _dimension = dim.ELECTRIC_RESISTANCE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize electric resistance quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ElectricResistance("name") -> Unknown electric resistance
        - ElectricResistance("name", "unit") -> Unknown electric resistance with unit preference (NEW)
        - ElectricResistance("name", "unit", value) -> Known electric resistance (NEW)
        - ElectricResistance(value, "unit", "name") -> Known electric resistance (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ElectricResistanceSetter':
        """
        Create a setter for this electric resistance quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ElectricResistanceSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ElectricResistanceSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ElectricResistanceSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this electric resistance.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this electric resistance.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ElectricalConductance(FieldQnty):
    """
    Type-safe electrical conductance quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ElectricalConductance("variable_name") -> Create unknown electrical conductance
    - ElectricalConductance(value, "unit", "variable_name") -> Create known electrical conductance
    
    Examples:
    ---------
    >>> unknown = ElectricalConductance("pressure")  # Unknown electrical conductance
    >>> known = ElectricalConductance(100, "emu_cgs", "inlet_pressure")  # Known electrical conductance
    
    Available units: "emu_cgs", "esu_cgs", "mho"
    """

    __slots__ = ()
    _setter_class = field_setter.ElectricalConductanceSetter
    _dimension = dim.ELECTRICAL_CONDUCTANCE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize electrical conductance quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ElectricalConductance("name") -> Unknown electrical conductance
        - ElectricalConductance("name", "unit") -> Unknown electrical conductance with unit preference (NEW)
        - ElectricalConductance("name", "unit", value) -> Known electrical conductance (NEW)
        - ElectricalConductance(value, "unit", "name") -> Known electrical conductance (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ElectricalConductanceSetter':
        """
        Create a setter for this electrical conductance quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ElectricalConductanceSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ElectricalConductanceSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ElectricalConductanceSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this electrical conductance.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this electrical conductance.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ElectricalPermittivity(FieldQnty):
    """
    Type-safe electrical permittivity quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ElectricalPermittivity("variable_name") -> Create unknown electrical permittivity
    - ElectricalPermittivity(value, "unit", "variable_name") -> Create known electrical permittivity
    
    Examples:
    ---------
    >>> unknown = ElectricalPermittivity("pressure")  # Unknown electrical permittivity
    >>> known = ElectricalPermittivity(100, "farad_per_meter", "inlet_pressure")  # Known electrical permittivity
    
    Available units: "farad_per_meter"
    """

    __slots__ = ()
    _setter_class = field_setter.ElectricalPermittivitySetter
    _dimension = dim.ELECTRICAL_PERMITTIVITY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize electrical permittivity quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ElectricalPermittivity("name") -> Unknown electrical permittivity
        - ElectricalPermittivity("name", "unit") -> Unknown electrical permittivity with unit preference (NEW)
        - ElectricalPermittivity("name", "unit", value) -> Known electrical permittivity (NEW)
        - ElectricalPermittivity(value, "unit", "name") -> Known electrical permittivity (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ElectricalPermittivitySetter':
        """
        Create a setter for this electrical permittivity quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ElectricalPermittivitySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ElectricalPermittivitySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ElectricalPermittivitySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this electrical permittivity.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this electrical permittivity.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ElectricalResistivity(FieldQnty):
    """
    Type-safe electrical resistivity quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ElectricalResistivity("variable_name") -> Create unknown electrical resistivity
    - ElectricalResistivity(value, "unit", "variable_name") -> Create known electrical resistivity
    
    Examples:
    ---------
    >>> unknown = ElectricalResistivity("pressure")  # Unknown electrical resistivity
    >>> known = ElectricalResistivity(100, "circular_mil_ohm_per_foot", "inlet_pressure")  # Known electrical resistivity
    
    Available units: "circular_mil_ohm_per_foot", "emu_cgs", "microhm_inch"
    """

    __slots__ = ()
    _setter_class = field_setter.ElectricalResistivitySetter
    _dimension = dim.ELECTRICAL_RESISTIVITY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize electrical resistivity quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ElectricalResistivity("name") -> Unknown electrical resistivity
        - ElectricalResistivity("name", "unit") -> Unknown electrical resistivity with unit preference (NEW)
        - ElectricalResistivity("name", "unit", value) -> Known electrical resistivity (NEW)
        - ElectricalResistivity(value, "unit", "name") -> Known electrical resistivity (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ElectricalResistivitySetter':
        """
        Create a setter for this electrical resistivity quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ElectricalResistivitySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ElectricalResistivitySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ElectricalResistivitySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this electrical resistivity.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this electrical resistivity.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class EnergyFlux(FieldQnty):
    """
    Type-safe energy flux quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - EnergyFlux("variable_name") -> Create unknown energy flux
    - EnergyFlux(value, "unit", "variable_name") -> Create known energy flux
    
    Examples:
    ---------
    >>> unknown = EnergyFlux("pressure")  # Unknown energy flux
    >>> known = EnergyFlux(100, "btu_per_square_foot_per_hour", "inlet_pressure")  # Known energy flux
    
    Available units: "btu_per_square_foot_per_hour", "calorie_per_square_centimeter_per_second", "celsius_heat_units_chu"
    """

    __slots__ = ()
    _setter_class = field_setter.EnergyFluxSetter
    _dimension = dim.ENERGY_FLUX

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize energy flux quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - EnergyFlux("name") -> Unknown energy flux
        - EnergyFlux("name", "unit") -> Unknown energy flux with unit preference (NEW)
        - EnergyFlux("name", "unit", value) -> Known energy flux (NEW)
        - EnergyFlux(value, "unit", "name") -> Known energy flux (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.EnergyFluxSetter':
        """
        Create a setter for this energy flux quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            EnergyFluxSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.EnergyFluxSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.EnergyFluxSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this energy flux.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this energy flux.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class EnergyHeatWork(FieldQnty):
    """
    Type-safe energy, heat, work quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - EnergyHeatWork("variable_name") -> Create unknown energy, heat, work
    - EnergyHeatWork(value, "unit", "variable_name") -> Create known energy, heat, work
    
    Examples:
    ---------
    >>> unknown = EnergyHeatWork("pressure")  # Unknown energy, heat, work
    >>> known = EnergyHeatWork(100, "barrel_oil_equivalent_or_equivalent_barrel", "inlet_pressure")  # Known energy, heat, work
    
    Available units: "barrel_oil_equivalent_or_equivalent_barrel", "billion_electronvolt", "british_thermal_unit_4circ_mathrmc"
    """

    __slots__ = ()
    _setter_class = field_setter.EnergyHeatWorkSetter
    _dimension = dim.ENERGY_HEAT_WORK

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize energy, heat, work quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - EnergyHeatWork("name") -> Unknown energy, heat, work
        - EnergyHeatWork("name", "unit") -> Unknown energy, heat, work with unit preference (NEW)
        - EnergyHeatWork("name", "unit", value) -> Known energy, heat, work (NEW)
        - EnergyHeatWork(value, "unit", "name") -> Known energy, heat, work (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.EnergyHeatWorkSetter':
        """
        Create a setter for this energy, heat, work quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            EnergyHeatWorkSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.EnergyHeatWorkSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.EnergyHeatWorkSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this energy, heat, work.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this energy, heat, work.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class EnergyPerUnitArea(FieldQnty):
    """
    Type-safe energy per unit area quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - EnergyPerUnitArea("variable_name") -> Create unknown energy per unit area
    - EnergyPerUnitArea(value, "unit", "variable_name") -> Create known energy per unit area
    
    Examples:
    ---------
    >>> unknown = EnergyPerUnitArea("pressure")  # Unknown energy per unit area
    >>> known = EnergyPerUnitArea(100, "british_thermal_unit_per_square_foot", "inlet_pressure")  # Known energy per unit area
    
    Available units: "british_thermal_unit_per_square_foot", "joule_per_square_meter", "langley"
    """

    __slots__ = ()
    _setter_class = field_setter.EnergyPerUnitAreaSetter
    _dimension = dim.ENERGY_PER_UNIT_AREA

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize energy per unit area quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - EnergyPerUnitArea("name") -> Unknown energy per unit area
        - EnergyPerUnitArea("name", "unit") -> Unknown energy per unit area with unit preference (NEW)
        - EnergyPerUnitArea("name", "unit", value) -> Known energy per unit area (NEW)
        - EnergyPerUnitArea(value, "unit", "name") -> Known energy per unit area (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.EnergyPerUnitAreaSetter':
        """
        Create a setter for this energy per unit area quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            EnergyPerUnitAreaSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.EnergyPerUnitAreaSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.EnergyPerUnitAreaSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this energy per unit area.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this energy per unit area.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Force(FieldQnty):
    """
    Type-safe force quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Force("variable_name") -> Create unknown force
    - Force(value, "unit", "variable_name") -> Create known force
    
    Examples:
    ---------
    >>> unknown = Force("pressure")  # Unknown force
    >>> known = Force(100, "crinal", "inlet_pressure")  # Known force
    
    Available units: "crinal", "dyne", "funal"
    """

    __slots__ = ()
    _setter_class = field_setter.ForceSetter
    _dimension = dim.FORCE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize force quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Force("name") -> Unknown force
        - Force("name", "unit") -> Unknown force with unit preference (NEW)
        - Force("name", "unit", value) -> Known force (NEW)
        - Force(value, "unit", "name") -> Known force (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ForceSetter':
        """
        Create a setter for this force quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ForceSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ForceSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ForceSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this force.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this force.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ForceBody(FieldQnty):
    """
    Type-safe force (body) quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ForceBody("variable_name") -> Create unknown force (body)
    - ForceBody(value, "unit", "variable_name") -> Create known force (body)
    
    Examples:
    ---------
    >>> unknown = ForceBody("pressure")  # Unknown force (body)
    >>> known = ForceBody(100, "dyne_per_cubic_centimeter", "inlet_pressure")  # Known force (body)
    
    Available units: "dyne_per_cubic_centimeter", "kilogram_force_per_cubic_centimeter", "kilogram_force_per_cubic_meter"
    """

    __slots__ = ()
    _setter_class = field_setter.ForceBodySetter
    _dimension = dim.FORCE_BODY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize force (body) quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ForceBody("name") -> Unknown force (body)
        - ForceBody("name", "unit") -> Unknown force (body) with unit preference (NEW)
        - ForceBody("name", "unit", value) -> Known force (body) (NEW)
        - ForceBody(value, "unit", "name") -> Known force (body) (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ForceBodySetter':
        """
        Create a setter for this force (body) quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ForceBodySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ForceBodySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ForceBodySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this force (body).
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this force (body).
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ForcePerUnitMass(FieldQnty):
    """
    Type-safe force per unit mass quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ForcePerUnitMass("variable_name") -> Create unknown force per unit mass
    - ForcePerUnitMass(value, "unit", "variable_name") -> Create known force per unit mass
    
    Examples:
    ---------
    >>> unknown = ForcePerUnitMass("pressure")  # Unknown force per unit mass
    >>> known = ForcePerUnitMass(100, "dyne_per_gram", "inlet_pressure")  # Known force per unit mass
    
    Available units: "dyne_per_gram", "kilogram_force_per_kilogram", "newton_per_kilogram"
    """

    __slots__ = ()
    _setter_class = field_setter.ForcePerUnitMassSetter
    _dimension = dim.FORCE_PER_UNIT_MASS

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize force per unit mass quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ForcePerUnitMass("name") -> Unknown force per unit mass
        - ForcePerUnitMass("name", "unit") -> Unknown force per unit mass with unit preference (NEW)
        - ForcePerUnitMass("name", "unit", value) -> Known force per unit mass (NEW)
        - ForcePerUnitMass(value, "unit", "name") -> Known force per unit mass (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ForcePerUnitMassSetter':
        """
        Create a setter for this force per unit mass quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ForcePerUnitMassSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ForcePerUnitMassSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ForcePerUnitMassSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this force per unit mass.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this force per unit mass.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class FrequencyVoltageRatio(FieldQnty):
    """
    Type-safe frequency voltage ratio quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - FrequencyVoltageRatio("variable_name") -> Create unknown frequency voltage ratio
    - FrequencyVoltageRatio(value, "unit", "variable_name") -> Create known frequency voltage ratio
    
    Examples:
    ---------
    >>> unknown = FrequencyVoltageRatio("pressure")  # Unknown frequency voltage ratio
    >>> known = FrequencyVoltageRatio(100, "cycles_per_second_per_volt", "inlet_pressure")  # Known frequency voltage ratio
    
    Available units: "cycles_per_second_per_volt", "hertz_per_volt", "terahertz_per_volt"
    """

    __slots__ = ()
    _setter_class = field_setter.FrequencyVoltageRatioSetter
    _dimension = dim.FREQUENCY_VOLTAGE_RATIO

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize frequency voltage ratio quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - FrequencyVoltageRatio("name") -> Unknown frequency voltage ratio
        - FrequencyVoltageRatio("name", "unit") -> Unknown frequency voltage ratio with unit preference (NEW)
        - FrequencyVoltageRatio("name", "unit", value) -> Known frequency voltage ratio (NEW)
        - FrequencyVoltageRatio(value, "unit", "name") -> Known frequency voltage ratio (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.FrequencyVoltageRatioSetter':
        """
        Create a setter for this frequency voltage ratio quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            FrequencyVoltageRatioSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.FrequencyVoltageRatioSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.FrequencyVoltageRatioSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this frequency voltage ratio.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this frequency voltage ratio.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class FuelConsumption(FieldQnty):
    """
    Type-safe fuel consumption quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - FuelConsumption("variable_name") -> Create unknown fuel consumption
    - FuelConsumption(value, "unit", "variable_name") -> Create known fuel consumption
    
    Examples:
    ---------
    >>> unknown = FuelConsumption("pressure")  # Unknown fuel consumption
    >>> known = FuelConsumption(100, "unit_100_km_per_liter", "inlet_pressure")  # Known fuel consumption
    
    Available units: "unit_100_km_per_liter", "gallons_uk", "gallons_us"
    """

    __slots__ = ()
    _setter_class = field_setter.FuelConsumptionSetter
    _dimension = dim.FUEL_CONSUMPTION

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize fuel consumption quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - FuelConsumption("name") -> Unknown fuel consumption
        - FuelConsumption("name", "unit") -> Unknown fuel consumption with unit preference (NEW)
        - FuelConsumption("name", "unit", value) -> Known fuel consumption (NEW)
        - FuelConsumption(value, "unit", "name") -> Known fuel consumption (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.FuelConsumptionSetter':
        """
        Create a setter for this fuel consumption quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            FuelConsumptionSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.FuelConsumptionSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.FuelConsumptionSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this fuel consumption.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this fuel consumption.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class HeatOfCombustion(FieldQnty):
    """
    Type-safe heat of combustion quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - HeatOfCombustion("variable_name") -> Create unknown heat of combustion
    - HeatOfCombustion(value, "unit", "variable_name") -> Create known heat of combustion
    
    Examples:
    ---------
    >>> unknown = HeatOfCombustion("pressure")  # Unknown heat of combustion
    >>> known = HeatOfCombustion(100, "british_thermal_unit_per_pound", "inlet_pressure")  # Known heat of combustion
    
    Available units: "british_thermal_unit_per_pound", "calorie_per_gram", "chu_per_pound"
    """

    __slots__ = ()
    _setter_class = field_setter.HeatOfCombustionSetter
    _dimension = dim.HEAT_OF_COMBUSTION

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize heat of combustion quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - HeatOfCombustion("name") -> Unknown heat of combustion
        - HeatOfCombustion("name", "unit") -> Unknown heat of combustion with unit preference (NEW)
        - HeatOfCombustion("name", "unit", value) -> Known heat of combustion (NEW)
        - HeatOfCombustion(value, "unit", "name") -> Known heat of combustion (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.HeatOfCombustionSetter':
        """
        Create a setter for this heat of combustion quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            HeatOfCombustionSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.HeatOfCombustionSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.HeatOfCombustionSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this heat of combustion.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this heat of combustion.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class HeatOfFusion(FieldQnty):
    """
    Type-safe heat of fusion quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - HeatOfFusion("variable_name") -> Create unknown heat of fusion
    - HeatOfFusion(value, "unit", "variable_name") -> Create known heat of fusion
    
    Examples:
    ---------
    >>> unknown = HeatOfFusion("pressure")  # Unknown heat of fusion
    >>> known = HeatOfFusion(100, "british_thermal_unit_mean", "inlet_pressure")  # Known heat of fusion
    
    Available units: "british_thermal_unit_mean", "british_thermal_unit_per_pound", "calorie_per_gram"
    """

    __slots__ = ()
    _setter_class = field_setter.HeatOfFusionSetter
    _dimension = dim.HEAT_OF_FUSION

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize heat of fusion quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - HeatOfFusion("name") -> Unknown heat of fusion
        - HeatOfFusion("name", "unit") -> Unknown heat of fusion with unit preference (NEW)
        - HeatOfFusion("name", "unit", value) -> Known heat of fusion (NEW)
        - HeatOfFusion(value, "unit", "name") -> Known heat of fusion (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.HeatOfFusionSetter':
        """
        Create a setter for this heat of fusion quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            HeatOfFusionSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.HeatOfFusionSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.HeatOfFusionSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this heat of fusion.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this heat of fusion.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class HeatOfVaporization(FieldQnty):
    """
    Type-safe heat of vaporization quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - HeatOfVaporization("variable_name") -> Create unknown heat of vaporization
    - HeatOfVaporization(value, "unit", "variable_name") -> Create known heat of vaporization
    
    Examples:
    ---------
    >>> unknown = HeatOfVaporization("pressure")  # Unknown heat of vaporization
    >>> known = HeatOfVaporization(100, "british_thermal_unit_per_pound", "inlet_pressure")  # Known heat of vaporization
    
    Available units: "british_thermal_unit_per_pound", "calorie_per_gram", "chu_per_pound"
    """

    __slots__ = ()
    _setter_class = field_setter.HeatOfVaporizationSetter
    _dimension = dim.HEAT_OF_VAPORIZATION

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize heat of vaporization quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - HeatOfVaporization("name") -> Unknown heat of vaporization
        - HeatOfVaporization("name", "unit") -> Unknown heat of vaporization with unit preference (NEW)
        - HeatOfVaporization("name", "unit", value) -> Known heat of vaporization (NEW)
        - HeatOfVaporization(value, "unit", "name") -> Known heat of vaporization (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.HeatOfVaporizationSetter':
        """
        Create a setter for this heat of vaporization quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            HeatOfVaporizationSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.HeatOfVaporizationSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.HeatOfVaporizationSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this heat of vaporization.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this heat of vaporization.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class HeatTransferCoefficient(FieldQnty):
    """
    Type-safe heat transfer coefficient quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - HeatTransferCoefficient("variable_name") -> Create unknown heat transfer coefficient
    - HeatTransferCoefficient(value, "unit", "variable_name") -> Create known heat transfer coefficient
    
    Examples:
    ---------
    >>> unknown = HeatTransferCoefficient("pressure")  # Unknown heat transfer coefficient
    >>> known = HeatTransferCoefficient(100, "btu_per_square_foot_per_hour_per_degree_fahrenheit_or_rankine", "inlet_pressure")  # Known heat transfer coefficient
    
    Available units: "btu_per_square_foot_per_hour_per_degree_fahrenheit_or_rankine", "watt_per_square_meter_per_degree_celsius_or_kelvin"
    """

    __slots__ = ()
    _setter_class = field_setter.HeatTransferCoefficientSetter
    _dimension = dim.HEAT_TRANSFER_COEFFICIENT

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize heat transfer coefficient quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - HeatTransferCoefficient("name") -> Unknown heat transfer coefficient
        - HeatTransferCoefficient("name", "unit") -> Unknown heat transfer coefficient with unit preference (NEW)
        - HeatTransferCoefficient("name", "unit", value) -> Known heat transfer coefficient (NEW)
        - HeatTransferCoefficient(value, "unit", "name") -> Known heat transfer coefficient (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.HeatTransferCoefficientSetter':
        """
        Create a setter for this heat transfer coefficient quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            HeatTransferCoefficientSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.HeatTransferCoefficientSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.HeatTransferCoefficientSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this heat transfer coefficient.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this heat transfer coefficient.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Illuminance(FieldQnty):
    """
    Type-safe illuminance quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Illuminance("variable_name") -> Create unknown illuminance
    - Illuminance(value, "unit", "variable_name") -> Create known illuminance
    
    Examples:
    ---------
    >>> unknown = Illuminance("pressure")  # Unknown illuminance
    >>> known = Illuminance(100, "foot_candle", "inlet_pressure")  # Known illuminance
    
    Available units: "foot_candle", "lux", "nox"
    """

    __slots__ = ()
    _setter_class = field_setter.IlluminanceSetter
    _dimension = dim.ILLUMINANCE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize illuminance quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Illuminance("name") -> Unknown illuminance
        - Illuminance("name", "unit") -> Unknown illuminance with unit preference (NEW)
        - Illuminance("name", "unit", value) -> Known illuminance (NEW)
        - Illuminance(value, "unit", "name") -> Known illuminance (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.IlluminanceSetter':
        """
        Create a setter for this illuminance quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            IlluminanceSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.IlluminanceSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.IlluminanceSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this illuminance.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this illuminance.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class KineticEnergyOfTurbulence(FieldQnty):
    """
    Type-safe kinetic energy of turbulence quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - KineticEnergyOfTurbulence("variable_name") -> Create unknown kinetic energy of turbulence
    - KineticEnergyOfTurbulence(value, "unit", "variable_name") -> Create known kinetic energy of turbulence
    
    Examples:
    ---------
    >>> unknown = KineticEnergyOfTurbulence("pressure")  # Unknown kinetic energy of turbulence
    >>> known = KineticEnergyOfTurbulence(100, "square_foot_per_second_squared", "inlet_pressure")  # Known kinetic energy of turbulence
    
    Available units: "square_foot_per_second_squared", "square_meters_per_second_squared"
    """

    __slots__ = ()
    _setter_class = field_setter.KineticEnergyOfTurbulenceSetter
    _dimension = dim.KINETIC_ENERGY_OF_TURBULENCE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize kinetic energy of turbulence quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - KineticEnergyOfTurbulence("name") -> Unknown kinetic energy of turbulence
        - KineticEnergyOfTurbulence("name", "unit") -> Unknown kinetic energy of turbulence with unit preference (NEW)
        - KineticEnergyOfTurbulence("name", "unit", value) -> Known kinetic energy of turbulence (NEW)
        - KineticEnergyOfTurbulence(value, "unit", "name") -> Known kinetic energy of turbulence (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.KineticEnergyOfTurbulenceSetter':
        """
        Create a setter for this kinetic energy of turbulence quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            KineticEnergyOfTurbulenceSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.KineticEnergyOfTurbulenceSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.KineticEnergyOfTurbulenceSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this kinetic energy of turbulence.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this kinetic energy of turbulence.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Length(FieldQnty):
    """
    Type-safe length quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Length("variable_name") -> Create unknown length
    - Length(value, "unit", "variable_name") -> Create known length
    
    Examples:
    ---------
    >>> unknown = Length("pressure")  # Unknown length
    >>> known = Length(100, "ngstr_m", "inlet_pressure")  # Known length
    
    Available units: "ngstr_m", "arpent_quebec", "astronomic_unit"
    """

    __slots__ = ()
    _setter_class = field_setter.LengthSetter
    _dimension = dim.LENGTH

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize length quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Length("name") -> Unknown length
        - Length("name", "unit") -> Unknown length with unit preference (NEW)
        - Length("name", "unit", value) -> Known length (NEW)
        - Length(value, "unit", "name") -> Known length (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.LengthSetter':
        """
        Create a setter for this length quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            LengthSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.LengthSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.LengthSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this length.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this length.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class LinearMassDensity(FieldQnty):
    """
    Type-safe linear mass density quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - LinearMassDensity("variable_name") -> Create unknown linear mass density
    - LinearMassDensity(value, "unit", "variable_name") -> Create known linear mass density
    
    Examples:
    ---------
    >>> unknown = LinearMassDensity("pressure")  # Unknown linear mass density
    >>> known = LinearMassDensity(100, "denier", "inlet_pressure")  # Known linear mass density
    
    Available units: "denier", "kilogram_per_centimeter", "kilogram_per_meter"
    """

    __slots__ = ()
    _setter_class = field_setter.LinearMassDensitySetter
    _dimension = dim.LINEAR_MASS_DENSITY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize linear mass density quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - LinearMassDensity("name") -> Unknown linear mass density
        - LinearMassDensity("name", "unit") -> Unknown linear mass density with unit preference (NEW)
        - LinearMassDensity("name", "unit", value) -> Known linear mass density (NEW)
        - LinearMassDensity(value, "unit", "name") -> Known linear mass density (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.LinearMassDensitySetter':
        """
        Create a setter for this linear mass density quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            LinearMassDensitySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.LinearMassDensitySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.LinearMassDensitySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this linear mass density.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this linear mass density.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class LinearMomentum(FieldQnty):
    """
    Type-safe linear momentum quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - LinearMomentum("variable_name") -> Create unknown linear momentum
    - LinearMomentum(value, "unit", "variable_name") -> Create known linear momentum
    
    Examples:
    ---------
    >>> unknown = LinearMomentum("pressure")  # Unknown linear momentum
    >>> known = LinearMomentum(100, "foot_pounds_force_per_hour", "inlet_pressure")  # Known linear momentum
    
    Available units: "foot_pounds_force_per_hour", "foot_pounds_force_per_minute", "foot_pounds_force_per_second"
    """

    __slots__ = ()
    _setter_class = field_setter.LinearMomentumSetter
    _dimension = dim.LINEAR_MOMENTUM

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize linear momentum quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - LinearMomentum("name") -> Unknown linear momentum
        - LinearMomentum("name", "unit") -> Unknown linear momentum with unit preference (NEW)
        - LinearMomentum("name", "unit", value) -> Known linear momentum (NEW)
        - LinearMomentum(value, "unit", "name") -> Known linear momentum (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.LinearMomentumSetter':
        """
        Create a setter for this linear momentum quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            LinearMomentumSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.LinearMomentumSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.LinearMomentumSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this linear momentum.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this linear momentum.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class LuminanceSelf(FieldQnty):
    """
    Type-safe luminance (self) quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - LuminanceSelf("variable_name") -> Create unknown luminance (self)
    - LuminanceSelf(value, "unit", "variable_name") -> Create known luminance (self)
    
    Examples:
    ---------
    >>> unknown = LuminanceSelf("pressure")  # Unknown luminance (self)
    >>> known = LuminanceSelf(100, "apostilb", "inlet_pressure")  # Known luminance (self)
    
    Available units: "apostilb", "blondel", "candela_per_square_meter"
    """

    __slots__ = ()
    _setter_class = field_setter.LuminanceSelfSetter
    _dimension = dim.LUMINANCE_SELF

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize luminance (self) quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - LuminanceSelf("name") -> Unknown luminance (self)
        - LuminanceSelf("name", "unit") -> Unknown luminance (self) with unit preference (NEW)
        - LuminanceSelf("name", "unit", value) -> Known luminance (self) (NEW)
        - LuminanceSelf(value, "unit", "name") -> Known luminance (self) (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.LuminanceSelfSetter':
        """
        Create a setter for this luminance (self) quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            LuminanceSelfSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.LuminanceSelfSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.LuminanceSelfSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this luminance (self).
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this luminance (self).
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class LuminousFlux(FieldQnty):
    """
    Type-safe luminous flux quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - LuminousFlux("variable_name") -> Create unknown luminous flux
    - LuminousFlux(value, "unit", "variable_name") -> Create known luminous flux
    
    Examples:
    ---------
    >>> unknown = LuminousFlux("pressure")  # Unknown luminous flux
    >>> known = LuminousFlux(100, "candela_steradian", "inlet_pressure")  # Known luminous flux
    
    Available units: "candela_steradian", "lumen"
    """

    __slots__ = ()
    _setter_class = field_setter.LuminousFluxSetter
    _dimension = dim.LUMINOUS_FLUX

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize luminous flux quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - LuminousFlux("name") -> Unknown luminous flux
        - LuminousFlux("name", "unit") -> Unknown luminous flux with unit preference (NEW)
        - LuminousFlux("name", "unit", value) -> Known luminous flux (NEW)
        - LuminousFlux(value, "unit", "name") -> Known luminous flux (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.LuminousFluxSetter':
        """
        Create a setter for this luminous flux quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            LuminousFluxSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.LuminousFluxSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.LuminousFluxSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this luminous flux.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this luminous flux.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class LuminousIntensity(FieldQnty):
    """
    Type-safe luminous intensity quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - LuminousIntensity("variable_name") -> Create unknown luminous intensity
    - LuminousIntensity(value, "unit", "variable_name") -> Create known luminous intensity
    
    Examples:
    ---------
    >>> unknown = LuminousIntensity("pressure")  # Unknown luminous intensity
    >>> known = LuminousIntensity(100, "candela", "inlet_pressure")  # Known luminous intensity
    
    Available units: "candela", "candle_international", "carcel"
    """

    __slots__ = ()
    _setter_class = field_setter.LuminousIntensitySetter
    _dimension = dim.LUMINOUS_INTENSITY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize luminous intensity quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - LuminousIntensity("name") -> Unknown luminous intensity
        - LuminousIntensity("name", "unit") -> Unknown luminous intensity with unit preference (NEW)
        - LuminousIntensity("name", "unit", value) -> Known luminous intensity (NEW)
        - LuminousIntensity(value, "unit", "name") -> Known luminous intensity (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.LuminousIntensitySetter':
        """
        Create a setter for this luminous intensity quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            LuminousIntensitySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.LuminousIntensitySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.LuminousIntensitySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this luminous intensity.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this luminous intensity.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MagneticField(FieldQnty):
    """
    Type-safe magnetic field quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MagneticField("variable_name") -> Create unknown magnetic field
    - MagneticField(value, "unit", "variable_name") -> Create known magnetic field
    
    Examples:
    ---------
    >>> unknown = MagneticField("pressure")  # Unknown magnetic field
    >>> known = MagneticField(100, "ampere_per_meter", "inlet_pressure")  # Known magnetic field
    
    Available units: "ampere_per_meter", "lenz", "oersted"
    """

    __slots__ = ()
    _setter_class = field_setter.MagneticFieldSetter
    _dimension = dim.MAGNETIC_FIELD

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize magnetic field quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MagneticField("name") -> Unknown magnetic field
        - MagneticField("name", "unit") -> Unknown magnetic field with unit preference (NEW)
        - MagneticField("name", "unit", value) -> Known magnetic field (NEW)
        - MagneticField(value, "unit", "name") -> Known magnetic field (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MagneticFieldSetter':
        """
        Create a setter for this magnetic field quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MagneticFieldSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MagneticFieldSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MagneticFieldSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this magnetic field.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this magnetic field.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MagneticFlux(FieldQnty):
    """
    Type-safe magnetic flux quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MagneticFlux("variable_name") -> Create unknown magnetic flux
    - MagneticFlux(value, "unit", "variable_name") -> Create known magnetic flux
    
    Examples:
    ---------
    >>> unknown = MagneticFlux("pressure")  # Unknown magnetic flux
    >>> known = MagneticFlux(100, "kapp_line", "inlet_pressure")  # Known magnetic flux
    
    Available units: "kapp_line", "line", "maxwell"
    """

    __slots__ = ()
    _setter_class = field_setter.MagneticFluxSetter
    _dimension = dim.MAGNETIC_FLUX

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize magnetic flux quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MagneticFlux("name") -> Unknown magnetic flux
        - MagneticFlux("name", "unit") -> Unknown magnetic flux with unit preference (NEW)
        - MagneticFlux("name", "unit", value) -> Known magnetic flux (NEW)
        - MagneticFlux(value, "unit", "name") -> Known magnetic flux (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MagneticFluxSetter':
        """
        Create a setter for this magnetic flux quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MagneticFluxSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MagneticFluxSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MagneticFluxSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this magnetic flux.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this magnetic flux.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MagneticInductionFieldStrength(FieldQnty):
    """
    Type-safe magnetic induction field strength quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MagneticInductionFieldStrength("variable_name") -> Create unknown magnetic induction field strength
    - MagneticInductionFieldStrength(value, "unit", "variable_name") -> Create known magnetic induction field strength
    
    Examples:
    ---------
    >>> unknown = MagneticInductionFieldStrength("pressure")  # Unknown magnetic induction field strength
    >>> known = MagneticInductionFieldStrength(100, "gamma", "inlet_pressure")  # Known magnetic induction field strength
    
    Available units: "gamma", "gauss", "line_per_square_centimeter"
    """

    __slots__ = ()
    _setter_class = field_setter.MagneticInductionFieldStrengthSetter
    _dimension = dim.MAGNETIC_INDUCTION_FIELD_STRENGTH

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize magnetic induction field strength quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MagneticInductionFieldStrength("name") -> Unknown magnetic induction field strength
        - MagneticInductionFieldStrength("name", "unit") -> Unknown magnetic induction field strength with unit preference (NEW)
        - MagneticInductionFieldStrength("name", "unit", value) -> Known magnetic induction field strength (NEW)
        - MagneticInductionFieldStrength(value, "unit", "name") -> Known magnetic induction field strength (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MagneticInductionFieldStrengthSetter':
        """
        Create a setter for this magnetic induction field strength quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MagneticInductionFieldStrengthSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MagneticInductionFieldStrengthSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MagneticInductionFieldStrengthSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this magnetic induction field strength.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this magnetic induction field strength.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MagneticMoment(FieldQnty):
    """
    Type-safe magnetic moment quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MagneticMoment("variable_name") -> Create unknown magnetic moment
    - MagneticMoment(value, "unit", "variable_name") -> Create known magnetic moment
    
    Examples:
    ---------
    >>> unknown = MagneticMoment("pressure")  # Unknown magnetic moment
    >>> known = MagneticMoment(100, "bohr_magneton", "inlet_pressure")  # Known magnetic moment
    
    Available units: "bohr_magneton", "joule_per_tesla", "nuclear_magneton"
    """

    __slots__ = ()
    _setter_class = field_setter.MagneticMomentSetter
    _dimension = dim.MAGNETIC_MOMENT

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize magnetic moment quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MagneticMoment("name") -> Unknown magnetic moment
        - MagneticMoment("name", "unit") -> Unknown magnetic moment with unit preference (NEW)
        - MagneticMoment("name", "unit", value) -> Known magnetic moment (NEW)
        - MagneticMoment(value, "unit", "name") -> Known magnetic moment (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MagneticMomentSetter':
        """
        Create a setter for this magnetic moment quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MagneticMomentSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MagneticMomentSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MagneticMomentSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this magnetic moment.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this magnetic moment.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MagneticPermeability(FieldQnty):
    """
    Type-safe magnetic permeability quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MagneticPermeability("variable_name") -> Create unknown magnetic permeability
    - MagneticPermeability(value, "unit", "variable_name") -> Create known magnetic permeability
    
    Examples:
    ---------
    >>> unknown = MagneticPermeability("pressure")  # Unknown magnetic permeability
    >>> known = MagneticPermeability(100, "henrys_per_meter", "inlet_pressure")  # Known magnetic permeability
    
    Available units: "henrys_per_meter", "newton_per_square_ampere"
    """

    __slots__ = ()
    _setter_class = field_setter.MagneticPermeabilitySetter
    _dimension = dim.MAGNETIC_PERMEABILITY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize magnetic permeability quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MagneticPermeability("name") -> Unknown magnetic permeability
        - MagneticPermeability("name", "unit") -> Unknown magnetic permeability with unit preference (NEW)
        - MagneticPermeability("name", "unit", value) -> Known magnetic permeability (NEW)
        - MagneticPermeability(value, "unit", "name") -> Known magnetic permeability (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MagneticPermeabilitySetter':
        """
        Create a setter for this magnetic permeability quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MagneticPermeabilitySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MagneticPermeabilitySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MagneticPermeabilitySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this magnetic permeability.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this magnetic permeability.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MagnetomotiveForce(FieldQnty):
    """
    Type-safe magnetomotive force quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MagnetomotiveForce("variable_name") -> Create unknown magnetomotive force
    - MagnetomotiveForce(value, "unit", "variable_name") -> Create known magnetomotive force
    
    Examples:
    ---------
    >>> unknown = MagnetomotiveForce("pressure")  # Unknown magnetomotive force
    >>> known = MagnetomotiveForce(100, "abampere_turn", "inlet_pressure")  # Known magnetomotive force
    
    Available units: "abampere_turn", "ampere", "ampere_turn"
    """

    __slots__ = ()
    _setter_class = field_setter.MagnetomotiveForceSetter
    _dimension = dim.MAGNETOMOTIVE_FORCE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize magnetomotive force quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MagnetomotiveForce("name") -> Unknown magnetomotive force
        - MagnetomotiveForce("name", "unit") -> Unknown magnetomotive force with unit preference (NEW)
        - MagnetomotiveForce("name", "unit", value) -> Known magnetomotive force (NEW)
        - MagnetomotiveForce(value, "unit", "name") -> Known magnetomotive force (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MagnetomotiveForceSetter':
        """
        Create a setter for this magnetomotive force quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MagnetomotiveForceSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MagnetomotiveForceSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MagnetomotiveForceSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this magnetomotive force.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this magnetomotive force.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Mass(FieldQnty):
    """
    Type-safe mass quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Mass("variable_name") -> Create unknown mass
    - Mass(value, "unit", "variable_name") -> Create known mass
    
    Examples:
    ---------
    >>> unknown = Mass("pressure")  # Unknown mass
    >>> known = Mass(100, "slug", "inlet_pressure")  # Known mass
    
    Available units: "slug", "atomic_mass_unit_12_mathrmc", "carat_metric"
    """

    __slots__ = ()
    _setter_class = field_setter.MassSetter
    _dimension = dim.MASS

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize mass quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Mass("name") -> Unknown mass
        - Mass("name", "unit") -> Unknown mass with unit preference (NEW)
        - Mass("name", "unit", value) -> Known mass (NEW)
        - Mass(value, "unit", "name") -> Known mass (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MassSetter':
        """
        Create a setter for this mass quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MassSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MassSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MassSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this mass.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this mass.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MassDensity(FieldQnty):
    """
    Type-safe mass density quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MassDensity("variable_name") -> Create unknown mass density
    - MassDensity(value, "unit", "variable_name") -> Create known mass density
    
    Examples:
    ---------
    >>> unknown = MassDensity("pressure")  # Unknown mass density
    >>> known = MassDensity(100, "gram_per_cubic_centimeter", "inlet_pressure")  # Known mass density
    
    Available units: "gram_per_cubic_centimeter", "gram_per_cubic_decimeter", "gram_per_cubic_meter"
    """

    __slots__ = ()
    _setter_class = field_setter.MassDensitySetter
    _dimension = dim.MASS_DENSITY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize mass density quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MassDensity("name") -> Unknown mass density
        - MassDensity("name", "unit") -> Unknown mass density with unit preference (NEW)
        - MassDensity("name", "unit", value) -> Known mass density (NEW)
        - MassDensity(value, "unit", "name") -> Known mass density (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MassDensitySetter':
        """
        Create a setter for this mass density quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MassDensitySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MassDensitySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MassDensitySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this mass density.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this mass density.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MassFlowRate(FieldQnty):
    """
    Type-safe mass flow rate quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MassFlowRate("variable_name") -> Create unknown mass flow rate
    - MassFlowRate(value, "unit", "variable_name") -> Create known mass flow rate
    
    Examples:
    ---------
    >>> unknown = MassFlowRate("pressure")  # Unknown mass flow rate
    >>> known = MassFlowRate(100, "kilograms_per_day", "inlet_pressure")  # Known mass flow rate
    
    Available units: "kilograms_per_day", "kilograms_per_hour", "kilograms_per_minute"
    """

    __slots__ = ()
    _setter_class = field_setter.MassFlowRateSetter
    _dimension = dim.MASS_FLOW_RATE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize mass flow rate quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MassFlowRate("name") -> Unknown mass flow rate
        - MassFlowRate("name", "unit") -> Unknown mass flow rate with unit preference (NEW)
        - MassFlowRate("name", "unit", value) -> Known mass flow rate (NEW)
        - MassFlowRate(value, "unit", "name") -> Known mass flow rate (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MassFlowRateSetter':
        """
        Create a setter for this mass flow rate quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MassFlowRateSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MassFlowRateSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MassFlowRateSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this mass flow rate.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this mass flow rate.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MassFlux(FieldQnty):
    """
    Type-safe mass flux quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MassFlux("variable_name") -> Create unknown mass flux
    - MassFlux(value, "unit", "variable_name") -> Create known mass flux
    
    Examples:
    ---------
    >>> unknown = MassFlux("pressure")  # Unknown mass flux
    >>> known = MassFlux(100, "kilogram_per_square_meter_per_day", "inlet_pressure")  # Known mass flux
    
    Available units: "kilogram_per_square_meter_per_day", "kilogram_per_square_meter_per_hour", "kilogram_per_square_meter_per_minute"
    """

    __slots__ = ()
    _setter_class = field_setter.MassFluxSetter
    _dimension = dim.MASS_FLUX

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize mass flux quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MassFlux("name") -> Unknown mass flux
        - MassFlux("name", "unit") -> Unknown mass flux with unit preference (NEW)
        - MassFlux("name", "unit", value) -> Known mass flux (NEW)
        - MassFlux(value, "unit", "name") -> Known mass flux (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MassFluxSetter':
        """
        Create a setter for this mass flux quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MassFluxSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MassFluxSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MassFluxSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this mass flux.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this mass flux.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MassFractionOfI(FieldQnty):
    """
    Type-safe mass fraction of "i" quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MassFractionOfI("variable_name") -> Create unknown mass fraction of "i"
    - MassFractionOfI(value, "unit", "variable_name") -> Create known mass fraction of "i"
    
    Examples:
    ---------
    >>> unknown = MassFractionOfI("pressure")  # Unknown mass fraction of "i"
    >>> known = MassFractionOfI(100, "grains_of_i_per_pound_total", "inlet_pressure")  # Known mass fraction of "i"
    
    Available units: "grains_of_i_per_pound_total", "gram_of_i_per_kilogram_total", "kilogram_of_i_per_kilogram_total"
    """

    __slots__ = ()
    _setter_class = field_setter.MassFractionOfISetter
    _dimension = dim.MASS_FRACTION_OF_I

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize mass fraction of "i" quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MassFractionOfI("name") -> Unknown mass fraction of "i"
        - MassFractionOfI("name", "unit") -> Unknown mass fraction of "i" with unit preference (NEW)
        - MassFractionOfI("name", "unit", value) -> Known mass fraction of "i" (NEW)
        - MassFractionOfI(value, "unit", "name") -> Known mass fraction of "i" (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MassFractionOfISetter':
        """
        Create a setter for this mass fraction of "i" quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MassFractionOfISetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MassFractionOfISetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MassFractionOfISetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this mass fraction of "i".
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this mass fraction of "i".
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MassTransferCoefficient(FieldQnty):
    """
    Type-safe mass transfer coefficient quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MassTransferCoefficient("variable_name") -> Create unknown mass transfer coefficient
    - MassTransferCoefficient(value, "unit", "variable_name") -> Create known mass transfer coefficient
    
    Examples:
    ---------
    >>> unknown = MassTransferCoefficient("pressure")  # Unknown mass transfer coefficient
    >>> known = MassTransferCoefficient(100, "gram_per_square_centimeter_per_second", "inlet_pressure")  # Known mass transfer coefficient
    
    Available units: "gram_per_square_centimeter_per_second", "kilogram_per_square_meter_per_second", "pounds_force_per_cubic_foot_per_hour"
    """

    __slots__ = ()
    _setter_class = field_setter.MassTransferCoefficientSetter
    _dimension = dim.MASS_TRANSFER_COEFFICIENT

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize mass transfer coefficient quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MassTransferCoefficient("name") -> Unknown mass transfer coefficient
        - MassTransferCoefficient("name", "unit") -> Unknown mass transfer coefficient with unit preference (NEW)
        - MassTransferCoefficient("name", "unit", value) -> Known mass transfer coefficient (NEW)
        - MassTransferCoefficient(value, "unit", "name") -> Known mass transfer coefficient (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MassTransferCoefficientSetter':
        """
        Create a setter for this mass transfer coefficient quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MassTransferCoefficientSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MassTransferCoefficientSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MassTransferCoefficientSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this mass transfer coefficient.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this mass transfer coefficient.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MolalityOfSoluteI(FieldQnty):
    """
    Type-safe molality of solute "i" quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MolalityOfSoluteI("variable_name") -> Create unknown molality of solute "i"
    - MolalityOfSoluteI(value, "unit", "variable_name") -> Create known molality of solute "i"
    
    Examples:
    ---------
    >>> unknown = MolalityOfSoluteI("pressure")  # Unknown molality of solute "i"
    >>> known = MolalityOfSoluteI(100, "gram_moles_of_i_per_kilogram", "inlet_pressure")  # Known molality of solute "i"
    
    Available units: "gram_moles_of_i_per_kilogram", "kilogram_mols_of_i_per_kilogram", "kmols_of_i_per_kilogram"
    """

    __slots__ = ()
    _setter_class = field_setter.MolalityOfSoluteISetter
    _dimension = dim.MOLALITY_OF_SOLUTE_I

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize molality of solute "i" quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MolalityOfSoluteI("name") -> Unknown molality of solute "i"
        - MolalityOfSoluteI("name", "unit") -> Unknown molality of solute "i" with unit preference (NEW)
        - MolalityOfSoluteI("name", "unit", value) -> Known molality of solute "i" (NEW)
        - MolalityOfSoluteI(value, "unit", "name") -> Known molality of solute "i" (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MolalityOfSoluteISetter':
        """
        Create a setter for this molality of solute "i" quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MolalityOfSoluteISetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MolalityOfSoluteISetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MolalityOfSoluteISetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this molality of solute "i".
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this molality of solute "i".
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MolarConcentrationByMass(FieldQnty):
    """
    Type-safe molar concentration by mass quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MolarConcentrationByMass("variable_name") -> Create unknown molar concentration by mass
    - MolarConcentrationByMass(value, "unit", "variable_name") -> Create known molar concentration by mass
    
    Examples:
    ---------
    >>> unknown = MolarConcentrationByMass("pressure")  # Unknown molar concentration by mass
    >>> known = MolarConcentrationByMass(100, "gram_mole_or_mole_per_gram", "inlet_pressure")  # Known molar concentration by mass
    
    Available units: "gram_mole_or_mole_per_gram", "gram_mole_or_mole_per_kilogram", "kilogram_mole_or_kmol_per_kilogram"
    """

    __slots__ = ()
    _setter_class = field_setter.MolarConcentrationByMassSetter
    _dimension = dim.MOLAR_CONCENTRATION_BY_MASS

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize molar concentration by mass quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MolarConcentrationByMass("name") -> Unknown molar concentration by mass
        - MolarConcentrationByMass("name", "unit") -> Unknown molar concentration by mass with unit preference (NEW)
        - MolarConcentrationByMass("name", "unit", value) -> Known molar concentration by mass (NEW)
        - MolarConcentrationByMass(value, "unit", "name") -> Known molar concentration by mass (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MolarConcentrationByMassSetter':
        """
        Create a setter for this molar concentration by mass quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MolarConcentrationByMassSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MolarConcentrationByMassSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MolarConcentrationByMassSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this molar concentration by mass.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this molar concentration by mass.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MolarFlowRate(FieldQnty):
    """
    Type-safe molar flow rate quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MolarFlowRate("variable_name") -> Create unknown molar flow rate
    - MolarFlowRate(value, "unit", "variable_name") -> Create known molar flow rate
    
    Examples:
    ---------
    >>> unknown = MolarFlowRate("pressure")  # Unknown molar flow rate
    >>> known = MolarFlowRate(100, "gram_mole_per_day", "inlet_pressure")  # Known molar flow rate
    
    Available units: "gram_mole_per_day", "gram_mole_per_hour", "gram_mole_per_minute"
    """

    __slots__ = ()
    _setter_class = field_setter.MolarFlowRateSetter
    _dimension = dim.MOLAR_FLOW_RATE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize molar flow rate quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MolarFlowRate("name") -> Unknown molar flow rate
        - MolarFlowRate("name", "unit") -> Unknown molar flow rate with unit preference (NEW)
        - MolarFlowRate("name", "unit", value) -> Known molar flow rate (NEW)
        - MolarFlowRate(value, "unit", "name") -> Known molar flow rate (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MolarFlowRateSetter':
        """
        Create a setter for this molar flow rate quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MolarFlowRateSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MolarFlowRateSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MolarFlowRateSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this molar flow rate.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this molar flow rate.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MolarFlux(FieldQnty):
    """
    Type-safe molar flux quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MolarFlux("variable_name") -> Create unknown molar flux
    - MolarFlux(value, "unit", "variable_name") -> Create known molar flux
    
    Examples:
    ---------
    >>> unknown = MolarFlux("pressure")  # Unknown molar flux
    >>> known = MolarFlux(100, "kmol_per_square_meter_per_day", "inlet_pressure")  # Known molar flux
    
    Available units: "kmol_per_square_meter_per_day", "kmol_per_square_meter_per_hour", "kmol_per_square_meter_per_minute"
    """

    __slots__ = ()
    _setter_class = field_setter.MolarFluxSetter
    _dimension = dim.MOLAR_FLUX

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize molar flux quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MolarFlux("name") -> Unknown molar flux
        - MolarFlux("name", "unit") -> Unknown molar flux with unit preference (NEW)
        - MolarFlux("name", "unit", value) -> Known molar flux (NEW)
        - MolarFlux(value, "unit", "name") -> Known molar flux (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MolarFluxSetter':
        """
        Create a setter for this molar flux quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MolarFluxSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MolarFluxSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MolarFluxSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this molar flux.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this molar flux.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MolarHeatCapacity(FieldQnty):
    """
    Type-safe molar heat capacity quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MolarHeatCapacity("variable_name") -> Create unknown molar heat capacity
    - MolarHeatCapacity(value, "unit", "variable_name") -> Create known molar heat capacity
    
    Examples:
    ---------
    >>> unknown = MolarHeatCapacity("pressure")  # Unknown molar heat capacity
    >>> known = MolarHeatCapacity(100, "btu_per_pound_mole_per_degree_fahrenheit_or_degree_rankine", "inlet_pressure")  # Known molar heat capacity
    
    Available units: "btu_per_pound_mole_per_degree_fahrenheit_or_degree_rankine", "calories_per_gram_mole_per_kelvin_or_degree_celsius", "joule_per_gram_mole_per_kelvin_or_degree_celsius"
    """

    __slots__ = ()
    _setter_class = field_setter.MolarHeatCapacitySetter
    _dimension = dim.MOLAR_HEAT_CAPACITY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize molar heat capacity quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MolarHeatCapacity("name") -> Unknown molar heat capacity
        - MolarHeatCapacity("name", "unit") -> Unknown molar heat capacity with unit preference (NEW)
        - MolarHeatCapacity("name", "unit", value) -> Known molar heat capacity (NEW)
        - MolarHeatCapacity(value, "unit", "name") -> Known molar heat capacity (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MolarHeatCapacitySetter':
        """
        Create a setter for this molar heat capacity quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MolarHeatCapacitySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MolarHeatCapacitySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MolarHeatCapacitySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this molar heat capacity.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this molar heat capacity.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MolarityOfI(FieldQnty):
    """
    Type-safe molarity of "i" quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MolarityOfI("variable_name") -> Create unknown molarity of "i"
    - MolarityOfI(value, "unit", "variable_name") -> Create known molarity of "i"
    
    Examples:
    ---------
    >>> unknown = MolarityOfI("pressure")  # Unknown molarity of "i"
    >>> known = MolarityOfI(100, "gram_moles_of_i_per_cubic_meter", "inlet_pressure")  # Known molarity of "i"
    
    Available units: "gram_moles_of_i_per_cubic_meter", "gram_moles_of_i_per_liter", "kilogram_moles_of_i_per_cubic_meter"
    """

    __slots__ = ()
    _setter_class = field_setter.MolarityOfISetter
    _dimension = dim.MOLARITY_OF_I

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize molarity of "i" quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MolarityOfI("name") -> Unknown molarity of "i"
        - MolarityOfI("name", "unit") -> Unknown molarity of "i" with unit preference (NEW)
        - MolarityOfI("name", "unit", value) -> Known molarity of "i" (NEW)
        - MolarityOfI(value, "unit", "name") -> Known molarity of "i" (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MolarityOfISetter':
        """
        Create a setter for this molarity of "i" quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MolarityOfISetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MolarityOfISetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MolarityOfISetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this molarity of "i".
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this molarity of "i".
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MoleFractionOfI(FieldQnty):
    """
    Type-safe mole fraction of "i" quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MoleFractionOfI("variable_name") -> Create unknown mole fraction of "i"
    - MoleFractionOfI(value, "unit", "variable_name") -> Create known mole fraction of "i"
    
    Examples:
    ---------
    >>> unknown = MoleFractionOfI("pressure")  # Unknown mole fraction of "i"
    >>> known = MoleFractionOfI(100, "gram_mole_of_i_per_gram_mole_total", "inlet_pressure")  # Known mole fraction of "i"
    
    Available units: "gram_mole_of_i_per_gram_mole_total", "kilogram_mole_of_i_per_kilogram_mole_total", "kilomole_of_i_per_kilomole_total"
    """

    __slots__ = ()
    _setter_class = field_setter.MoleFractionOfISetter
    _dimension = dim.MOLE_FRACTION_OF_I

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize mole fraction of "i" quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MoleFractionOfI("name") -> Unknown mole fraction of "i"
        - MoleFractionOfI("name", "unit") -> Unknown mole fraction of "i" with unit preference (NEW)
        - MoleFractionOfI("name", "unit", value) -> Known mole fraction of "i" (NEW)
        - MoleFractionOfI(value, "unit", "name") -> Known mole fraction of "i" (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MoleFractionOfISetter':
        """
        Create a setter for this mole fraction of "i" quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MoleFractionOfISetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MoleFractionOfISetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MoleFractionOfISetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this mole fraction of "i".
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this mole fraction of "i".
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MomentOfInertia(FieldQnty):
    """
    Type-safe moment of inertia quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MomentOfInertia("variable_name") -> Create unknown moment of inertia
    - MomentOfInertia(value, "unit", "variable_name") -> Create known moment of inertia
    
    Examples:
    ---------
    >>> unknown = MomentOfInertia("pressure")  # Unknown moment of inertia
    >>> known = MomentOfInertia(100, "gram_force_centimeter_square_second", "inlet_pressure")  # Known moment of inertia
    
    Available units: "gram_force_centimeter_square_second", "gram_square_centimeter", "kilogram_force_centimeter_square_second"
    """

    __slots__ = ()
    _setter_class = field_setter.MomentOfInertiaSetter
    _dimension = dim.MOMENT_OF_INERTIA

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize moment of inertia quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MomentOfInertia("name") -> Unknown moment of inertia
        - MomentOfInertia("name", "unit") -> Unknown moment of inertia with unit preference (NEW)
        - MomentOfInertia("name", "unit", value) -> Known moment of inertia (NEW)
        - MomentOfInertia(value, "unit", "name") -> Known moment of inertia (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MomentOfInertiaSetter':
        """
        Create a setter for this moment of inertia quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MomentOfInertiaSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MomentOfInertiaSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MomentOfInertiaSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this moment of inertia.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this moment of inertia.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MomentumFlowRate(FieldQnty):
    """
    Type-safe momentum flow rate quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MomentumFlowRate("variable_name") -> Create unknown momentum flow rate
    - MomentumFlowRate(value, "unit", "variable_name") -> Create known momentum flow rate
    
    Examples:
    ---------
    >>> unknown = MomentumFlowRate("pressure")  # Unknown momentum flow rate
    >>> known = MomentumFlowRate(100, "foot_pounds_per_square_hour", "inlet_pressure")  # Known momentum flow rate
    
    Available units: "foot_pounds_per_square_hour", "foot_pounds_per_square_minute", "foot_pounds_per_square_second"
    """

    __slots__ = ()
    _setter_class = field_setter.MomentumFlowRateSetter
    _dimension = dim.MOMENTUM_FLOW_RATE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize momentum flow rate quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MomentumFlowRate("name") -> Unknown momentum flow rate
        - MomentumFlowRate("name", "unit") -> Unknown momentum flow rate with unit preference (NEW)
        - MomentumFlowRate("name", "unit", value) -> Known momentum flow rate (NEW)
        - MomentumFlowRate(value, "unit", "name") -> Known momentum flow rate (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MomentumFlowRateSetter':
        """
        Create a setter for this momentum flow rate quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MomentumFlowRateSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MomentumFlowRateSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MomentumFlowRateSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this momentum flow rate.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this momentum flow rate.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class MomentumFlux(FieldQnty):
    """
    Type-safe momentum flux quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - MomentumFlux("variable_name") -> Create unknown momentum flux
    - MomentumFlux(value, "unit", "variable_name") -> Create known momentum flux
    
    Examples:
    ---------
    >>> unknown = MomentumFlux("pressure")  # Unknown momentum flux
    >>> known = MomentumFlux(100, "dyne_per_square_centimeter", "inlet_pressure")  # Known momentum flux
    
    Available units: "dyne_per_square_centimeter", "gram_per_centimeter_per_square_second", "newton_per_square_meter"
    """

    __slots__ = ()
    _setter_class = field_setter.MomentumFluxSetter
    _dimension = dim.MOMENTUM_FLUX

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize momentum flux quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - MomentumFlux("name") -> Unknown momentum flux
        - MomentumFlux("name", "unit") -> Unknown momentum flux with unit preference (NEW)
        - MomentumFlux("name", "unit", value) -> Known momentum flux (NEW)
        - MomentumFlux(value, "unit", "name") -> Known momentum flux (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.MomentumFluxSetter':
        """
        Create a setter for this momentum flux quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            MomentumFluxSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.MomentumFluxSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.MomentumFluxSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this momentum flux.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this momentum flux.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class NormalityOfSolution(FieldQnty):
    """
    Type-safe normality of solution quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - NormalityOfSolution("variable_name") -> Create unknown normality of solution
    - NormalityOfSolution(value, "unit", "variable_name") -> Create known normality of solution
    
    Examples:
    ---------
    >>> unknown = NormalityOfSolution("pressure")  # Unknown normality of solution
    >>> known = NormalityOfSolution(100, "gram_equivalents_per_cubic_meter", "inlet_pressure")  # Known normality of solution
    
    Available units: "gram_equivalents_per_cubic_meter", "gram_equivalents_per_liter", "pound_equivalents_per_cubic_foot"
    """

    __slots__ = ()
    _setter_class = field_setter.NormalityOfSolutionSetter
    _dimension = dim.NORMALITY_OF_SOLUTION

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize normality of solution quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - NormalityOfSolution("name") -> Unknown normality of solution
        - NormalityOfSolution("name", "unit") -> Unknown normality of solution with unit preference (NEW)
        - NormalityOfSolution("name", "unit", value) -> Known normality of solution (NEW)
        - NormalityOfSolution(value, "unit", "name") -> Known normality of solution (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.NormalityOfSolutionSetter':
        """
        Create a setter for this normality of solution quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            NormalityOfSolutionSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.NormalityOfSolutionSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.NormalityOfSolutionSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this normality of solution.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this normality of solution.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ParticleDensity(FieldQnty):
    """
    Type-safe particle density quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ParticleDensity("variable_name") -> Create unknown particle density
    - ParticleDensity(value, "unit", "variable_name") -> Create known particle density
    
    Examples:
    ---------
    >>> unknown = ParticleDensity("pressure")  # Unknown particle density
    >>> known = ParticleDensity(100, "particles_per_cubic_centimeter", "inlet_pressure")  # Known particle density
    
    Available units: "particles_per_cubic_centimeter", "particles_per_cubic_foot", "particles_per_cubic_meter"
    """

    __slots__ = ()
    _setter_class = field_setter.ParticleDensitySetter
    _dimension = dim.PARTICLE_DENSITY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize particle density quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ParticleDensity("name") -> Unknown particle density
        - ParticleDensity("name", "unit") -> Unknown particle density with unit preference (NEW)
        - ParticleDensity("name", "unit", value) -> Known particle density (NEW)
        - ParticleDensity(value, "unit", "name") -> Known particle density (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ParticleDensitySetter':
        """
        Create a setter for this particle density quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ParticleDensitySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ParticleDensitySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ParticleDensitySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this particle density.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this particle density.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Percent(FieldQnty):
    """
    Type-safe percent quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Percent("variable_name") -> Create unknown percent
    - Percent(value, "unit", "variable_name") -> Create known percent
    
    Examples:
    ---------
    >>> unknown = Percent("pressure")  # Unknown percent
    >>> known = Percent(100, "percent", "inlet_pressure")  # Known percent
    
    Available units: "percent", "per_mille", "basis_point"
    """

    __slots__ = ()
    _setter_class = field_setter.PercentSetter
    _dimension = dim.PERCENT

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize percent quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Percent("name") -> Unknown percent
        - Percent("name", "unit") -> Unknown percent with unit preference (NEW)
        - Percent("name", "unit", value) -> Known percent (NEW)
        - Percent(value, "unit", "name") -> Known percent (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.PercentSetter':
        """
        Create a setter for this percent quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            PercentSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.PercentSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.PercentSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this percent.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this percent.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Permeability(FieldQnty):
    """
    Type-safe permeability quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Permeability("variable_name") -> Create unknown permeability
    - Permeability(value, "unit", "variable_name") -> Create known permeability
    
    Examples:
    ---------
    >>> unknown = Permeability("pressure")  # Unknown permeability
    >>> known = Permeability(100, "darcy", "inlet_pressure")  # Known permeability
    
    Available units: "darcy", "square_feet", "square_meters"
    """

    __slots__ = ()
    _setter_class = field_setter.PermeabilitySetter
    _dimension = dim.PERMEABILITY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize permeability quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Permeability("name") -> Unknown permeability
        - Permeability("name", "unit") -> Unknown permeability with unit preference (NEW)
        - Permeability("name", "unit", value) -> Known permeability (NEW)
        - Permeability(value, "unit", "name") -> Known permeability (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.PermeabilitySetter':
        """
        Create a setter for this permeability quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            PermeabilitySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.PermeabilitySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.PermeabilitySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this permeability.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this permeability.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class PhotonEmissionRate(FieldQnty):
    """
    Type-safe photon emission rate quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - PhotonEmissionRate("variable_name") -> Create unknown photon emission rate
    - PhotonEmissionRate(value, "unit", "variable_name") -> Create known photon emission rate
    
    Examples:
    ---------
    >>> unknown = PhotonEmissionRate("pressure")  # Unknown photon emission rate
    >>> known = PhotonEmissionRate(100, "rayleigh", "inlet_pressure")  # Known photon emission rate
    
    Available units: "rayleigh", "reciprocal_square_meter_second"
    """

    __slots__ = ()
    _setter_class = field_setter.PhotonEmissionRateSetter
    _dimension = dim.PHOTON_EMISSION_RATE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize photon emission rate quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - PhotonEmissionRate("name") -> Unknown photon emission rate
        - PhotonEmissionRate("name", "unit") -> Unknown photon emission rate with unit preference (NEW)
        - PhotonEmissionRate("name", "unit", value) -> Known photon emission rate (NEW)
        - PhotonEmissionRate(value, "unit", "name") -> Known photon emission rate (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.PhotonEmissionRateSetter':
        """
        Create a setter for this photon emission rate quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            PhotonEmissionRateSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.PhotonEmissionRateSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.PhotonEmissionRateSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this photon emission rate.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this photon emission rate.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class PowerPerUnitMass(FieldQnty):
    """
    Type-safe power per unit mass or specific power quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - PowerPerUnitMass("variable_name") -> Create unknown power per unit mass or specific power
    - PowerPerUnitMass(value, "unit", "variable_name") -> Create known power per unit mass or specific power
    
    Examples:
    ---------
    >>> unknown = PowerPerUnitMass("pressure")  # Unknown power per unit mass or specific power
    >>> known = PowerPerUnitMass(100, "british_thermal_unit_per_hour_per_pound_mass", "inlet_pressure")  # Known power per unit mass or specific power
    
    Available units: "british_thermal_unit_per_hour_per_pound_mass", "calorie_per_second_per_gram", "kilocalorie_per_hour_per_kilogram"
    """

    __slots__ = ()
    _setter_class = field_setter.PowerPerUnitMassSetter
    _dimension = dim.POWER_PER_UNIT_MASS

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize power per unit mass or specific power quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - PowerPerUnitMass("name") -> Unknown power per unit mass or specific power
        - PowerPerUnitMass("name", "unit") -> Unknown power per unit mass or specific power with unit preference (NEW)
        - PowerPerUnitMass("name", "unit", value) -> Known power per unit mass or specific power (NEW)
        - PowerPerUnitMass(value, "unit", "name") -> Known power per unit mass or specific power (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.PowerPerUnitMassSetter':
        """
        Create a setter for this power per unit mass or specific power quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            PowerPerUnitMassSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.PowerPerUnitMassSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.PowerPerUnitMassSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this power per unit mass or specific power.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this power per unit mass or specific power.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class PowerPerUnitVolume(FieldQnty):
    """
    Type-safe power per unit volume or power density quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - PowerPerUnitVolume("variable_name") -> Create unknown power per unit volume or power density
    - PowerPerUnitVolume(value, "unit", "variable_name") -> Create known power per unit volume or power density
    
    Examples:
    ---------
    >>> unknown = PowerPerUnitVolume("pressure")  # Unknown power per unit volume or power density
    >>> known = PowerPerUnitVolume(100, "british_thermal_unit_per_hour_per_cubic_foot", "inlet_pressure")  # Known power per unit volume or power density
    
    Available units: "british_thermal_unit_per_hour_per_cubic_foot", "calorie_per_second_per_cubic_centimeter", "chu_per_hour_per_cubic_foot"
    """

    __slots__ = ()
    _setter_class = field_setter.PowerPerUnitVolumeSetter
    _dimension = dim.POWER_PER_UNIT_VOLUME

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize power per unit volume or power density quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - PowerPerUnitVolume("name") -> Unknown power per unit volume or power density
        - PowerPerUnitVolume("name", "unit") -> Unknown power per unit volume or power density with unit preference (NEW)
        - PowerPerUnitVolume("name", "unit", value) -> Known power per unit volume or power density (NEW)
        - PowerPerUnitVolume(value, "unit", "name") -> Known power per unit volume or power density (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.PowerPerUnitVolumeSetter':
        """
        Create a setter for this power per unit volume or power density quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            PowerPerUnitVolumeSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.PowerPerUnitVolumeSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.PowerPerUnitVolumeSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this power per unit volume or power density.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this power per unit volume or power density.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class PowerThermalDuty(FieldQnty):
    """
    Type-safe power, thermal duty quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - PowerThermalDuty("variable_name") -> Create unknown power, thermal duty
    - PowerThermalDuty(value, "unit", "variable_name") -> Create known power, thermal duty
    
    Examples:
    ---------
    >>> unknown = PowerThermalDuty("pressure")  # Unknown power, thermal duty
    >>> known = PowerThermalDuty(100, "abwatt_emu_of_power", "inlet_pressure")  # Known power, thermal duty
    
    Available units: "abwatt_emu_of_power", "boiler_horsepower", "british_thermal_unit_mean"
    """

    __slots__ = ()
    _setter_class = field_setter.PowerThermalDutySetter
    _dimension = dim.POWER_THERMAL_DUTY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize power, thermal duty quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - PowerThermalDuty("name") -> Unknown power, thermal duty
        - PowerThermalDuty("name", "unit") -> Unknown power, thermal duty with unit preference (NEW)
        - PowerThermalDuty("name", "unit", value) -> Known power, thermal duty (NEW)
        - PowerThermalDuty(value, "unit", "name") -> Known power, thermal duty (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.PowerThermalDutySetter':
        """
        Create a setter for this power, thermal duty quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            PowerThermalDutySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.PowerThermalDutySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.PowerThermalDutySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this power, thermal duty.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this power, thermal duty.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Pressure(FieldQnty):
    """
    Type-safe pressure quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Pressure("variable_name") -> Create unknown pressure
    - Pressure(value, "unit", "variable_name") -> Create known pressure
    
    Examples:
    ---------
    >>> unknown = Pressure("pressure")  # Unknown pressure
    >>> known = Pressure(100, "atmosphere_standard", "inlet_pressure")  # Known pressure
    
    Available units: "atmosphere_standard", "bar", "barye"
    """

    __slots__ = ()
    _setter_class = field_setter.PressureSetter
    _dimension = dim.PRESSURE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize pressure quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Pressure("name") -> Unknown pressure
        - Pressure("name", "unit") -> Unknown pressure with unit preference (NEW)
        - Pressure("name", "unit", value) -> Known pressure (NEW)
        - Pressure(value, "unit", "name") -> Known pressure (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.PressureSetter':
        """
        Create a setter for this pressure quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            PressureSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.PressureSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.PressureSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this pressure.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this pressure.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class RadiationDoseEquivalent(FieldQnty):
    """
    Type-safe radiation dose equivalent quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - RadiationDoseEquivalent("variable_name") -> Create unknown radiation dose equivalent
    - RadiationDoseEquivalent(value, "unit", "variable_name") -> Create known radiation dose equivalent
    
    Examples:
    ---------
    >>> unknown = RadiationDoseEquivalent("pressure")  # Unknown radiation dose equivalent
    >>> known = RadiationDoseEquivalent(100, "rem", "inlet_pressure")  # Known radiation dose equivalent
    
    Available units: "rem", "sievert", "millisievert"
    """

    __slots__ = ()
    _setter_class = field_setter.RadiationDoseEquivalentSetter
    _dimension = dim.RADIATION_DOSE_EQUIVALENT

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize radiation dose equivalent quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - RadiationDoseEquivalent("name") -> Unknown radiation dose equivalent
        - RadiationDoseEquivalent("name", "unit") -> Unknown radiation dose equivalent with unit preference (NEW)
        - RadiationDoseEquivalent("name", "unit", value) -> Known radiation dose equivalent (NEW)
        - RadiationDoseEquivalent(value, "unit", "name") -> Known radiation dose equivalent (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.RadiationDoseEquivalentSetter':
        """
        Create a setter for this radiation dose equivalent quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            RadiationDoseEquivalentSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.RadiationDoseEquivalentSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.RadiationDoseEquivalentSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this radiation dose equivalent.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this radiation dose equivalent.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class RadiationExposure(FieldQnty):
    """
    Type-safe radiation exposure quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - RadiationExposure("variable_name") -> Create unknown radiation exposure
    - RadiationExposure(value, "unit", "variable_name") -> Create known radiation exposure
    
    Examples:
    ---------
    >>> unknown = RadiationExposure("pressure")  # Unknown radiation exposure
    >>> known = RadiationExposure(100, "coulomb_per_kilogram", "inlet_pressure")  # Known radiation exposure
    
    Available units: "coulomb_per_kilogram", "d_unit", "pastille_dose_b_unit"
    """

    __slots__ = ()
    _setter_class = field_setter.RadiationExposureSetter
    _dimension = dim.RADIATION_EXPOSURE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize radiation exposure quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - RadiationExposure("name") -> Unknown radiation exposure
        - RadiationExposure("name", "unit") -> Unknown radiation exposure with unit preference (NEW)
        - RadiationExposure("name", "unit", value) -> Known radiation exposure (NEW)
        - RadiationExposure(value, "unit", "name") -> Known radiation exposure (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.RadiationExposureSetter':
        """
        Create a setter for this radiation exposure quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            RadiationExposureSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.RadiationExposureSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.RadiationExposureSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this radiation exposure.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this radiation exposure.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Radioactivity(FieldQnty):
    """
    Type-safe radioactivity quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Radioactivity("variable_name") -> Create unknown radioactivity
    - Radioactivity(value, "unit", "variable_name") -> Create known radioactivity
    
    Examples:
    ---------
    >>> unknown = Radioactivity("pressure")  # Unknown radioactivity
    >>> known = Radioactivity(100, "becquerel", "inlet_pressure")  # Known radioactivity
    
    Available units: "becquerel", "curie", "mache_unit"
    """

    __slots__ = ()
    _setter_class = field_setter.RadioactivitySetter
    _dimension = dim.RADIOACTIVITY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize radioactivity quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Radioactivity("name") -> Unknown radioactivity
        - Radioactivity("name", "unit") -> Unknown radioactivity with unit preference (NEW)
        - Radioactivity("name", "unit", value) -> Known radioactivity (NEW)
        - Radioactivity(value, "unit", "name") -> Known radioactivity (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.RadioactivitySetter':
        """
        Create a setter for this radioactivity quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            RadioactivitySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.RadioactivitySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.RadioactivitySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this radioactivity.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this radioactivity.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class SecondMomentOfArea(FieldQnty):
    """
    Type-safe second moment of area quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - SecondMomentOfArea("variable_name") -> Create unknown second moment of area
    - SecondMomentOfArea(value, "unit", "variable_name") -> Create known second moment of area
    
    Examples:
    ---------
    >>> unknown = SecondMomentOfArea("pressure")  # Unknown second moment of area
    >>> known = SecondMomentOfArea(100, "inch_quadrupled", "inlet_pressure")  # Known second moment of area
    
    Available units: "inch_quadrupled", "centimeter_quadrupled", "foot_quadrupled"
    """

    __slots__ = ()
    _setter_class = field_setter.SecondMomentOfAreaSetter
    _dimension = dim.SECOND_MOMENT_OF_AREA

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize second moment of area quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - SecondMomentOfArea("name") -> Unknown second moment of area
        - SecondMomentOfArea("name", "unit") -> Unknown second moment of area with unit preference (NEW)
        - SecondMomentOfArea("name", "unit", value) -> Known second moment of area (NEW)
        - SecondMomentOfArea(value, "unit", "name") -> Known second moment of area (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.SecondMomentOfAreaSetter':
        """
        Create a setter for this second moment of area quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            SecondMomentOfAreaSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.SecondMomentOfAreaSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.SecondMomentOfAreaSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this second moment of area.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this second moment of area.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class SecondRadiationConstantPlanck(FieldQnty):
    """
    Type-safe second radiation constant (planck) quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - SecondRadiationConstantPlanck("variable_name") -> Create unknown second radiation constant (planck)
    - SecondRadiationConstantPlanck(value, "unit", "variable_name") -> Create known second radiation constant (planck)
    
    Examples:
    ---------
    >>> unknown = SecondRadiationConstantPlanck("pressure")  # Unknown second radiation constant (planck)
    >>> known = SecondRadiationConstantPlanck(100, "meter_kelvin", "inlet_pressure")  # Known second radiation constant (planck)
    
    Available units: "meter_kelvin"
    """

    __slots__ = ()
    _setter_class = field_setter.SecondRadiationConstantPlanckSetter
    _dimension = dim.SECOND_RADIATION_CONSTANT_PLANCK

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize second radiation constant (planck) quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - SecondRadiationConstantPlanck("name") -> Unknown second radiation constant (planck)
        - SecondRadiationConstantPlanck("name", "unit") -> Unknown second radiation constant (planck) with unit preference (NEW)
        - SecondRadiationConstantPlanck("name", "unit", value) -> Known second radiation constant (planck) (NEW)
        - SecondRadiationConstantPlanck(value, "unit", "name") -> Known second radiation constant (planck) (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.SecondRadiationConstantPlanckSetter':
        """
        Create a setter for this second radiation constant (planck) quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            SecondRadiationConstantPlanckSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.SecondRadiationConstantPlanckSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.SecondRadiationConstantPlanckSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this second radiation constant (planck).
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this second radiation constant (planck).
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class SpecificEnthalpy(FieldQnty):
    """
    Type-safe specific enthalpy quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - SpecificEnthalpy("variable_name") -> Create unknown specific enthalpy
    - SpecificEnthalpy(value, "unit", "variable_name") -> Create known specific enthalpy
    
    Examples:
    ---------
    >>> unknown = SpecificEnthalpy("pressure")  # Unknown specific enthalpy
    >>> known = SpecificEnthalpy(100, "british_thermal_unit_mean", "inlet_pressure")  # Known specific enthalpy
    
    Available units: "british_thermal_unit_mean", "british_thermal_unit_per_pound", "calorie_per_gram"
    """

    __slots__ = ()
    _setter_class = field_setter.SpecificEnthalpySetter
    _dimension = dim.SPECIFIC_ENTHALPY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize specific enthalpy quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - SpecificEnthalpy("name") -> Unknown specific enthalpy
        - SpecificEnthalpy("name", "unit") -> Unknown specific enthalpy with unit preference (NEW)
        - SpecificEnthalpy("name", "unit", value) -> Known specific enthalpy (NEW)
        - SpecificEnthalpy(value, "unit", "name") -> Known specific enthalpy (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.SpecificEnthalpySetter':
        """
        Create a setter for this specific enthalpy quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            SpecificEnthalpySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.SpecificEnthalpySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.SpecificEnthalpySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this specific enthalpy.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this specific enthalpy.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class SpecificGravity(FieldQnty):
    """
    Type-safe specific gravity quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - SpecificGravity("variable_name") -> Create unknown specific gravity
    - SpecificGravity(value, "unit", "variable_name") -> Create known specific gravity
    
    Examples:
    ---------
    >>> unknown = SpecificGravity("pressure")  # Unknown specific gravity
    >>> known = SpecificGravity(100, "dimensionless", "inlet_pressure")  # Known specific gravity
    
    Available units: "dimensionless"
    """

    __slots__ = ()
    _setter_class = field_setter.SpecificGravitySetter
    _dimension = dim.SPECIFIC_GRAVITY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize specific gravity quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - SpecificGravity("name") -> Unknown specific gravity
        - SpecificGravity("name", "unit") -> Unknown specific gravity with unit preference (NEW)
        - SpecificGravity("name", "unit", value) -> Known specific gravity (NEW)
        - SpecificGravity(value, "unit", "name") -> Known specific gravity (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.SpecificGravitySetter':
        """
        Create a setter for this specific gravity quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            SpecificGravitySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.SpecificGravitySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.SpecificGravitySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this specific gravity.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this specific gravity.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class SpecificHeatCapacityConstantPressure(FieldQnty):
    """
    Type-safe specific heat capacity (constant pressure) quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - SpecificHeatCapacityConstantPressure("variable_name") -> Create unknown specific heat capacity (constant pressure)
    - SpecificHeatCapacityConstantPressure(value, "unit", "variable_name") -> Create known specific heat capacity (constant pressure)
    
    Examples:
    ---------
    >>> unknown = SpecificHeatCapacityConstantPressure("pressure")  # Unknown specific heat capacity (constant pressure)
    >>> known = SpecificHeatCapacityConstantPressure(100, "btu_per_pound_per_degree_fahrenheit_or_degree_rankine", "inlet_pressure")  # Known specific heat capacity (constant pressure)
    
    Available units: "btu_per_pound_per_degree_fahrenheit_or_degree_rankine", "calories_per_gram_per_kelvin_or_degree_celsius", "joules_per_kilogram_per_kelvin_or_degree_celsius"
    """

    __slots__ = ()
    _setter_class = field_setter.SpecificHeatCapacityConstantPressureSetter
    _dimension = dim.SPECIFIC_HEAT_CAPACITY_CONSTANT_PRESSURE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize specific heat capacity (constant pressure) quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - SpecificHeatCapacityConstantPressure("name") -> Unknown specific heat capacity (constant pressure)
        - SpecificHeatCapacityConstantPressure("name", "unit") -> Unknown specific heat capacity (constant pressure) with unit preference (NEW)
        - SpecificHeatCapacityConstantPressure("name", "unit", value) -> Known specific heat capacity (constant pressure) (NEW)
        - SpecificHeatCapacityConstantPressure(value, "unit", "name") -> Known specific heat capacity (constant pressure) (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.SpecificHeatCapacityConstantPressureSetter':
        """
        Create a setter for this specific heat capacity (constant pressure) quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            SpecificHeatCapacityConstantPressureSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.SpecificHeatCapacityConstantPressureSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.SpecificHeatCapacityConstantPressureSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this specific heat capacity (constant pressure).
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this specific heat capacity (constant pressure).
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class SpecificLength(FieldQnty):
    """
    Type-safe specific length quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - SpecificLength("variable_name") -> Create unknown specific length
    - SpecificLength(value, "unit", "variable_name") -> Create known specific length
    
    Examples:
    ---------
    >>> unknown = SpecificLength("pressure")  # Unknown specific length
    >>> known = SpecificLength(100, "centimeter_per_gram", "inlet_pressure")  # Known specific length
    
    Available units: "centimeter_per_gram", "cotton_count", "ft_per_pound"
    """

    __slots__ = ()
    _setter_class = field_setter.SpecificLengthSetter
    _dimension = dim.SPECIFIC_LENGTH

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize specific length quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - SpecificLength("name") -> Unknown specific length
        - SpecificLength("name", "unit") -> Unknown specific length with unit preference (NEW)
        - SpecificLength("name", "unit", value) -> Known specific length (NEW)
        - SpecificLength(value, "unit", "name") -> Known specific length (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.SpecificLengthSetter':
        """
        Create a setter for this specific length quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            SpecificLengthSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.SpecificLengthSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.SpecificLengthSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this specific length.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this specific length.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class SpecificSurface(FieldQnty):
    """
    Type-safe specific surface quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - SpecificSurface("variable_name") -> Create unknown specific surface
    - SpecificSurface(value, "unit", "variable_name") -> Create known specific surface
    
    Examples:
    ---------
    >>> unknown = SpecificSurface("pressure")  # Unknown specific surface
    >>> known = SpecificSurface(100, "square_centimeter_per_gram", "inlet_pressure")  # Known specific surface
    
    Available units: "square_centimeter_per_gram", "square_foot_per_kilogram", "square_foot_per_pound"
    """

    __slots__ = ()
    _setter_class = field_setter.SpecificSurfaceSetter
    _dimension = dim.SPECIFIC_SURFACE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize specific surface quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - SpecificSurface("name") -> Unknown specific surface
        - SpecificSurface("name", "unit") -> Unknown specific surface with unit preference (NEW)
        - SpecificSurface("name", "unit", value) -> Known specific surface (NEW)
        - SpecificSurface(value, "unit", "name") -> Known specific surface (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.SpecificSurfaceSetter':
        """
        Create a setter for this specific surface quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            SpecificSurfaceSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.SpecificSurfaceSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.SpecificSurfaceSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this specific surface.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this specific surface.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class SpecificVolume(FieldQnty):
    """
    Type-safe specific volume quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - SpecificVolume("variable_name") -> Create unknown specific volume
    - SpecificVolume(value, "unit", "variable_name") -> Create known specific volume
    
    Examples:
    ---------
    >>> unknown = SpecificVolume("pressure")  # Unknown specific volume
    >>> known = SpecificVolume(100, "cubic_centimeter_per_gram", "inlet_pressure")  # Known specific volume
    
    Available units: "cubic_centimeter_per_gram", "cubic_foot_per_kilogram", "cubic_foot_per_pound"
    """

    __slots__ = ()
    _setter_class = field_setter.SpecificVolumeSetter
    _dimension = dim.SPECIFIC_VOLUME

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize specific volume quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - SpecificVolume("name") -> Unknown specific volume
        - SpecificVolume("name", "unit") -> Unknown specific volume with unit preference (NEW)
        - SpecificVolume("name", "unit", value) -> Known specific volume (NEW)
        - SpecificVolume(value, "unit", "name") -> Known specific volume (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.SpecificVolumeSetter':
        """
        Create a setter for this specific volume quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            SpecificVolumeSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.SpecificVolumeSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.SpecificVolumeSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this specific volume.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this specific volume.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Stress(FieldQnty):
    """
    Type-safe stress quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Stress("variable_name") -> Create unknown stress
    - Stress(value, "unit", "variable_name") -> Create known stress
    
    Examples:
    ---------
    >>> unknown = Stress("pressure")  # Unknown stress
    >>> known = Stress(100, "dyne_per_square_centimeter", "inlet_pressure")  # Known stress
    
    Available units: "dyne_per_square_centimeter", "gigapascal", "hectopascal"
    """

    __slots__ = ()
    _setter_class = field_setter.StressSetter
    _dimension = dim.STRESS

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize stress quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Stress("name") -> Unknown stress
        - Stress("name", "unit") -> Unknown stress with unit preference (NEW)
        - Stress("name", "unit", value) -> Known stress (NEW)
        - Stress(value, "unit", "name") -> Known stress (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.StressSetter':
        """
        Create a setter for this stress quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            StressSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.StressSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.StressSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this stress.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this stress.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class SurfaceMassDensity(FieldQnty):
    """
    Type-safe surface mass density quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - SurfaceMassDensity("variable_name") -> Create unknown surface mass density
    - SurfaceMassDensity(value, "unit", "variable_name") -> Create known surface mass density
    
    Examples:
    ---------
    >>> unknown = SurfaceMassDensity("pressure")  # Unknown surface mass density
    >>> known = SurfaceMassDensity(100, "gram_per_square_centimeter", "inlet_pressure")  # Known surface mass density
    
    Available units: "gram_per_square_centimeter", "gram_per_square_meter", "kilogram_per_square_meter"
    """

    __slots__ = ()
    _setter_class = field_setter.SurfaceMassDensitySetter
    _dimension = dim.SURFACE_MASS_DENSITY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize surface mass density quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - SurfaceMassDensity("name") -> Unknown surface mass density
        - SurfaceMassDensity("name", "unit") -> Unknown surface mass density with unit preference (NEW)
        - SurfaceMassDensity("name", "unit", value) -> Known surface mass density (NEW)
        - SurfaceMassDensity(value, "unit", "name") -> Known surface mass density (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.SurfaceMassDensitySetter':
        """
        Create a setter for this surface mass density quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            SurfaceMassDensitySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.SurfaceMassDensitySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.SurfaceMassDensitySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this surface mass density.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this surface mass density.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class SurfaceTension(FieldQnty):
    """
    Type-safe surface tension quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - SurfaceTension("variable_name") -> Create unknown surface tension
    - SurfaceTension(value, "unit", "variable_name") -> Create known surface tension
    
    Examples:
    ---------
    >>> unknown = SurfaceTension("pressure")  # Unknown surface tension
    >>> known = SurfaceTension(100, "dyne_per_centimeter", "inlet_pressure")  # Known surface tension
    
    Available units: "dyne_per_centimeter", "gram_force_per_centimeter", "newton_per_meter"
    """

    __slots__ = ()
    _setter_class = field_setter.SurfaceTensionSetter
    _dimension = dim.SURFACE_TENSION

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize surface tension quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - SurfaceTension("name") -> Unknown surface tension
        - SurfaceTension("name", "unit") -> Unknown surface tension with unit preference (NEW)
        - SurfaceTension("name", "unit", value) -> Known surface tension (NEW)
        - SurfaceTension(value, "unit", "name") -> Known surface tension (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.SurfaceTensionSetter':
        """
        Create a setter for this surface tension quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            SurfaceTensionSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.SurfaceTensionSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.SurfaceTensionSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this surface tension.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this surface tension.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Temperature(FieldQnty):
    """
    Type-safe temperature quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Temperature("variable_name") -> Create unknown temperature
    - Temperature(value, "unit", "variable_name") -> Create known temperature
    
    Examples:
    ---------
    >>> unknown = Temperature("pressure")  # Unknown temperature
    >>> known = Temperature(100, "degree_celsius_unit_size", "inlet_pressure")  # Known temperature
    
    Available units: "degree_celsius_unit_size", "degree_fahrenheit_unit_size", "degree_r_aumur_unit_size"
    """

    __slots__ = ()
    _setter_class = field_setter.TemperatureSetter
    _dimension = dim.TEMPERATURE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize temperature quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Temperature("name") -> Unknown temperature
        - Temperature("name", "unit") -> Unknown temperature with unit preference (NEW)
        - Temperature("name", "unit", value) -> Known temperature (NEW)
        - Temperature(value, "unit", "name") -> Known temperature (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.TemperatureSetter':
        """
        Create a setter for this temperature quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            TemperatureSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.TemperatureSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.TemperatureSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this temperature.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this temperature.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ThermalConductivity(FieldQnty):
    """
    Type-safe thermal conductivity quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ThermalConductivity("variable_name") -> Create unknown thermal conductivity
    - ThermalConductivity(value, "unit", "variable_name") -> Create known thermal conductivity
    
    Examples:
    ---------
    >>> unknown = ThermalConductivity("pressure")  # Unknown thermal conductivity
    >>> known = ThermalConductivity(100, "btu_it", "inlet_pressure")  # Known thermal conductivity
    
    Available units: "btu_it", "btu_therm", "btu_therm"
    """

    __slots__ = ()
    _setter_class = field_setter.ThermalConductivitySetter
    _dimension = dim.THERMAL_CONDUCTIVITY

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize thermal conductivity quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ThermalConductivity("name") -> Unknown thermal conductivity
        - ThermalConductivity("name", "unit") -> Unknown thermal conductivity with unit preference (NEW)
        - ThermalConductivity("name", "unit", value) -> Known thermal conductivity (NEW)
        - ThermalConductivity(value, "unit", "name") -> Known thermal conductivity (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ThermalConductivitySetter':
        """
        Create a setter for this thermal conductivity quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ThermalConductivitySetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ThermalConductivitySetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ThermalConductivitySetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this thermal conductivity.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this thermal conductivity.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Time(FieldQnty):
    """
    Type-safe time quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Time("variable_name") -> Create unknown time
    - Time(value, "unit", "variable_name") -> Create known time
    
    Examples:
    ---------
    >>> unknown = Time("pressure")  # Unknown time
    >>> known = Time(100, "blink", "inlet_pressure")  # Known time
    
    Available units: "blink", "century", "chronon_or_tempon"
    """

    __slots__ = ()
    _setter_class = field_setter.TimeSetter
    _dimension = dim.TIME

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize time quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Time("name") -> Unknown time
        - Time("name", "unit") -> Unknown time with unit preference (NEW)
        - Time("name", "unit", value) -> Known time (NEW)
        - Time(value, "unit", "name") -> Known time (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.TimeSetter':
        """
        Create a setter for this time quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            TimeSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.TimeSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.TimeSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this time.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this time.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Torque(FieldQnty):
    """
    Type-safe torque quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Torque("variable_name") -> Create unknown torque
    - Torque(value, "unit", "variable_name") -> Create known torque
    
    Examples:
    ---------
    >>> unknown = Torque("pressure")  # Unknown torque
    >>> known = Torque(100, "centimeter_kilogram_force", "inlet_pressure")  # Known torque
    
    Available units: "centimeter_kilogram_force", "dyne_centimeter", "foot_kilogram_force"
    """

    __slots__ = ()
    _setter_class = field_setter.TorqueSetter
    _dimension = dim.TORQUE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize torque quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Torque("name") -> Unknown torque
        - Torque("name", "unit") -> Unknown torque with unit preference (NEW)
        - Torque("name", "unit", value) -> Known torque (NEW)
        - Torque(value, "unit", "name") -> Known torque (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.TorqueSetter':
        """
        Create a setter for this torque quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            TorqueSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.TorqueSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.TorqueSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this torque.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this torque.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class TurbulenceEnergyDissipationRate(FieldQnty):
    """
    Type-safe turbulence energy dissipation rate quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - TurbulenceEnergyDissipationRate("variable_name") -> Create unknown turbulence energy dissipation rate
    - TurbulenceEnergyDissipationRate(value, "unit", "variable_name") -> Create known turbulence energy dissipation rate
    
    Examples:
    ---------
    >>> unknown = TurbulenceEnergyDissipationRate("pressure")  # Unknown turbulence energy dissipation rate
    >>> known = TurbulenceEnergyDissipationRate(100, "square_foot_per_cubic_second", "inlet_pressure")  # Known turbulence energy dissipation rate
    
    Available units: "square_foot_per_cubic_second", "square_meter_per_cubic_second"
    """

    __slots__ = ()
    _setter_class = field_setter.TurbulenceEnergyDissipationRateSetter
    _dimension = dim.TURBULENCE_ENERGY_DISSIPATION_RATE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize turbulence energy dissipation rate quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - TurbulenceEnergyDissipationRate("name") -> Unknown turbulence energy dissipation rate
        - TurbulenceEnergyDissipationRate("name", "unit") -> Unknown turbulence energy dissipation rate with unit preference (NEW)
        - TurbulenceEnergyDissipationRate("name", "unit", value) -> Known turbulence energy dissipation rate (NEW)
        - TurbulenceEnergyDissipationRate(value, "unit", "name") -> Known turbulence energy dissipation rate (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.TurbulenceEnergyDissipationRateSetter':
        """
        Create a setter for this turbulence energy dissipation rate quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            TurbulenceEnergyDissipationRateSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.TurbulenceEnergyDissipationRateSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.TurbulenceEnergyDissipationRateSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this turbulence energy dissipation rate.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this turbulence energy dissipation rate.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class VelocityAngular(FieldQnty):
    """
    Type-safe velocity, angular quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - VelocityAngular("variable_name") -> Create unknown velocity, angular
    - VelocityAngular(value, "unit", "variable_name") -> Create known velocity, angular
    
    Examples:
    ---------
    >>> unknown = VelocityAngular("pressure")  # Unknown velocity, angular
    >>> known = VelocityAngular(100, "degree_per_minute", "inlet_pressure")  # Known velocity, angular
    
    Available units: "degree_per_minute", "degree_per_second", "grade_per_minute"
    """

    __slots__ = ()
    _setter_class = field_setter.VelocityAngularSetter
    _dimension = dim.VELOCITY_ANGULAR

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize velocity, angular quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - VelocityAngular("name") -> Unknown velocity, angular
        - VelocityAngular("name", "unit") -> Unknown velocity, angular with unit preference (NEW)
        - VelocityAngular("name", "unit", value) -> Known velocity, angular (NEW)
        - VelocityAngular(value, "unit", "name") -> Known velocity, angular (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.VelocityAngularSetter':
        """
        Create a setter for this velocity, angular quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            VelocityAngularSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.VelocityAngularSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.VelocityAngularSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this velocity, angular.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this velocity, angular.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class VelocityLinear(FieldQnty):
    """
    Type-safe velocity, linear quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - VelocityLinear("variable_name") -> Create unknown velocity, linear
    - VelocityLinear(value, "unit", "variable_name") -> Create known velocity, linear
    
    Examples:
    ---------
    >>> unknown = VelocityLinear("pressure")  # Unknown velocity, linear
    >>> known = VelocityLinear(100, "foot_per_hour", "inlet_pressure")  # Known velocity, linear
    
    Available units: "foot_per_hour", "foot_per_minute", "foot_per_second"
    """

    __slots__ = ()
    _setter_class = field_setter.VelocityLinearSetter
    _dimension = dim.VELOCITY_LINEAR

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize velocity, linear quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - VelocityLinear("name") -> Unknown velocity, linear
        - VelocityLinear("name", "unit") -> Unknown velocity, linear with unit preference (NEW)
        - VelocityLinear("name", "unit", value) -> Known velocity, linear (NEW)
        - VelocityLinear(value, "unit", "name") -> Known velocity, linear (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.VelocityLinearSetter':
        """
        Create a setter for this velocity, linear quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            VelocityLinearSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.VelocityLinearSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.VelocityLinearSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this velocity, linear.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this velocity, linear.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ViscosityDynamic(FieldQnty):
    """
    Type-safe viscosity, dynamic quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ViscosityDynamic("variable_name") -> Create unknown viscosity, dynamic
    - ViscosityDynamic(value, "unit", "variable_name") -> Create known viscosity, dynamic
    
    Examples:
    ---------
    >>> unknown = ViscosityDynamic("pressure")  # Unknown viscosity, dynamic
    >>> known = ViscosityDynamic(100, "centipoise", "inlet_pressure")  # Known viscosity, dynamic
    
    Available units: "centipoise", "dyne_second_per_square_centimeter", "kilopound_second_per_square_meter"
    """

    __slots__ = ()
    _setter_class = field_setter.ViscosityDynamicSetter
    _dimension = dim.VISCOSITY_DYNAMIC

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize viscosity, dynamic quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ViscosityDynamic("name") -> Unknown viscosity, dynamic
        - ViscosityDynamic("name", "unit") -> Unknown viscosity, dynamic with unit preference (NEW)
        - ViscosityDynamic("name", "unit", value) -> Known viscosity, dynamic (NEW)
        - ViscosityDynamic(value, "unit", "name") -> Known viscosity, dynamic (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ViscosityDynamicSetter':
        """
        Create a setter for this viscosity, dynamic quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ViscosityDynamicSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ViscosityDynamicSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ViscosityDynamicSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this viscosity, dynamic.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this viscosity, dynamic.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class ViscosityKinematic(FieldQnty):
    """
    Type-safe viscosity, kinematic quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - ViscosityKinematic("variable_name") -> Create unknown viscosity, kinematic
    - ViscosityKinematic(value, "unit", "variable_name") -> Create known viscosity, kinematic
    
    Examples:
    ---------
    >>> unknown = ViscosityKinematic("pressure")  # Unknown viscosity, kinematic
    >>> known = ViscosityKinematic(100, "centistokes", "inlet_pressure")  # Known viscosity, kinematic
    
    Available units: "centistokes", "millistokes", "square_centimeter_per_second"
    """

    __slots__ = ()
    _setter_class = field_setter.ViscosityKinematicSetter
    _dimension = dim.VISCOSITY_KINEMATIC

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize viscosity, kinematic quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - ViscosityKinematic("name") -> Unknown viscosity, kinematic
        - ViscosityKinematic("name", "unit") -> Unknown viscosity, kinematic with unit preference (NEW)
        - ViscosityKinematic("name", "unit", value) -> Known viscosity, kinematic (NEW)
        - ViscosityKinematic(value, "unit", "name") -> Known viscosity, kinematic (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.ViscosityKinematicSetter':
        """
        Create a setter for this viscosity, kinematic quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            ViscosityKinematicSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.ViscosityKinematicSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.ViscosityKinematicSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this viscosity, kinematic.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this viscosity, kinematic.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Volume(FieldQnty):
    """
    Type-safe volume quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Volume("variable_name") -> Create unknown volume
    - Volume(value, "unit", "variable_name") -> Create known volume
    
    Examples:
    ---------
    >>> unknown = Volume("pressure")  # Unknown volume
    >>> known = Volume(100, "acre_foot", "inlet_pressure")  # Known volume
    
    Available units: "acre_foot", "acre_inch", "barrel_us_liquid"
    """

    __slots__ = ()
    _setter_class = field_setter.VolumeSetter
    _dimension = dim.VOLUME

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize volume quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Volume("name") -> Unknown volume
        - Volume("name", "unit") -> Unknown volume with unit preference (NEW)
        - Volume("name", "unit", value) -> Known volume (NEW)
        - Volume(value, "unit", "name") -> Known volume (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.VolumeSetter':
        """
        Create a setter for this volume quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            VolumeSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.VolumeSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.VolumeSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this volume.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this volume.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class VolumeFractionOfI(FieldQnty):
    """
    Type-safe volume fraction of "i" quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - VolumeFractionOfI("variable_name") -> Create unknown volume fraction of "i"
    - VolumeFractionOfI(value, "unit", "variable_name") -> Create known volume fraction of "i"
    
    Examples:
    ---------
    >>> unknown = VolumeFractionOfI("pressure")  # Unknown volume fraction of "i"
    >>> known = VolumeFractionOfI(100, "cubic_centimeters_of_i_per_cubic_meter_total", "inlet_pressure")  # Known volume fraction of "i"
    
    Available units: "cubic_centimeters_of_i_per_cubic_meter_total", "cubic_foot_of_i_per_cubic_foot_total", "cubic_meters_of_i_per_cubic_meter_total"
    """

    __slots__ = ()
    _setter_class = field_setter.VolumeFractionOfISetter
    _dimension = dim.VOLUME_FRACTION_OF_I

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize volume fraction of "i" quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - VolumeFractionOfI("name") -> Unknown volume fraction of "i"
        - VolumeFractionOfI("name", "unit") -> Unknown volume fraction of "i" with unit preference (NEW)
        - VolumeFractionOfI("name", "unit", value) -> Known volume fraction of "i" (NEW)
        - VolumeFractionOfI(value, "unit", "name") -> Known volume fraction of "i" (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.VolumeFractionOfISetter':
        """
        Create a setter for this volume fraction of "i" quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            VolumeFractionOfISetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.VolumeFractionOfISetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.VolumeFractionOfISetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this volume fraction of "i".
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this volume fraction of "i".
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class VolumetricCalorificHeatingValue(FieldQnty):
    """
    Type-safe volumetric calorific (heating) value quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - VolumetricCalorificHeatingValue("variable_name") -> Create unknown volumetric calorific (heating) value
    - VolumetricCalorificHeatingValue(value, "unit", "variable_name") -> Create known volumetric calorific (heating) value
    
    Examples:
    ---------
    >>> unknown = VolumetricCalorificHeatingValue("pressure")  # Unknown volumetric calorific (heating) value
    >>> known = VolumetricCalorificHeatingValue(100, "british_thermal_unit_per_cubic_foot", "inlet_pressure")  # Known volumetric calorific (heating) value
    
    Available units: "british_thermal_unit_per_cubic_foot", "british_thermal_unit_per_gallon_uk", "british_thermal_unit_per_gallon_us"
    """

    __slots__ = ()
    _setter_class = field_setter.VolumetricCalorificHeatingValueSetter
    _dimension = dim.VOLUMETRIC_CALORIFIC_HEATING_VALUE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize volumetric calorific (heating) value quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - VolumetricCalorificHeatingValue("name") -> Unknown volumetric calorific (heating) value
        - VolumetricCalorificHeatingValue("name", "unit") -> Unknown volumetric calorific (heating) value with unit preference (NEW)
        - VolumetricCalorificHeatingValue("name", "unit", value) -> Known volumetric calorific (heating) value (NEW)
        - VolumetricCalorificHeatingValue(value, "unit", "name") -> Known volumetric calorific (heating) value (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.VolumetricCalorificHeatingValueSetter':
        """
        Create a setter for this volumetric calorific (heating) value quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            VolumetricCalorificHeatingValueSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.VolumetricCalorificHeatingValueSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.VolumetricCalorificHeatingValueSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this volumetric calorific (heating) value.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this volumetric calorific (heating) value.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class VolumetricCoefficientOfExpansion(FieldQnty):
    """
    Type-safe volumetric coefficient of expansion quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - VolumetricCoefficientOfExpansion("variable_name") -> Create unknown volumetric coefficient of expansion
    - VolumetricCoefficientOfExpansion(value, "unit", "variable_name") -> Create known volumetric coefficient of expansion
    
    Examples:
    ---------
    >>> unknown = VolumetricCoefficientOfExpansion("pressure")  # Unknown volumetric coefficient of expansion
    >>> known = VolumetricCoefficientOfExpansion(100, "gram_per_cubic_centimeter_per_kelvin_or_degree_celsius", "inlet_pressure")  # Known volumetric coefficient of expansion
    
    Available units: "gram_per_cubic_centimeter_per_kelvin_or_degree_celsius", "kilogram_per_cubic_meter_per_kelvin_or_degree_celsius", "pound_per_cubic_foot_per_degree_fahrenheit_or_degree_rankine"
    """

    __slots__ = ()
    _setter_class = field_setter.VolumetricCoefficientOfExpansionSetter
    _dimension = dim.VOLUMETRIC_COEFFICIENT_OF_EXPANSION

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize volumetric coefficient of expansion quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - VolumetricCoefficientOfExpansion("name") -> Unknown volumetric coefficient of expansion
        - VolumetricCoefficientOfExpansion("name", "unit") -> Unknown volumetric coefficient of expansion with unit preference (NEW)
        - VolumetricCoefficientOfExpansion("name", "unit", value) -> Known volumetric coefficient of expansion (NEW)
        - VolumetricCoefficientOfExpansion(value, "unit", "name") -> Known volumetric coefficient of expansion (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.VolumetricCoefficientOfExpansionSetter':
        """
        Create a setter for this volumetric coefficient of expansion quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            VolumetricCoefficientOfExpansionSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.VolumetricCoefficientOfExpansionSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.VolumetricCoefficientOfExpansionSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this volumetric coefficient of expansion.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this volumetric coefficient of expansion.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class VolumetricFlowRate(FieldQnty):
    """
    Type-safe volumetric flow rate quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - VolumetricFlowRate("variable_name") -> Create unknown volumetric flow rate
    - VolumetricFlowRate(value, "unit", "variable_name") -> Create known volumetric flow rate
    
    Examples:
    ---------
    >>> unknown = VolumetricFlowRate("pressure")  # Unknown volumetric flow rate
    >>> known = VolumetricFlowRate(100, "cubic_feet_per_day", "inlet_pressure")  # Known volumetric flow rate
    
    Available units: "cubic_feet_per_day", "cubic_feet_per_hour", "cubic_feet_per_minute"
    """

    __slots__ = ()
    _setter_class = field_setter.VolumetricFlowRateSetter
    _dimension = dim.VOLUMETRIC_FLOW_RATE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize volumetric flow rate quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - VolumetricFlowRate("name") -> Unknown volumetric flow rate
        - VolumetricFlowRate("name", "unit") -> Unknown volumetric flow rate with unit preference (NEW)
        - VolumetricFlowRate("name", "unit", value) -> Known volumetric flow rate (NEW)
        - VolumetricFlowRate(value, "unit", "name") -> Known volumetric flow rate (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.VolumetricFlowRateSetter':
        """
        Create a setter for this volumetric flow rate quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            VolumetricFlowRateSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.VolumetricFlowRateSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.VolumetricFlowRateSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this volumetric flow rate.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this volumetric flow rate.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class VolumetricFlux(FieldQnty):
    """
    Type-safe volumetric flux quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - VolumetricFlux("variable_name") -> Create unknown volumetric flux
    - VolumetricFlux(value, "unit", "variable_name") -> Create known volumetric flux
    
    Examples:
    ---------
    >>> unknown = VolumetricFlux("pressure")  # Unknown volumetric flux
    >>> known = VolumetricFlux(100, "cubic_feet_per_square_foot_per_day", "inlet_pressure")  # Known volumetric flux
    
    Available units: "cubic_feet_per_square_foot_per_day", "cubic_feet_per_square_foot_per_hour", "cubic_feet_per_square_foot_per_minute"
    """

    __slots__ = ()
    _setter_class = field_setter.VolumetricFluxSetter
    _dimension = dim.VOLUMETRIC_FLUX

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize volumetric flux quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - VolumetricFlux("name") -> Unknown volumetric flux
        - VolumetricFlux("name", "unit") -> Unknown volumetric flux with unit preference (NEW)
        - VolumetricFlux("name", "unit", value) -> Known volumetric flux (NEW)
        - VolumetricFlux(value, "unit", "name") -> Known volumetric flux (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.VolumetricFluxSetter':
        """
        Create a setter for this volumetric flux quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            VolumetricFluxSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.VolumetricFluxSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.VolumetricFluxSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this volumetric flux.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this volumetric flux.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class VolumetricMassFlowRate(FieldQnty):
    """
    Type-safe volumetric mass flow rate quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - VolumetricMassFlowRate("variable_name") -> Create unknown volumetric mass flow rate
    - VolumetricMassFlowRate(value, "unit", "variable_name") -> Create known volumetric mass flow rate
    
    Examples:
    ---------
    >>> unknown = VolumetricMassFlowRate("pressure")  # Unknown volumetric mass flow rate
    >>> known = VolumetricMassFlowRate(100, "gram_per_second_per_cubic_centimeter", "inlet_pressure")  # Known volumetric mass flow rate
    
    Available units: "gram_per_second_per_cubic_centimeter", "kilogram_per_hour_per_cubic_foot", "kilogram_per_hour_per_cubic_meter"
    """

    __slots__ = ()
    _setter_class = field_setter.VolumetricMassFlowRateSetter
    _dimension = dim.VOLUMETRIC_MASS_FLOW_RATE

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize volumetric mass flow rate quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - VolumetricMassFlowRate("name") -> Unknown volumetric mass flow rate
        - VolumetricMassFlowRate("name", "unit") -> Unknown volumetric mass flow rate with unit preference (NEW)
        - VolumetricMassFlowRate("name", "unit", value) -> Known volumetric mass flow rate (NEW)
        - VolumetricMassFlowRate(value, "unit", "name") -> Known volumetric mass flow rate (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.VolumetricMassFlowRateSetter':
        """
        Create a setter for this volumetric mass flow rate quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            VolumetricMassFlowRateSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.VolumetricMassFlowRateSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.VolumetricMassFlowRateSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this volumetric mass flow rate.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this volumetric mass flow rate.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

class Wavenumber(FieldQnty):
    """
    Type-safe wavenumber quantity with expression capabilities.
    
    Constructor Options:
    -------------------
    - Wavenumber("variable_name") -> Create unknown wavenumber
    - Wavenumber(value, "unit", "variable_name") -> Create known wavenumber
    
    Examples:
    ---------
    >>> unknown = Wavenumber("pressure")  # Unknown wavenumber
    >>> known = Wavenumber(100, "diopter", "inlet_pressure")  # Known wavenumber
    
    Available units: "diopter", "kayser", "reciprocal_meter"
    """

    __slots__ = ()
    _setter_class = field_setter.WavenumberSetter
    _dimension = dim.WAVENUMBER

    def __init__(self, name_or_value: str | int | float, unit_or_name: str | None = None, name_or_value2: str | int | float | None = None):
        """
        Initialize wavenumber quantity with flexible syntax.
        
        Constructor Patterns:
        --------------------
        - Wavenumber("name") -> Unknown wavenumber
        - Wavenumber("name", "unit") -> Unknown wavenumber with unit preference (NEW)
        - Wavenumber("name", "unit", value) -> Known wavenumber (NEW)
        - Wavenumber(value, "unit", "name") -> Known wavenumber (OLD, backward compatibility)
        
        Args:
            name_or_value: Variable name (str) or value (int/float)
            unit_or_name: Unit string or variable name, depending on usage
            name_or_value2: Variable name (str) or value (int/float) for 3-arg patterns
        """
        if isinstance(name_or_value, str) and (name_or_value2 is None or isinstance(name_or_value2, (int, float))):
            # NEW syntax: name first
            if unit_or_name is None:
                # Pattern: Length("name")
                super().__init__(name_or_value, is_known=False)
            elif name_or_value2 is None:
                # Pattern: Length("name", "unit")
                super().__init__(name_or_value, is_known=False)
                self._set_preferred_unit(unit_or_name)
            else:
                # Pattern: Length("name", "unit", value)
                super().__init__(name_or_value2, unit_or_name, name_or_value, is_known=True)
        elif isinstance(name_or_value, (int, float)):
            # OLD syntax: value first (backward compatibility)
            if unit_or_name is None or name_or_value2 is None:
                raise ValueError("Unit and name required for value-first syntax")
            super().__init__(name_or_value, unit_or_name, name_or_value2, is_known=True)
        else:
            raise ValueError("Invalid constructor arguments")
        self.set_arithmetic_mode('expression')
    
    def set(self, value: float, unit: str | None = None) -> 'Self | field_setter.WavenumberSetter':
        """
        Create a setter for this wavenumber quantity.
        
        Args:
            value: The numeric value to set
            unit: Optional unit string (for compatibility with base class)
        
        Returns:
            WavenumberSetter: A setter with unit properties like .meters, .inches, etc.
        
        Example:
            >>> length = Length("beam_length")
            >>> length.set(100).millimeters  # Sets to 100 mm
        """
        if unit is not None:
            # Direct setting with unit
            setter = field_setter.WavenumberSetter(self, value)
            # Get the unit property and call it to set the value
            if hasattr(setter, unit):
                getattr(setter, unit)
            else:
                from ..utils.unit_suggestions import create_unit_validation_error
                raise create_unit_validation_error(unit, self.__class__.__name__)
            return self
        else:
            return field_setter.WavenumberSetter(self, value)
    
    @property
    def value(self) -> float | None:
        """
        Get the numeric value of this wavenumber.
        
        Returns:
            The numeric value if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.value  # Returns 100.0
        """
        return self.quantity.value if self.quantity is not None else None

    @property
    def unit(self) -> str | None:
        """
        Get the unit symbol of this wavenumber.
        
        Returns:
            The unit symbol if known, None if unknown
        
        Example:
            >>> length = Length(100, "mm", "beam_length")
            >>> length.unit  # Returns "mm"
        """
        return self.quantity.unit.symbol if self.quantity is not None else None
    

