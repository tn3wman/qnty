#!/usr/bin/env python3
"""
Script to generate comprehensive converters.py for all variable converters.

This script generates static converter class definitions with unit properties
for the fluent API similar to setter classes but for unit conversion.
"""

from pathlib import Path

from .data_processor import (
    augment_with_prefixed_units,
    calculate_statistics,
    convert_to_class_name,
    get_unit_names_and_aliases,
    load_unit_data,
    save_text_file,
    setup_import_path,
)


def generate_converters(parsed_data: dict, dimension_mapping: dict) -> str:
    """Generate the converters.py content with static converter class definitions."""
    del dimension_mapping  # Unused but kept for API compatibility

    sorted_fields = sorted(parsed_data.items())
    fields_with_units = [(k, v) for k, v in sorted_fields if v.get("units")]

    lines = [
        '"""',
        "Converter Classes Module - Static Edition",
        "========================================",
        "",
        "Static converter class definitions for maximum import performance.",
        "Provides fluent API unit properties for ToUnit and AsUnit converters.",
        "Auto-generated by codegen/generators/field_converters.py",
        "DO NOT EDIT MANUALLY - changes will be overwritten.",
        '"""',
        "",
        "from typing import TYPE_CHECKING, Final",
        "",
        "if TYPE_CHECKING:",
        '    from ..quantities.field_qnty import FieldQnty',
        "",
        "from .base_qnty import Quantity",
        "from ..units import field_units",
        "",
    ]

    # Generate base converter classes
    lines.extend([
        "# ===== BASE CONVERTER CLASSES =====",
        "",
        "class UnitConverter:",
        '    """Base unit converter class."""',
        "",
        "    def __init__(self, variable: 'FieldQnty') -> None:",
        "        self.variable = variable",
        "",
        "    def _get_unit_constant(self, unit_name: str):",
        '        """Get unit constant from field_units."""',
        "        if hasattr(self.variable, '_dimension') and self.variable._dimension:",
        "            # Get the dimension-specific units class",
        "            class_name = self.variable.__class__.__name__",
        "            units_class_name = f'{class_name}Units'",
        "            units_class = getattr(field_units, units_class_name, None)",
        "            if units_class and hasattr(units_class, unit_name):",
        "                return getattr(units_class, unit_name)",
        "        raise ValueError(f'Unknown unit: {unit_name} for {self.variable.__class__.__name__}')",
        "",
        "    def _convert_quantity(self, unit_constant, modify_original: bool = False):",
        '        """Convert quantity to specified unit."""',
        "        if self.variable.quantity is None:",
        "            raise ValueError('Cannot convert variable with no quantity')",
        "        ",
        "        # Convert to the target unit",
        "        converted_quantity = self.variable.quantity.to(unit_constant)",
        "        converted_value = converted_quantity.value",
        "        ",
        "        if modify_original:",
        "            # Modify the original variable",
        "            self.variable.quantity = Quantity(converted_value, unit_constant)",
        "            return self.variable",
        "        else:",
        "            # Return a new variable representation",
        "            new_var = self.variable.__class__(converted_value, unit_constant.name, f'{self.variable.name}_converted')",
        "            return new_var",
        "",
    ])

    # Generate ToUnit converter classes
    lines.append("# ===== TO_UNIT CONVERTER CLASSES =====")
    lines.append("# Converter classes that modify the original variable")
    lines.append("")

    for field_key, field_data in fields_with_units:
        class_name = convert_to_class_name(field_key)
        converter_class_name = f"ToUnit{class_name}Converter"
        
        lines.extend([
            f"class {converter_class_name}(UnitConverter):",
            f'    """{class_name}-specific ToUnit converter with optimized unit properties."""',
            "",
            "    __slots__ = ()",
            "",
            "    def __call__(self, unit_str: str) -> 'FieldQnty':",
            '        """Convert to specified unit using string notation."""',
            "        unit_constant = self._get_unit_constant(unit_str)",
            "        return self._convert_quantity(unit_constant, modify_original=True)",
            "",
        ])

        # Generate property for each unit, avoiding duplicates
        generated_properties = set()

        for unit_data in field_data["units"]:
            primary_name, aliases = get_unit_names_and_aliases(unit_data)
            # Use primary name for the main property
            property_name = primary_name

            # Skip if this property name was already generated
            if property_name in generated_properties:
                continue

            generated_properties.add(property_name)
            unit_display_name = unit_data.get("name", primary_name)
            # Escape backslashes in LaTeX expressions for docstrings
            escaped_unit_name = unit_display_name.replace("\\", "\\\\")
            
            lines.extend([
                "    @property",
                f"    def {property_name}(self) -> 'FieldQnty':",
                f'        """Convert to {escaped_unit_name} units."""',
                f"        unit_const: Final = field_units.{class_name}Units.{property_name}",
                "        return self._convert_quantity(unit_const, modify_original=True)",
                "",
            ])
            
            # Add alias properties
            for alias in aliases:
                # Only add if different from main property and not already generated
                if alias != property_name and alias.isidentifier() and alias not in generated_properties:
                    generated_properties.add(alias)
                    lines.extend([
                        "    @property",
                        f"    def {alias}(self) -> 'FieldQnty':",
                        f'        """Convert to {alias} units (alias for {primary_name})."""',
                        f"        return self.{property_name}",
                        "",
                    ])
        
        lines.append("")

    # Generate AsUnit converter classes
    lines.append("# ===== AS_UNIT CONVERTER CLASSES =====")
    lines.append("# Converter classes that return a new variable representation")
    lines.append("")

    for field_key, field_data in fields_with_units:
        class_name = convert_to_class_name(field_key)
        converter_class_name = f"AsUnit{class_name}Converter"
        
        lines.extend([
            f"class {converter_class_name}(UnitConverter):",
            f'    """{class_name}-specific AsUnit converter with optimized unit properties."""',
            "",
            "    __slots__ = ()",
            "",
            "    def __call__(self, unit_str: str) -> 'FieldQnty':",
            '        """Convert to specified unit using string notation, returning new variable."""',
            "        unit_constant = self._get_unit_constant(unit_str)",
            "        return self._convert_quantity(unit_constant, modify_original=False)",
            "",
        ])

        # Generate property for each unit, avoiding duplicates
        generated_properties = set()

        for unit_data in field_data["units"]:
            primary_name, aliases = get_unit_names_and_aliases(unit_data)
            # Use primary name for the main property
            property_name = primary_name

            # Skip if this property name was already generated
            if property_name in generated_properties:
                continue

            generated_properties.add(property_name)
            unit_display_name = unit_data.get("name", primary_name)
            # Escape backslashes in LaTeX expressions for docstrings
            escaped_unit_name = unit_display_name.replace("\\", "\\\\")
            
            lines.extend([
                "    @property",
                f"    def {property_name}(self) -> 'FieldQnty':",
                f'        """Convert to {escaped_unit_name} units, returning new variable."""',
                f"        unit_const: Final = field_units.{class_name}Units.{property_name}",
                "        return self._convert_quantity(unit_const, modify_original=False)",
                "",
            ])
            
            # Add alias properties
            for alias in aliases:
                # Only add if different from main property and not already generated
                if alias != property_name and alias.isidentifier() and alias not in generated_properties:
                    generated_properties.add(alias)
                    lines.extend([
                        "    @property",
                        f"    def {alias}(self) -> 'FieldQnty':",
                        f'        """Convert to {alias} units (alias for {primary_name}), returning new variable."""',
                        f"        return self.{property_name}",
                        "",
                    ])
        
        lines.append("")

    return "\n".join(lines)


def main():
    """Generate converters.py file."""
    # Setup paths
    base_path = Path(__file__).parent.parent.parent
    data_path = base_path / "codegen" / "generators" / "data"
    output_path = base_path / "codegen" / "generators" / "out"
    generated_path = base_path / "src" / "qnty" / "quantities"

    # Ensure output directories exist
    output_path.mkdir(exist_ok=True)
    generated_path.mkdir(exist_ok=True)

    parsed_file = data_path / "unit_data.json"
    dimension_file = output_path / "dimension_mapping.json"
    output_file = generated_path / "field_converters.py"

    print("Loading parsed units data for converters...")

    # Setup import path and load data using shared processor
    setup_import_path()
    parsed_data = load_unit_data(parsed_file)
    dimension_mapping = load_unit_data(dimension_file) if dimension_file.exists() else {}

    print(f"Loaded {len(parsed_data)} fields with units")

    # Augment data with missing prefixed units using shared processor
    print("\nAugmenting data with missing prefixed units...")
    augmented_data, generated_count = augment_with_prefixed_units(parsed_data)
    print(f"Generated {generated_count} missing prefixed units for converters")

    # Count fields with units
    fields_with_units = sum(1 for field_data in augmented_data.values() if field_data.get("units"))
    print(f"Found {len(augmented_data)} total fields, {fields_with_units} fields with units")

    # Generate converters file
    print("Generating field_converters.py...")
    content = generate_converters(augmented_data, dimension_mapping)

    # Write output file
    save_text_file(content, output_file)
    print(f"Generated converters file: {output_file}")

    # Print statistics using shared calculator
    stats = calculate_statistics(augmented_data)
    print("\nStatistics:")
    print(f"  Total fields: {stats['total_fields']}")
    print(f"  Fields with units: {fields_with_units}")
    print(f"  Original units: {stats['original_units']}")
    print(f"  Total units (with prefixes): {stats['total_units']}")
    print(f"  Generated prefixed units: {stats['generated_prefixed_units']}")

    print("âœ… Generated quantities/field_converters.py")


if __name__ == "__main__":
    main()
