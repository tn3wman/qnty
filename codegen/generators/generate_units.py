#!/usr/bin/env python3
"""
Units generator for qnty library.

This script generates the units.py file from unit_data.json, creating
comprehensive unit definitions organized by dimensional groups.
"""

import json
from pathlib import Path
from typing import Any

try:
    from .data_processor import (
        convert_to_class_name,
        escape_string,
        get_dimension_constant_name,
        get_unit_names_and_aliases,
        is_valid_python_identifier,
        load_unit_data,
        setup_import_path,
    )
except ImportError:
    from data_processor import (
        convert_to_class_name,
        escape_string,
        get_dimension_constant_name,
        get_unit_names_and_aliases,
        is_valid_python_identifier,
        load_unit_data,
        setup_import_path,
    )


class UnitsGenerator:
    """Generator for units.py file."""

    def __init__(self, data_path: Path, output_path: Path, out_dir: Path):
        """Initialize with paths."""
        self.data_path = data_path
        self.output_path = output_path
        self.out_dir = out_dir
        self.out_dir.mkdir(parents=True, exist_ok=True)

        # Setup import path and load data
        setup_import_path()
        raw_unit_data = load_unit_data(self.data_path)

        # For now, use raw data without augmentation to avoid import issues
        self.unit_data = raw_unit_data
        print(f"Loaded {len(raw_unit_data)} fields")

        # Track generated info
        self.dimension_constants: set[str] = set()
        self.field_to_class_mapping: dict[str, str] = {}
        
        # Track global aliases to prevent duplicates
        self.global_aliases: dict[str, str] = {}  # alias -> "class.primary_unit"

    def get_class_name(self, field_name: str) -> str:
        """Convert field name to class name."""
        # Use shared utility and add 'Units' suffix
        class_name = convert_to_class_name(field_name) + "Units"
        self.field_to_class_mapping[field_name] = class_name
        return class_name

    def get_dimension_constant_name(self, field_name: str) -> str:
        """Get the dimension constant name for a field."""
        constant_name = get_dimension_constant_name(field_name)
        self.dimension_constants.add(constant_name)
        return constant_name

    def generate_header(self) -> list[str]:
        """Generate file header with imports."""
        lines = [
            '"""',
            "Comprehensive Units Module",
            "==========================",
            "",
            "Auto-generated unit definitions for all engineering units.",
            f"Contains {sum(len(field_data['units']) for field_data in self.unit_data.values())} units",
            f"across {len(self.unit_data)} fields.",
            "",
            "This file is auto-generated by codegen/generators/units_gen.py",
            "DO NOT EDIT MANUALLY - changes will be overwritten.",
            '"""',
            "",
        ]

        lines.extend(
            [
                "from ..dimensions import dimensions as dim",
                "from .registry import Unit, UnitNamespace, ureg",
                "",
                "",
            ]
        )

        return lines

    def generate_unit_class(self, field_name: str, field_data: dict[str, Any]) -> list[str]:
        """Generate a unit class for a field."""
        class_name = self.get_class_name(field_name)
        dimension_constant = self.get_dimension_constant_name(field_name)

        lines = [
            f"class {class_name}(UnitNamespace):",
            f'    """Unit constants for {field_data["field"]}."""',
            "",
            "    __slots__ = ()",
        ]

        # Find preferred unit (SI factor = 1.0)
        units = field_data.get("units", [])
        if not units:
            lines.extend(["    pass", "", ""])
            return lines
        
        # Find preferred unit with SI factor of 1.0
        preferred_unit = None
        for unit_data in units:
            if unit_data.get("si_conversion", 1.0) == 1.0:
                primary_name, _ = get_unit_names_and_aliases(unit_data)
                if is_valid_python_identifier(primary_name):
                    preferred_unit = primary_name
                    break
        
        if preferred_unit:
            lines.append(f'    __preferred__ = "{preferred_unit}" # Where SI factor is 1.0')
        
        lines.append("")

        # First collect all primary unit names in this class
        class_primary_names = set()
        for unit_data in units:
            primary_name, _ = get_unit_names_and_aliases(unit_data)
            if is_valid_python_identifier(primary_name):
                class_primary_names.add(primary_name)

        # Generate unit constants using shared name processing
        for unit_data in units:
            primary_name, aliases = get_unit_names_and_aliases(unit_data)
            if not is_valid_python_identifier(primary_name):
                continue

            full_name = unit_data.get("name", "").strip()
            symbol = unit_data.get("notation", "").strip()
            si_factor = unit_data.get("si_conversion", 1.0)

            # Format unit definition with proper line breaks for readability
            if len(full_name) > 60:  # Long name comment
                lines.append(f"    # {full_name}")
            else:
                lines.append(f"    # {full_name}")
            
            # Check for primary name collision before generating unit
            class_unit_id = f"{class_name}.{primary_name}"
            if primary_name in self.global_aliases:
                existing = self.global_aliases[primary_name]
                print(f"Error: Primary unit name collision '{primary_name}' between {class_unit_id} and {existing}")
                # Make the primary name unique by prefixing with field
                field_prefix = field_name.lower().replace(" ", "_").replace(",", "")[:4]  # Use first 4 chars of field
                unique_name = f"{field_prefix}_{primary_name}"
                
                # If this unique name also exists, add a counter
                counter = 1
                base_unique_name = unique_name
                while unique_name in self.global_aliases:
                    unique_name = f"{base_unique_name}_{counter}"
                    counter += 1
                
                print(f"  -> Renaming to '{unique_name}' to avoid collision")
                
                # Update primary_name for unit generation
                primary_name = unique_name
                class_unit_id = f"{class_name}.{unique_name}"
                self.global_aliases[unique_name] = class_unit_id
            else:
                self.global_aliases[primary_name] = class_unit_id

            # More readable Unit formatting
            lines.extend([
                f"    {primary_name} = Unit(",
                f'        name="{escape_string(primary_name)}",',
                f'        symbol="{escape_string(symbol)}",',
                f"        dimension=dim.{dimension_constant},",
                f"        si_factor={si_factor},",
                "        si_offset=0.0,",
                "    )",
                "",
            ])

            # Add aliases, but check for conflicts
            valid_aliases = []
            
            for alias in aliases:
                if not is_valid_python_identifier(alias):
                    continue
                
                # Skip if alias conflicts with a primary name in this class
                if alias in class_primary_names and alias != primary_name:
                    print(f"Warning: Skipping alias '{alias}' in {class_name} (conflicts with primary unit name)")
                    continue
                    
                if alias in self.global_aliases:
                    # Skip duplicate alias with warning
                    existing = self.global_aliases[alias]
                    print(f"Warning: Skipping duplicate alias '{alias}' (already used by {existing})")
                    continue
                    
                # Register this alias globally
                self.global_aliases[alias] = class_unit_id
                valid_aliases.append(alias)
            
            # Add valid aliases as class attributes
            for alias in valid_aliases:
                lines.append(f"    {alias} = {primary_name}")
            
            if valid_aliases:
                lines.append("")

        lines.append("")
        return lines

    def generate_registry_function(self) -> list[str]:
        """Generate function to register all units with registry."""
        # We don't need a registration function since UnitNamespace metaclass
        # automatically registers units when the class is created
        return []

    def generate_dimensionless_class(self) -> list[str]:
        """Generate DimensionlessUnits class for backward compatibility."""
        return [
            "# Backward compatibility class",
            "class DimensionlessUnits:",
            '    """Dimensionless units for backward compatibility."""',
            "    __slots__ = ()",
            "",
            "    dimensionless = Unit(",
            '        name="dimensionless",',
            '        symbol="",',
            "        dimension=dim.DIMENSIONLESS,",
            "        si_factor=1.0,",
            "        si_offset=0.0",
            "    )",
            "",
            "",
        ]

    def generate_exports(self) -> list[str]:
        """Generate __all__ export list."""
        lines = [
            "# Export list",
            "__all__ = [",
            '    "DimensionlessUnits",',
            '    "ureg",  # Export the global registry',
        ]

        for class_name in sorted(self.field_to_class_mapping.values()):
            lines.append(f'    "{class_name}",')

        lines.extend(
            [
                "]",
                "",
            ]
        )

        return lines

    def generate_statistics(self) -> list[str]:
        """Generate statistics section."""
        total_units = sum(len(field_data.get("units", [])) for field_data in self.unit_data.values())

        return [
            "# Statistics",
            f"TOTAL_UNITS = {total_units}",
            f"TOTAL_FIELDS = {len(self.unit_data)}",
            f"TOTAL_DIMENSIONS = {len(self.dimension_constants)}",
        ]

    def generate(self) -> None:
        """Generate the complete units.py file."""
        # First pass: collect all dimension constants
        for field_name in self.unit_data.keys():
            self.get_dimension_constant_name(field_name)
            self.get_class_name(field_name)

        # Build file content
        lines = []
        lines.extend(self.generate_header())

        # Generate unit classes for each field
        for field_name, field_data in sorted(self.unit_data.items()):
            lines.extend(self.generate_unit_class(field_name, field_data))

        lines.extend(self.generate_registry_function())
        lines.extend(self.generate_exports())
        lines.extend(self.generate_statistics())

        # Write the file
        content = "\n".join(lines) + "\n"
        self.output_path.write_text(content, encoding="utf-8")
        print(f"Generated {self.output_path}")
        
        # Generate stub file
        self.generate_stubs()

        # Save metadata
        metadata = {
            "total_units": sum(len(field_data.get("units", [])) for field_data in self.unit_data.values()),
            "total_fields": len(self.unit_data),
            "total_dimensions": len(self.dimension_constants),
            "dimension_constants": sorted(self.dimension_constants),
            "unit_classes": sorted(self.field_to_class_mapping.values()),
        }

        metadata_path = self.out_dir / "units_metadata.json"
        with open(metadata_path, "w", encoding="utf-8") as f:
            json.dump(metadata, f, indent=2)
        print(f"Saved metadata to {metadata_path}")

    def generate_stubs(self) -> None:
        """Generate .pyi stub file for better type checking."""
        stub_path = self.output_path.with_suffix('.pyi')
        
        lines = [
            '"""Type stubs for field units."""',
            "",
            "from .registry import Unit, UnitRegistry",
            "",
            "",
        ]
        
        # Generate class stubs
        for field_name, field_data in sorted(self.unit_data.items()):
            class_name = self.get_class_name(field_name)
            
            lines.extend([
                f"class {class_name}:",
                f'    """Unit constants for {field_data["field"]}."""',
                "    __slots__: tuple[()]",
                "",
            ])
            
            # Generate unit attributes
            units = field_data.get("units", [])
            if not units:
                lines.extend(["    ...", "", ""])
                continue
                
            for unit_data in units:
                primary_name, aliases = get_unit_names_and_aliases(unit_data)
                if not is_valid_python_identifier(primary_name):
                    continue
                    
                # Primary unit
                lines.append(f"    {primary_name}: Unit")
                
                # Valid aliases that were successfully registered during main generation
                class_unit_id = f"{class_name}.{primary_name}"
                for alias in aliases:
                    if (is_valid_python_identifier(alias) and
                        self.global_aliases.get(alias) == class_unit_id):
                        lines.append(f"    {alias}: Unit")
            
            lines.append("")
        
        # Only add backward compatibility class if DimensionlessUnits wasn't already generated
        if "DimensionlessUnits" not in [self.get_class_name(field_name) for field_name in self.unit_data.keys()]:
            lines.extend([
                "class DimensionlessUnits:",
                '    """Dimensionless units for backward compatibility."""',
                "    __slots__: tuple[()]",
                "    dimensionless: Unit",
                "",
            ])
        
        lines.extend([
            "# Global registry",
            "ureg: UnitRegistry",
            "",
        ])
        
        # Write stub file
        content = "\n".join(lines) + "\n"
        stub_path.write_text(content, encoding="utf-8")
        print(f"Generated {stub_path}")


def main() -> None:
    """Main entry point."""
    # Set up paths
    generator_dir = Path(__file__).parent
    data_path = generator_dir / "data" / "unit_data.json"
    output_path = generator_dir.parent.parent / "src" / "qnty" / "units" / "units.py"
    out_dir = generator_dir / "out"

    # Create output directory if needed
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Check if data file exists
    if not data_path.exists():
        print(f"Error: Data file not found at {data_path}")
        return

    # Run generator
    generator = UnitsGenerator(data_path, output_path, out_dir)
    generator.generate()

    print("\nUnits generation complete!")
    print(f"  - Total units: {sum(len(field_data.get('units', [])) for field_data in generator.unit_data.values())}")
    print(f"  - Total fields: {len(generator.unit_data)}")
    print(f"  - Unit classes: {len(generator.field_to_class_mapping)}")


if __name__ == "__main__":
    main()
